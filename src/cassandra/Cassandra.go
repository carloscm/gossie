// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"bytes"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type Cassandra interface {
	// Parameters:
	//  - AuthRequest
	Login(auth_request *AuthenticationRequest) (err error)
	// Parameters:
	//  - Keyspace
	SetKeyspace(keyspace string) (err error)
	// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
	// the only method that can throw an exception under non-failure conditions.)
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - ConsistencyLevel
	Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error)
	// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
	// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error)
	// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
	// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error)
	// Performs a get_slice for column_parent and predicate for the given keys in parallel.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error)
	// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error)
	// returns a subset of columns for a contiguous range of keys.
	//
	// Parameters:
	//  - ColumnParent
	//  - Predicate
	//  - Range
	//  - ConsistencyLevel
	GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
	//
	// Parameters:
	//  - ColumnFamily
	//  - Range
	//  - StartColumn
	//  - ConsistencyLevel
	GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
	// @deprecated use get_range_slices instead with range.row_filter specified
	//
	// Parameters:
	//  - ColumnParent
	//  - IndexClause
	//  - ColumnPredicate
	//  - ConsistencyLevel
	GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error)
	// Increment or decrement a counter.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error)
	// Atomic compare and set.
	//
	// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
	// Otherwise, success will be false and current_values will contain the current values for the columns in
	// expected (that, by definition of compare-and-set, will differ from the values in expected).
	//
	// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
	// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
	// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
	// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
	// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
	// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
	// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
	// the write.
	//
	// Parameters:
	//  - Key
	//  - ColumnFamily
	//  - Expected
	//  - Updates
	//  - SerialConsistencyLevel
	//  - CommitConsistencyLevel
	Cas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error)
	// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
	// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
	// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - Timestamp
	//  - ConsistencyLevel
	Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error)
	// Remove a counter at the specified location.
	// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
	// until the delete has reached all the nodes and all of them have been fully compacted.
	//
	// Parameters:
	//  - Key
	//  - Path
	//  - ConsistencyLevel
	RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error)
	//   Mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
	//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
	// Truncate will mark and entire column family as deleted.
	// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
	// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
	// only marks the data as deleted.
	// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
	// some hosts are down.
	//
	// Parameters:
	//  - Cfname
	Truncate(cfname string) (err error)
	// for each schema version present in the cluster, returns a list of nodes at that version.
	// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
	// the cluster is all on the same version if the size of the map is 1.
	DescribeSchemaVersions() (r map[string][]string, err error)
	// list the defined keyspaces in this cluster
	DescribeKeyspaces() (r []*KsDef, err error)
	// get the cluster name
	DescribeClusterName() (r string, err error)
	// get the thrift api version
	DescribeVersion() (r string, err error)
	// get the token ring: a map of ranges to host addresses,
	// represented as a set of TokenRange instead of a map from range
	// to list of endpoints, because you can't use Thrift structs as
	// map keys:
	// https://issues.apache.org/jira/browse/THRIFT-162
	//
	// for the same reason, we can't return a set here, even though
	// order is neither important nor predictable.
	//
	// Parameters:
	//  - Keyspace
	DescribeRing(keyspace string) (r []*TokenRange, err error)
	// same as describe_ring, but considers only nodes in the local DC
	//
	// Parameters:
	//  - Keyspace
	DescribeLocalRing(keyspace string) (r []*TokenRange, err error)
	// get the mapping between token->node ip
	// without taking replication into consideration
	// https://issues.apache.org/jira/browse/CASSANDRA-4092
	DescribeTokenMap() (r map[string]string, err error)
	// returns the partitioner used by this cluster
	DescribePartitioner() (r string, err error)
	// returns the snitch used by this cluster
	DescribeSnitch() (r string, err error)
	// describe specified keyspace
	//
	// Parameters:
	//  - Keyspace
	DescribeKeyspace(keyspace string) (r *KsDef, err error)
	// experimental API for hadoop/parallel query support.
	// may change violently and without warning.
	//
	// returns list of token strings such that first subrange is (list[0], list[1]],
	// next is (list[1], list[2]], etc.
	//
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error)
	// Enables tracing for the next query in this connection and returns the UUID for that trace session
	// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
	TraceNextQuery() (r []byte, err error)
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error)
	// adds a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemAddColumnFamily(cf_def *CfDef) (r string, err error)
	// drops a column family. returns the new schema id.
	//
	// Parameters:
	//  - ColumnFamily
	SystemDropColumnFamily(column_family string) (r string, err error)
	// adds a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemAddKeyspace(ks_def *KsDef) (r string, err error)
	// drops a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - Keyspace
	SystemDropKeyspace(keyspace string) (r string, err error)
	// updates properties of a keyspace. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemUpdateKeyspace(ks_def *KsDef) (r string, err error)
	// updates properties of a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - Query
	//  - Compression
	ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult_, err error)
	// Executes a CQL3 (Cassandra Query Language) statement and returns a
	// CqlResult containing the results.
	//
	// Parameters:
	//  - Query
	//  - Compression
	//  - Consistency
	ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult_, err error)
	// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
	// - the type of CQL statement
	// - an id token of the compiled CQL stored on the server side.
	// - a count of the discovered bound markers in the statement
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult_, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult_, err error)
	// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
	// to bind, and the consistency level, and returns a CqlResult containing the results.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	//  - Consistency
	ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error)
	// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
	//
	// Parameters:
	//  - Version
	SetCqlVersion(version string) (err error)
}

type CassandraClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewCassandraClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewCassandraClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - AuthRequest
func (p *CassandraClient) Login(auth_request *AuthenticationRequest) (err error) {
	if err = p.sendLogin(auth_request); err != nil {
		return
	}
	return p.recvLogin()
}

func (p *CassandraClient) sendLogin(auth_request *AuthenticationRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("login", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraLoginArgs{
		AuthRequest: auth_request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvLogin() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "login" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "login failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "login failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error33 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error34 error
		error34, err = error33.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error34
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "login failed: invalid message type")
		return
	}
	result := CassandraLoginResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Authnx != nil {
		err = result.Authnx
		return
	} else if result.Authzx != nil {
		err = result.Authzx
		return
	}
	return
}

// Parameters:
//  - Keyspace
func (p *CassandraClient) SetKeyspace(keyspace string) (err error) {
	if err = p.sendSetKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSetKeyspace()
}

func (p *CassandraClient) sendSetKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("set_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSetKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSetKeyspace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "set_keyspace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "set_keyspace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "set_keyspace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "set_keyspace failed: invalid message type")
		return
	}
	result := CassandraSetKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	return
}

// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
// the only method that can throw an exception under non-failure conditions.)
//
// Parameters:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
func (p *CassandraClient) Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error) {
	if err = p.sendGet(key, column_path, consistency_level); err != nil {
		return
	}
	return p.recvGet()
}

func (p *CassandraClient) sendGet(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetArgs{
		Key:              key,
		ColumnPath:       column_path,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGet() (value *ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error37 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error38 error
		error38, err = error37.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error38
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get failed: invalid message type")
		return
	}
	result := CassandraGetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Nfe != nil {
		err = result.Nfe
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error) {
	if err = p.sendGetSlice(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetSlice()
}

func (p *CassandraClient) sendGetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetSliceArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetSlice() (value []*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get_slice" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get_slice failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_slice failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get_slice failed: invalid message type")
		return
	}
	result := CassandraGetSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error) {
	if err = p.sendGetCount(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetCount()
}

func (p *CassandraClient) sendGetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetCountArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetCount() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get_count" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get_count failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_count failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error41 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error42 error
		error42, err = error41.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error42
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get_count failed: invalid message type")
		return
	}
	result := CassandraGetCountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Performs a get_slice for column_parent and predicate for the given keys in parallel.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error) {
	if err = p.sendMultigetSlice(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetSlice()
}

func (p *CassandraClient) sendMultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraMultigetSliceArgs{
		Keys:             keys,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetSlice() (value map[string][]*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "multiget_slice" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "multiget_slice failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_slice failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "multiget_slice failed: invalid message type")
		return
	}
	result := CassandraMultigetSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error) {
	if err = p.sendMultigetCount(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetCount()
}

func (p *CassandraClient) sendMultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraMultigetCountArgs{
		Keys:             keys,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetCount() (value map[string]int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "multiget_count" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "multiget_count failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_count failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error45 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error46 error
		error46, err = error45.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error46
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "multiget_count failed: invalid message type")
		return
	}
	result := CassandraMultigetCountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns a subset of columns for a contiguous range of keys.
//
// Parameters:
//  - ColumnParent
//  - Predicate
//  - Range
//  - ConsistencyLevel
func (p *CassandraClient) GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetRangeSlices(column_parent, predicate, range_a1, consistency_level); err != nil {
		return
	}
	return p.recvGetRangeSlices()
}

func (p *CassandraClient) sendGetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_range_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetRangeSlicesArgs{
		ColumnParent:     column_parent,
		Predicate:        predicate,
		Range:            range_a1,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetRangeSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get_range_slices" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get_range_slices failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_range_slices failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get_range_slices failed: invalid message type")
		return
	}
	result := CassandraGetRangeSlicesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
//
// Parameters:
//  - ColumnFamily
//  - Range
//  - StartColumn
//  - ConsistencyLevel
func (p *CassandraClient) GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetPagedSlice(column_family, range_a1, start_column, consistency_level); err != nil {
		return
	}
	return p.recvGetPagedSlice()
}

func (p *CassandraClient) sendGetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_paged_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetPagedSliceArgs{
		ColumnFamily:     column_family,
		Range:            range_a1,
		StartColumn:      start_column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetPagedSlice() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get_paged_slice" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get_paged_slice failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_paged_slice failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error49 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error50 error
		error50, err = error49.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error50
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get_paged_slice failed: invalid message type")
		return
	}
	result := CassandraGetPagedSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
// @deprecated use get_range_slices instead with range.row_filter specified
//
// Parameters:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
func (p *CassandraClient) GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetIndexedSlices(column_parent, index_clause, column_predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetIndexedSlices()
}

func (p *CassandraClient) sendGetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_indexed_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraGetIndexedSlicesArgs{
		ColumnParent:     column_parent,
		IndexClause:      index_clause,
		ColumnPredicate:  column_predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetIndexedSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "get_indexed_slices" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "get_indexed_slices failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_indexed_slices failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "get_indexed_slices failed: invalid message type")
		return
	}
	result := CassandraGetIndexedSlicesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendInsert(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvInsert()
}

func (p *CassandraClient) sendInsert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("insert", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraInsertArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Column:           column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvInsert() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "insert" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "insert failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "insert failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error53 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error54 error
		error54, err = error53.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error54
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "insert failed: invalid message type")
		return
	}
	result := CassandraInsertResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Increment or decrement a counter.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendAdd(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CassandraClient) sendAdd(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("add", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraAddArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Column:           column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvAdd() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "add" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "add failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "add failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "add failed: invalid message type")
		return
	}
	result := CassandraAddResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Atomic compare and set.
//
// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
// Otherwise, success will be false and current_values will contain the current values for the columns in
// expected (that, by definition of compare-and-set, will differ from the values in expected).
//
// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
// the write.
//
// Parameters:
//  - Key
//  - ColumnFamily
//  - Expected
//  - Updates
//  - SerialConsistencyLevel
//  - CommitConsistencyLevel
func (p *CassandraClient) Cas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error) {
	if err = p.sendCas(key, column_family, expected, updates, serial_consistency_level, commit_consistency_level); err != nil {
		return
	}
	return p.recvCas()
}

func (p *CassandraClient) sendCas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("cas", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraCasArgs{
		Key:                    key,
		ColumnFamily:           column_family,
		Expected:               expected,
		Updates:                updates,
		SerialConsistencyLevel: serial_consistency_level,
		CommitConsistencyLevel: commit_consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvCas() (value *CASResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "cas" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "cas failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "cas failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error57 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error58 error
		error58, err = error57.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error58
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "cas failed: invalid message type")
		return
	}
	result := CassandraCasResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
//
// Parameters:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
func (p *CassandraClient) Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemove(key, column_path, timestamp, consistency_level); err != nil {
		return
	}
	return p.recvRemove()
}

func (p *CassandraClient) sendRemove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraRemoveArgs{
		Key:              key,
		ColumnPath:       column_path,
		Timestamp:        timestamp,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemove() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "remove" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "remove failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "remove failed: invalid message type")
		return
	}
	result := CassandraRemoveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Remove a counter at the specified location.
// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
// until the delete has reached all the nodes and all of them have been fully compacted.
//
// Parameters:
//  - Key
//  - Path
//  - ConsistencyLevel
func (p *CassandraClient) RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemoveCounter(key, path, consistency_level); err != nil {
		return
	}
	return p.recvRemoveCounter()
}

func (p *CassandraClient) sendRemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove_counter", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraRemoveCounterArgs{
		Key:              key,
		Path:             path,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemoveCounter() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "remove_counter" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "remove_counter failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove_counter failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error61 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error62 error
		error62, err = error61.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error62
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "remove_counter failed: invalid message type")
		return
	}
	result := CassandraRemoveCounterResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

//   Mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvBatchMutate()
}

func (p *CassandraClient) sendBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("batch_mutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraBatchMutateArgs{
		MutationMap:      mutation_map,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvBatchMutate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "batch_mutate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "batch_mutate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "batch_mutate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "batch_mutate failed: invalid message type")
		return
	}
	result := CassandraBatchMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendAtomicBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvAtomicBatchMutate()
}

func (p *CassandraClient) sendAtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("atomic_batch_mutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraAtomicBatchMutateArgs{
		MutationMap:      mutation_map,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvAtomicBatchMutate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "atomic_batch_mutate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "atomic_batch_mutate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "atomic_batch_mutate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error65 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error66 error
		error66, err = error65.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error66
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "atomic_batch_mutate failed: invalid message type")
		return
	}
	result := CassandraAtomicBatchMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Truncate will mark and entire column family as deleted.
// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
// only marks the data as deleted.
// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
// some hosts are down.
//
// Parameters:
//  - Cfname
func (p *CassandraClient) Truncate(cfname string) (err error) {
	if err = p.sendTruncate(cfname); err != nil {
		return
	}
	return p.recvTruncate()
}

func (p *CassandraClient) sendTruncate(cfname string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("truncate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraTruncateArgs{
		Cfname: cfname,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvTruncate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "truncate" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "truncate failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "truncate failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "truncate failed: invalid message type")
		return
	}
	result := CassandraTruncateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// for each schema version present in the cluster, returns a list of nodes at that version.
// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
// the cluster is all on the same version if the size of the map is 1.
func (p *CassandraClient) DescribeSchemaVersions() (r map[string][]string, err error) {
	if err = p.sendDescribeSchemaVersions(); err != nil {
		return
	}
	return p.recvDescribeSchemaVersions()
}

func (p *CassandraClient) sendDescribeSchemaVersions() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_schema_versions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeSchemaVersionsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSchemaVersions() (value map[string][]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_schema_versions" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_schema_versions failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_schema_versions failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error69 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error70 error
		error70, err = error69.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error70
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_schema_versions failed: invalid message type")
		return
	}
	result := CassandraDescribeSchemaVersionsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// list the defined keyspaces in this cluster
func (p *CassandraClient) DescribeKeyspaces() (r []*KsDef, err error) {
	if err = p.sendDescribeKeyspaces(); err != nil {
		return
	}
	return p.recvDescribeKeyspaces()
}

func (p *CassandraClient) sendDescribeKeyspaces() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspaces", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeKeyspacesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspaces() (value []*KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_keyspaces" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_keyspaces failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspaces failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_keyspaces failed: invalid message type")
		return
	}
	result := CassandraDescribeKeyspacesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// get the cluster name
func (p *CassandraClient) DescribeClusterName() (r string, err error) {
	if err = p.sendDescribeClusterName(); err != nil {
		return
	}
	return p.recvDescribeClusterName()
}

func (p *CassandraClient) sendDescribeClusterName() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_cluster_name", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeClusterNameArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeClusterName() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_cluster_name" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_cluster_name failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_cluster_name failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error73 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error74 error
		error74, err = error73.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error74
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_cluster_name failed: invalid message type")
		return
	}
	result := CassandraDescribeClusterNameResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// get the thrift api version
func (p *CassandraClient) DescribeVersion() (r string, err error) {
	if err = p.sendDescribeVersion(); err != nil {
		return
	}
	return p.recvDescribeVersion()
}

func (p *CassandraClient) sendDescribeVersion() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_version", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeVersionArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeVersion() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_version" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_version failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_version failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_version failed: invalid message type")
		return
	}
	result := CassandraDescribeVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// get the token ring: a map of ranges to host addresses,
// represented as a set of TokenRange instead of a map from range
// to list of endpoints, because you can't use Thrift structs as
// map keys:
// https://issues.apache.org/jira/browse/THRIFT-162
//
// for the same reason, we can't return a set here, even though
// order is neither important nor predictable.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeRing(keyspace string) (r []*TokenRange, err error) {
	if err = p.sendDescribeRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeRing()
}

func (p *CassandraClient) sendDescribeRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_ring", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeRingArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeRing() (value []*TokenRange, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_ring" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_ring failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_ring failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error77 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error78 error
		error78, err = error77.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error78
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_ring failed: invalid message type")
		return
	}
	result := CassandraDescribeRingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// same as describe_ring, but considers only nodes in the local DC
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeLocalRing(keyspace string) (r []*TokenRange, err error) {
	if err = p.sendDescribeLocalRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeLocalRing()
}

func (p *CassandraClient) sendDescribeLocalRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_local_ring", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeLocalRingArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeLocalRing() (value []*TokenRange, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_local_ring" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_local_ring failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_local_ring failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_local_ring failed: invalid message type")
		return
	}
	result := CassandraDescribeLocalRingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// get the mapping between token->node ip
// without taking replication into consideration
// https://issues.apache.org/jira/browse/CASSANDRA-4092
func (p *CassandraClient) DescribeTokenMap() (r map[string]string, err error) {
	if err = p.sendDescribeTokenMap(); err != nil {
		return
	}
	return p.recvDescribeTokenMap()
}

func (p *CassandraClient) sendDescribeTokenMap() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_token_map", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeTokenMapArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeTokenMap() (value map[string]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_token_map" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_token_map failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_token_map failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error81 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error82 error
		error82, err = error81.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error82
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_token_map failed: invalid message type")
		return
	}
	result := CassandraDescribeTokenMapResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// returns the partitioner used by this cluster
func (p *CassandraClient) DescribePartitioner() (r string, err error) {
	if err = p.sendDescribePartitioner(); err != nil {
		return
	}
	return p.recvDescribePartitioner()
}

func (p *CassandraClient) sendDescribePartitioner() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_partitioner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribePartitionerArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribePartitioner() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_partitioner" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_partitioner failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_partitioner failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_partitioner failed: invalid message type")
		return
	}
	result := CassandraDescribePartitionerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// returns the snitch used by this cluster
func (p *CassandraClient) DescribeSnitch() (r string, err error) {
	if err = p.sendDescribeSnitch(); err != nil {
		return
	}
	return p.recvDescribeSnitch()
}

func (p *CassandraClient) sendDescribeSnitch() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_snitch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeSnitchArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSnitch() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_snitch" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_snitch failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_snitch failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error85 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error86 error
		error86, err = error85.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error86
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_snitch failed: invalid message type")
		return
	}
	result := CassandraDescribeSnitchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// describe specified keyspace
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeKeyspace(keyspace string) (r *KsDef, err error) {
	if err = p.sendDescribeKeyspace(keyspace); err != nil {
		return
	}
	return p.recvDescribeKeyspace()
}

func (p *CassandraClient) sendDescribeKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspace() (value *KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_keyspace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_keyspace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_keyspace failed: invalid message type")
		return
	}
	result := CassandraDescribeKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Nfe != nil {
		err = result.Nfe
		return
	} else if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// experimental API for hadoop/parallel query support.
// may change violently and without warning.
//
// returns list of token strings such that first subrange is (list[0], list[1]],
// next is (list[1], list[2]], etc.
//
// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error) {
	if err = p.sendDescribeSplits(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplits()
}

func (p *CassandraClient) sendDescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_splits", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeSplitsArgs{
		CfName:       cfName,
		StartToken:   start_token,
		EndToken:     end_token,
		KeysPerSplit: keys_per_split,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSplits() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_splits" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_splits failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_splits failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error89 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error90 error
		error90, err = error89.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error90
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_splits failed: invalid message type")
		return
	}
	result := CassandraDescribeSplitsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// Enables tracing for the next query in this connection and returns the UUID for that trace session
// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
func (p *CassandraClient) TraceNextQuery() (r []byte, err error) {
	if err = p.sendTraceNextQuery(); err != nil {
		return
	}
	return p.recvTraceNextQuery()
}

func (p *CassandraClient) sendTraceNextQuery() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("trace_next_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraTraceNextQueryArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvTraceNextQuery() (value []byte, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "trace_next_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "trace_next_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "trace_next_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "trace_next_query failed: invalid message type")
		return
	}
	result := CassandraTraceNextQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error) {
	if err = p.sendDescribeSplitsEx(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplitsEx()
}

func (p *CassandraClient) sendDescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_splits_ex", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraDescribeSplitsExArgs{
		CfName:       cfName,
		StartToken:   start_token,
		EndToken:     end_token,
		KeysPerSplit: keys_per_split,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSplitsEx() (value []*CfSplit, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "describe_splits_ex" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "describe_splits_ex failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_splits_ex failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error93 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error94 error
		error94, err = error93.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error94
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "describe_splits_ex failed: invalid message type")
		return
	}
	result := CassandraDescribeSplitsExResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// adds a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemAddColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemAddColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemAddColumnFamily()
}

func (p *CassandraClient) sendSystemAddColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemAddColumnFamilyArgs{
		CfDef: cf_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_add_column_family" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_add_column_family failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_column_family failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_add_column_family failed: invalid message type")
		return
	}
	result := CassandraSystemAddColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// drops a column family. returns the new schema id.
//
// Parameters:
//  - ColumnFamily
func (p *CassandraClient) SystemDropColumnFamily(column_family string) (r string, err error) {
	if err = p.sendSystemDropColumnFamily(column_family); err != nil {
		return
	}
	return p.recvSystemDropColumnFamily()
}

func (p *CassandraClient) sendSystemDropColumnFamily(column_family string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemDropColumnFamilyArgs{
		ColumnFamily: column_family,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_drop_column_family" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_drop_column_family failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_column_family failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error97 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error98 error
		error98, err = error97.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error98
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_drop_column_family failed: invalid message type")
		return
	}
	result := CassandraSystemDropColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// adds a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemAddKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemAddKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemAddKeyspace()
}

func (p *CassandraClient) sendSystemAddKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemAddKeyspaceArgs{
		KsDef: ks_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_add_keyspace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_add_keyspace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_keyspace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_add_keyspace failed: invalid message type")
		return
	}
	result := CassandraSystemAddKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// drops a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) SystemDropKeyspace(keyspace string) (r string, err error) {
	if err = p.sendSystemDropKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSystemDropKeyspace()
}

func (p *CassandraClient) sendSystemDropKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemDropKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_drop_keyspace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_drop_keyspace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_keyspace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error101 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error102 error
		error102, err = error101.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error102
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_drop_keyspace failed: invalid message type")
		return
	}
	result := CassandraSystemDropKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// updates properties of a keyspace. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemUpdateKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemUpdateKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemUpdateKeyspace()
}

func (p *CassandraClient) sendSystemUpdateKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemUpdateKeyspaceArgs{
		KsDef: ks_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_update_keyspace" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_update_keyspace failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_keyspace failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		error104, err = error103.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error104
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_update_keyspace failed: invalid message type")
		return
	}
	result := CassandraSystemUpdateKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// updates properties of a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemUpdateColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemUpdateColumnFamily()
}

func (p *CassandraClient) sendSystemUpdateColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSystemUpdateColumnFamilyArgs{
		CfDef: cf_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "system_update_column_family" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "system_update_column_family failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_column_family failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error105 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error106 error
		error106, err = error105.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error106
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "system_update_column_family failed: invalid message type")
		return
	}
	result := CassandraSystemUpdateColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult_, err error) {
	if err = p.sendExecuteCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvExecuteCqlQuery()
}

func (p *CassandraClient) sendExecuteCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraExecuteCqlQueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecuteCqlQuery() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "execute_cql_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "execute_cql_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_cql_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		error108, err = error107.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error108
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "execute_cql_query failed: invalid message type")
		return
	}
	result := CassandraExecuteCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// Executes a CQL3 (Cassandra Query Language) statement and returns a
// CqlResult containing the results.
//
// Parameters:
//  - Query
//  - Compression
//  - Consistency
func (p *CassandraClient) ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error) {
	if err = p.sendExecuteCql3Query(query, compression, consistency); err != nil {
		return
	}
	return p.recvExecuteCql3Query()
}

func (p *CassandraClient) sendExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraExecuteCql3QueryArgs{
		Query:       query,
		Compression: compression,
		Consistency: consistency,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecuteCql3Query() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "execute_cql3_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "execute_cql3_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_cql3_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error109 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error110 error
		error110, err = error109.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error110
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "execute_cql3_query failed: invalid message type")
		return
	}
	result := CassandraExecuteCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
	if err = p.sendPrepareCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvPrepareCqlQuery()
}

func (p *CassandraClient) sendPrepareCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("prepare_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraPrepareCqlQueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvPrepareCqlQuery() (value *CqlPreparedResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "prepare_cql_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "prepare_cql_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "prepare_cql_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		error112, err = error111.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error112
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "prepare_cql_query failed: invalid message type")
		return
	}
	result := CassandraPrepareCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
// - the type of CQL statement
// - an id token of the compiled CQL stored on the server side.
// - a count of the discovered bound markers in the statement
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
	if err = p.sendPrepareCql3Query(query, compression); err != nil {
		return
	}
	return p.recvPrepareCql3Query()
}

func (p *CassandraClient) sendPrepareCql3Query(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("prepare_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraPrepareCql3QueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvPrepareCql3Query() (value *CqlPreparedResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "prepare_cql3_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "prepare_cql3_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "prepare_cql3_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error113 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error114 error
		error114, err = error113.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error114
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "prepare_cql3_query failed: invalid message type")
		return
	}
	result := CassandraPrepareCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - ItemId
//  - Values
func (p *CassandraClient) ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult_, err error) {
	if err = p.sendExecutePreparedCqlQuery(itemId, values); err != nil {
		return
	}
	return p.recvExecutePreparedCqlQuery()
}

func (p *CassandraClient) sendExecutePreparedCqlQuery(itemId int32, values [][]byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraExecutePreparedCqlQueryArgs{
		ItemId: itemId,
		Values: values,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecutePreparedCqlQuery() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "execute_prepared_cql_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "execute_prepared_cql_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_prepared_cql_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		error116, err = error115.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error116
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "execute_prepared_cql_query failed: invalid message type")
		return
	}
	result := CassandraExecutePreparedCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
// to bind, and the consistency level, and returns a CqlResult containing the results.
//
// Parameters:
//  - ItemId
//  - Values
//  - Consistency
func (p *CassandraClient) ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error) {
	if err = p.sendExecutePreparedCql3Query(itemId, values, consistency); err != nil {
		return
	}
	return p.recvExecutePreparedCql3Query()
}

func (p *CassandraClient) sendExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraExecutePreparedCql3QueryArgs{
		ItemId:      itemId,
		Values:      values,
		Consistency: consistency,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecutePreparedCql3Query() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "execute_prepared_cql3_query" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "execute_prepared_cql3_query failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_prepared_cql3_query failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error117 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error118 error
		error118, err = error117.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error118
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "execute_prepared_cql3_query failed: invalid message type")
		return
	}
	result := CassandraExecutePreparedCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
//
// Parameters:
//  - Version
func (p *CassandraClient) SetCqlVersion(version string) (err error) {
	if err = p.sendSetCqlVersion(version); err != nil {
		return
	}
	return p.recvSetCqlVersion()
}

func (p *CassandraClient) sendSetCqlVersion(version string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("set_cql_version", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CassandraSetCqlVersionArgs{
		Version: version,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSetCqlVersion() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "set_cql_version" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "set_cql_version failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "set_cql_version failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		error120, err = error119.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error120
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "set_cql_version failed: invalid message type")
		return
	}
	result := CassandraSetCqlVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	return
}

type CassandraProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Cassandra
}

func (p *CassandraProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *CassandraProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *CassandraProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewCassandraProcessor(handler Cassandra) *CassandraProcessor {

	self121 := &CassandraProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self121.processorMap["login"] = &cassandraProcessorLogin{handler: handler}
	self121.processorMap["set_keyspace"] = &cassandraProcessorSetKeyspace{handler: handler}
	self121.processorMap["get"] = &cassandraProcessorGet{handler: handler}
	self121.processorMap["get_slice"] = &cassandraProcessorGetSlice{handler: handler}
	self121.processorMap["get_count"] = &cassandraProcessorGetCount{handler: handler}
	self121.processorMap["multiget_slice"] = &cassandraProcessorMultigetSlice{handler: handler}
	self121.processorMap["multiget_count"] = &cassandraProcessorMultigetCount{handler: handler}
	self121.processorMap["get_range_slices"] = &cassandraProcessorGetRangeSlices{handler: handler}
	self121.processorMap["get_paged_slice"] = &cassandraProcessorGetPagedSlice{handler: handler}
	self121.processorMap["get_indexed_slices"] = &cassandraProcessorGetIndexedSlices{handler: handler}
	self121.processorMap["insert"] = &cassandraProcessorInsert{handler: handler}
	self121.processorMap["add"] = &cassandraProcessorAdd{handler: handler}
	self121.processorMap["cas"] = &cassandraProcessorCas{handler: handler}
	self121.processorMap["remove"] = &cassandraProcessorRemove{handler: handler}
	self121.processorMap["remove_counter"] = &cassandraProcessorRemoveCounter{handler: handler}
	self121.processorMap["batch_mutate"] = &cassandraProcessorBatchMutate{handler: handler}
	self121.processorMap["atomic_batch_mutate"] = &cassandraProcessorAtomicBatchMutate{handler: handler}
	self121.processorMap["truncate"] = &cassandraProcessorTruncate{handler: handler}
	self121.processorMap["describe_schema_versions"] = &cassandraProcessorDescribeSchemaVersions{handler: handler}
	self121.processorMap["describe_keyspaces"] = &cassandraProcessorDescribeKeyspaces{handler: handler}
	self121.processorMap["describe_cluster_name"] = &cassandraProcessorDescribeClusterName{handler: handler}
	self121.processorMap["describe_version"] = &cassandraProcessorDescribeVersion{handler: handler}
	self121.processorMap["describe_ring"] = &cassandraProcessorDescribeRing{handler: handler}
	self121.processorMap["describe_local_ring"] = &cassandraProcessorDescribeLocalRing{handler: handler}
	self121.processorMap["describe_token_map"] = &cassandraProcessorDescribeTokenMap{handler: handler}
	self121.processorMap["describe_partitioner"] = &cassandraProcessorDescribePartitioner{handler: handler}
	self121.processorMap["describe_snitch"] = &cassandraProcessorDescribeSnitch{handler: handler}
	self121.processorMap["describe_keyspace"] = &cassandraProcessorDescribeKeyspace{handler: handler}
	self121.processorMap["describe_splits"] = &cassandraProcessorDescribeSplits{handler: handler}
	self121.processorMap["trace_next_query"] = &cassandraProcessorTraceNextQuery{handler: handler}
	self121.processorMap["describe_splits_ex"] = &cassandraProcessorDescribeSplitsEx{handler: handler}
	self121.processorMap["system_add_column_family"] = &cassandraProcessorSystemAddColumnFamily{handler: handler}
	self121.processorMap["system_drop_column_family"] = &cassandraProcessorSystemDropColumnFamily{handler: handler}
	self121.processorMap["system_add_keyspace"] = &cassandraProcessorSystemAddKeyspace{handler: handler}
	self121.processorMap["system_drop_keyspace"] = &cassandraProcessorSystemDropKeyspace{handler: handler}
	self121.processorMap["system_update_keyspace"] = &cassandraProcessorSystemUpdateKeyspace{handler: handler}
	self121.processorMap["system_update_column_family"] = &cassandraProcessorSystemUpdateColumnFamily{handler: handler}
	self121.processorMap["execute_cql_query"] = &cassandraProcessorExecuteCqlQuery{handler: handler}
	self121.processorMap["execute_cql3_query"] = &cassandraProcessorExecuteCql3Query{handler: handler}
	self121.processorMap["prepare_cql_query"] = &cassandraProcessorPrepareCqlQuery{handler: handler}
	self121.processorMap["prepare_cql3_query"] = &cassandraProcessorPrepareCql3Query{handler: handler}
	self121.processorMap["execute_prepared_cql_query"] = &cassandraProcessorExecutePreparedCqlQuery{handler: handler}
	self121.processorMap["execute_prepared_cql3_query"] = &cassandraProcessorExecutePreparedCql3Query{handler: handler}
	self121.processorMap["set_cql_version"] = &cassandraProcessorSetCqlVersion{handler: handler}
	return self121
}

func (p *CassandraProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x122 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x122.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x122

}

type cassandraProcessorLogin struct {
	handler Cassandra
}

func (p *cassandraProcessorLogin) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraLoginArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraLoginResult{}
	var err2 error
	if err2 = p.handler.Login(args.AuthRequest); err2 != nil {
		switch v := err2.(type) {
		case *AuthenticationException:
			result.Authnx = v
		case *AuthorizationException:
			result.Authzx = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing login: "+err2.Error())
			oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("login", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSetKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSetKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSetKeyspaceResult{}
	var err2 error
	if err2 = p.handler.SetKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("set_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGet struct {
	handler Cassandra
}

func (p *cassandraProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetResult{}
	var retval *ColumnOrSuperColumn
	var err2 error
	if retval, err2 = p.handler.Get(args.Key, args.ColumnPath, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *NotFoundException:
			result.Nfe = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetSliceResult{}
	var retval []*ColumnOrSuperColumn
	var err2 error
	if retval, err2 = p.handler.GetSlice(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_slice: "+err2.Error())
			oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorGetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetCountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetCountResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.GetCount(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_count: "+err2.Error())
			oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("get_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraMultigetSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraMultigetSliceResult{}
	var retval map[string][]*ColumnOrSuperColumn
	var err2 error
	if retval, err2 = p.handler.MultigetSlice(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_slice: "+err2.Error())
			oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("multiget_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraMultigetCountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraMultigetCountResult{}
	var retval map[string]int32
	var err2 error
	if retval, err2 = p.handler.MultigetCount(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_count: "+err2.Error())
			oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("multiget_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetRangeSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetRangeSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetRangeSlicesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetRangeSlicesResult{}
	var retval []*KeySlice
	var err2 error
	if retval, err2 = p.handler.GetRangeSlices(args.ColumnParent, args.Predicate, args.Range, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_range_slices: "+err2.Error())
			oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_range_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetPagedSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetPagedSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetPagedSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetPagedSliceResult{}
	var retval []*KeySlice
	var err2 error
	if retval, err2 = p.handler.GetPagedSlice(args.ColumnFamily, args.Range, args.StartColumn, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_paged_slice: "+err2.Error())
			oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_paged_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetIndexedSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetIndexedSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraGetIndexedSlicesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraGetIndexedSlicesResult{}
	var retval []*KeySlice
	var err2 error
	if retval, err2 = p.handler.GetIndexedSlices(args.ColumnParent, args.IndexClause, args.ColumnPredicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_indexed_slices: "+err2.Error())
			oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_indexed_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorInsert struct {
	handler Cassandra
}

func (p *cassandraProcessorInsert) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraInsertArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraInsertResult{}
	var err2 error
	if err2 = p.handler.Insert(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing insert: "+err2.Error())
			oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("insert", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAdd struct {
	handler Cassandra
}

func (p *cassandraProcessorAdd) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraAddArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraAddResult{}
	var err2 error
	if err2 = p.handler.Add(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing add: "+err2.Error())
			oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("add", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorCas struct {
	handler Cassandra
}

func (p *cassandraProcessorCas) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraCasArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraCasResult{}
	var retval *CASResult_
	var err2 error
	if retval, err2 = p.handler.Cas(args.Key, args.ColumnFamily, args.Expected, args.Updates, args.SerialConsistencyLevel, args.CommitConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cas: "+err2.Error())
			oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("cas", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemove struct {
	handler Cassandra
}

func (p *cassandraProcessorRemove) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraRemoveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraRemoveResult{}
	var err2 error
	if err2 = p.handler.Remove(args.Key, args.ColumnPath, args.Timestamp, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: "+err2.Error())
			oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemoveCounter struct {
	handler Cassandra
}

func (p *cassandraProcessorRemoveCounter) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraRemoveCounterArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraRemoveCounterResult{}
	var err2 error
	if err2 = p.handler.RemoveCounter(args.Key, args.Path, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove_counter: "+err2.Error())
			oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove_counter", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraBatchMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraBatchMutateResult{}
	var err2 error
	if err2 = p.handler.BatchMutate(args.MutationMap, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch_mutate: "+err2.Error())
			oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAtomicBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorAtomicBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraAtomicBatchMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraAtomicBatchMutateResult{}
	var err2 error
	if err2 = p.handler.AtomicBatchMutate(args.MutationMap, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomic_batch_mutate: "+err2.Error())
			oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("atomic_batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTruncate struct {
	handler Cassandra
}

func (p *cassandraProcessorTruncate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraTruncateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraTruncateResult{}
	var err2 error
	if err2 = p.handler.Truncate(args.Cfname); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: "+err2.Error())
			oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("truncate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSchemaVersions struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSchemaVersions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeSchemaVersionsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeSchemaVersionsResult{}
	var retval map[string][]string
	var err2 error
	if retval, err2 = p.handler.DescribeSchemaVersions(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_schema_versions: "+err2.Error())
			oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_schema_versions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspaces struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspaces) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeKeyspacesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeKeyspacesResult{}
	var retval []*KsDef
	var err2 error
	if retval, err2 = p.handler.DescribeKeyspaces(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspaces: "+err2.Error())
			oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspaces", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeClusterName struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeClusterName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeClusterNameArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeClusterNameResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeClusterName(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_cluster_name: "+err2.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("describe_cluster_name", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeVersionResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeVersion(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_version: "+err2.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("describe_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeRingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeRingResult{}
	var retval []*TokenRange
	var err2 error
	if retval, err2 = p.handler.DescribeRing(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_ring: "+err2.Error())
			oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeLocalRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeLocalRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeLocalRingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeLocalRingResult{}
	var retval []*TokenRange
	var err2 error
	if retval, err2 = p.handler.DescribeLocalRing(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_local_ring: "+err2.Error())
			oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_local_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeTokenMap struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeTokenMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeTokenMapArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeTokenMapResult{}
	var retval map[string]string
	var err2 error
	if retval, err2 = p.handler.DescribeTokenMap(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_token_map: "+err2.Error())
			oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_token_map", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribePartitioner struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribePartitioner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribePartitionerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribePartitionerResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribePartitioner(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_partitioner: "+err2.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("describe_partitioner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSnitch struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSnitch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeSnitchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeSnitchResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeSnitch(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_snitch: "+err2.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("describe_snitch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeKeyspaceResult{}
	var retval *KsDef
	var err2 error
	if retval, err2 = p.handler.DescribeKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *NotFoundException:
			result.Nfe = v
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplits struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeSplitsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeSplitsResult{}
	var retval []string
	var err2 error
	if retval, err2 = p.handler.DescribeSplits(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits: "+err2.Error())
			oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTraceNextQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorTraceNextQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraTraceNextQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraTraceNextQueryResult{}
	var retval []byte
	var err2 error
	if retval, err2 = p.handler.TraceNextQuery(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing trace_next_query: "+err2.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("trace_next_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplitsEx struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplitsEx) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraDescribeSplitsExArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraDescribeSplitsExResult{}
	var retval []*CfSplit
	var err2 error
	if retval, err2 = p.handler.DescribeSplitsEx(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits_ex: "+err2.Error())
			oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("describe_splits_ex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemAddColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemAddColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemAddColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_add_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemDropColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemDropColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemDropColumnFamily(args.ColumnFamily); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_drop_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemAddKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemAddKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemAddKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_add_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemDropKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemDropKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemDropKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_drop_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemUpdateKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemUpdateKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemUpdateKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_update_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSystemUpdateColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSystemUpdateColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemUpdateColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("system_update_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraExecuteCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraExecuteCqlQueryResult{}
	var retval *CqlResult_
	var err2 error
	if retval, err2 = p.handler.ExecuteCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("execute_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraExecuteCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraExecuteCql3QueryResult{}
	var retval *CqlResult_
	var err2 error
	if retval, err2 = p.handler.ExecuteCql3Query(args.Query, args.Compression, args.Consistency); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("execute_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraPrepareCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraPrepareCqlQueryResult{}
	var retval *CqlPreparedResult_
	var err2 error
	if retval, err2 = p.handler.PrepareCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("prepare_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraPrepareCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraPrepareCql3QueryResult{}
	var retval *CqlPreparedResult_
	var err2 error
	if retval, err2 = p.handler.PrepareCql3Query(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("prepare_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraExecutePreparedCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraExecutePreparedCqlQueryResult{}
	var retval *CqlResult_
	var err2 error
	if retval, err2 = p.handler.ExecutePreparedCqlQuery(args.ItemId, args.Values); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraExecutePreparedCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraExecutePreparedCql3QueryResult{}
	var retval *CqlResult_
	var err2 error
	if retval, err2 = p.handler.ExecutePreparedCql3Query(args.ItemId, args.Values, args.Consistency); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetCqlVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorSetCqlVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CassandraSetCqlVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CassandraSetCqlVersionResult{}
	var err2 error
	if err2 = p.handler.SetCqlVersion(args.Version); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cql_version: "+err2.Error())
			oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("set_cql_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - AuthRequest
type CassandraLoginArgs struct {
	AuthRequest *AuthenticationRequest `thrift:"auth_request,1,required" json:"auth_request"`
}

func NewCassandraLoginArgs() *CassandraLoginArgs {
	return &CassandraLoginArgs{}
}

var CassandraLoginArgs_AuthRequest_DEFAULT *AuthenticationRequest

func (p *CassandraLoginArgs) GetAuthRequest() *AuthenticationRequest {
	if !p.IsSetAuthRequest() {
		return CassandraLoginArgs_AuthRequest_DEFAULT
	}
	return p.AuthRequest
}
func (p *CassandraLoginArgs) IsSetAuthRequest() bool {
	return p.AuthRequest != nil
}

func (p *CassandraLoginArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetAuthRequest bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetAuthRequest = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetAuthRequest {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field AuthRequest is not set"))
	}
	return nil
}

func (p *CassandraLoginArgs) readField1(iprot thrift.TProtocol) error {
	p.AuthRequest = &AuthenticationRequest{}
	if err := p.AuthRequest.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.AuthRequest), err)
	}
	return nil
}

func (p *CassandraLoginArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraLoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("auth_request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:auth_request: ", p), err)
	}
	if err := p.AuthRequest.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.AuthRequest), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:auth_request: ", p), err)
	}
	return err
}

func (p *CassandraLoginArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraLoginArgs(%+v)", *p)
}

// Attributes:
//  - Authnx
//  - Authzx
type CassandraLoginResult struct {
	Authnx *AuthenticationException `thrift:"authnx,1" json:"authnx,omitempty"`
	Authzx *AuthorizationException  `thrift:"authzx,2" json:"authzx,omitempty"`
}

func NewCassandraLoginResult() *CassandraLoginResult {
	return &CassandraLoginResult{}
}

var CassandraLoginResult_Authnx_DEFAULT *AuthenticationException

func (p *CassandraLoginResult) GetAuthnx() *AuthenticationException {
	if !p.IsSetAuthnx() {
		return CassandraLoginResult_Authnx_DEFAULT
	}
	return p.Authnx
}

var CassandraLoginResult_Authzx_DEFAULT *AuthorizationException

func (p *CassandraLoginResult) GetAuthzx() *AuthorizationException {
	if !p.IsSetAuthzx() {
		return CassandraLoginResult_Authzx_DEFAULT
	}
	return p.Authzx
}
func (p *CassandraLoginResult) IsSetAuthnx() bool {
	return p.Authnx != nil
}

func (p *CassandraLoginResult) IsSetAuthzx() bool {
	return p.Authzx != nil
}

func (p *CassandraLoginResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraLoginResult) readField1(iprot thrift.TProtocol) error {
	p.Authnx = &AuthenticationException{}
	if err := p.Authnx.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authnx), err)
	}
	return nil
}

func (p *CassandraLoginResult) readField2(iprot thrift.TProtocol) error {
	p.Authzx = &AuthorizationException{}
	if err := p.Authzx.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Authzx), err)
	}
	return nil
}

func (p *CassandraLoginResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraLoginResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthnx() {
		if err := oprot.WriteFieldBegin("authnx", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authnx: ", p), err)
		}
		if err := p.Authnx.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authnx), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authnx: ", p), err)
		}
	}
	return err
}

func (p *CassandraLoginResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthzx() {
		if err := oprot.WriteFieldBegin("authzx", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:authzx: ", p), err)
		}
		if err := p.Authzx.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Authzx), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:authzx: ", p), err)
		}
	}
	return err
}

func (p *CassandraLoginResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraLoginResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraSetKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewCassandraSetKeyspaceArgs() *CassandraSetKeyspaceArgs {
	return &CassandraSetKeyspaceArgs{}
}

func (p *CassandraSetKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *CassandraSetKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	return nil
}

func (p *CassandraSetKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CassandraSetKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSetKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CassandraSetKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSetKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Ire
type CassandraSetKeyspaceResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraSetKeyspaceResult() *CassandraSetKeyspaceResult {
	return &CassandraSetKeyspaceResult{}
}

var CassandraSetKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSetKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSetKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraSetKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSetKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSetKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSetKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSetKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSetKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSetKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
type CassandraGetArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required" json:"column_path"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" json:"consistency_level"`
}

func NewCassandraGetArgs() *CassandraGetArgs {
	return &CassandraGetArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraGetArgs) GetKey() []byte {
	return p.Key
}

var CassandraGetArgs_ColumnPath_DEFAULT *ColumnPath

func (p *CassandraGetArgs) GetColumnPath() *ColumnPath {
	if !p.IsSetColumnPath() {
		return CassandraGetArgs_ColumnPath_DEFAULT
	}
	return p.ColumnPath
}

func (p *CassandraGetArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetArgs) IsSetColumnPath() bool {
	return p.ColumnPath != nil
}

func (p *CassandraGetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnPath bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnPath = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnPath {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPath is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraGetArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = &ColumnPath{}
	if err := p.ColumnPath.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPath), err)
	}
	return nil
}

func (p *CassandraGetArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraGetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_path: ", p), err)
	}
	if err := p.ColumnPath.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPath), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_path: ", p), err)
	}
	return err
}

func (p *CassandraGetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Nfe
//  - Ue
//  - Te
type CassandraGetResult struct {
	Success *ColumnOrSuperColumn     `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Nfe     *NotFoundException       `thrift:"nfe,2" json:"nfe,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,3" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,4" json:"te,omitempty"`
}

func NewCassandraGetResult() *CassandraGetResult {
	return &CassandraGetResult{}
}

var CassandraGetResult_Success_DEFAULT *ColumnOrSuperColumn

func (p *CassandraGetResult) GetSuccess() *ColumnOrSuperColumn {
	if !p.IsSetSuccess() {
		return CassandraGetResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraGetResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetResult_Nfe_DEFAULT *NotFoundException

func (p *CassandraGetResult) GetNfe() *NotFoundException {
	if !p.IsSetNfe() {
		return CassandraGetResult_Nfe_DEFAULT
	}
	return p.Nfe
}

var CassandraGetResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetResult) IsSetNfe() bool {
	return p.Nfe != nil
}

func (p *CassandraGetResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &ColumnOrSuperColumn{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraGetResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetResult) readField2(iprot thrift.TProtocol) error {
	p.Nfe = &NotFoundException{}
	if err := p.Nfe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Nfe), err)
	}
	return nil
}

func (p *CassandraGetResult) readField3(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetResult) readField4(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetNfe() {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:nfe: ", p), err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Nfe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:nfe: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraGetSliceArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraGetSliceArgs() *CassandraGetSliceArgs {
	return &CassandraGetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraGetSliceArgs) GetKey() []byte {
	return p.Key
}

var CassandraGetSliceArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraGetSliceArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraGetSliceArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraGetSliceArgs_Predicate_DEFAULT *SlicePredicate

func (p *CassandraGetSliceArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return CassandraGetSliceArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *CassandraGetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetSliceArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraGetSliceArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *CassandraGetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnParent bool = false
	var issetPredicate bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetPredicate = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetSliceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraGetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraGetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *CassandraGetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraGetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraGetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err)
	}
	return err
}

func (p *CassandraGetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetSliceResult struct {
	Success []*ColumnOrSuperColumn   `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraGetSliceResult() *CassandraGetSliceResult {
	return &CassandraGetSliceResult{}
}

var CassandraGetSliceResult_Success_DEFAULT []*ColumnOrSuperColumn

func (p *CassandraGetSliceResult) GetSuccess() []*ColumnOrSuperColumn {
	return p.Success
}

var CassandraGetSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetSliceResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetSliceResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem123 := &ColumnOrSuperColumn{}
		if err := _elem123.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem123), err)
		}
		p.Success = append(p.Success, _elem123)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraGetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetSliceResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraGetCountArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraGetCountArgs() *CassandraGetCountArgs {
	return &CassandraGetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraGetCountArgs) GetKey() []byte {
	return p.Key
}

var CassandraGetCountArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraGetCountArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraGetCountArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraGetCountArgs_Predicate_DEFAULT *SlicePredicate

func (p *CassandraGetCountArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return CassandraGetCountArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *CassandraGetCountArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetCountArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraGetCountArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *CassandraGetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnParent bool = false
	var issetPredicate bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetPredicate = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetCountArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraGetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraGetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *CassandraGetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraGetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraGetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err)
	}
	return err
}

func (p *CassandraGetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetCountArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetCountResult struct {
	Success *int32                   `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraGetCountResult() *CassandraGetCountResult {
	return &CassandraGetCountResult{}
}

var CassandraGetCountResult_Success_DEFAULT int32

func (p *CassandraGetCountResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return CassandraGetCountResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraGetCountResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetCountResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetCountResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetCountResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetCountResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetCountResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetCountResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetCountResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetCountResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetCountResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetCountResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetCountResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetCountResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraGetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetCountResult(%+v)", *p)
}

// Attributes:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraMultigetSliceArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraMultigetSliceArgs() *CassandraMultigetSliceArgs {
	return &CassandraMultigetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraMultigetSliceArgs) GetKeys() [][]byte {
	return p.Keys
}

var CassandraMultigetSliceArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraMultigetSliceArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraMultigetSliceArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraMultigetSliceArgs_Predicate_DEFAULT *SlicePredicate

func (p *CassandraMultigetSliceArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return CassandraMultigetSliceArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *CassandraMultigetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraMultigetSliceArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraMultigetSliceArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *CassandraMultigetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeys bool = false
	var issetColumnParent bool = false
	var issetPredicate bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeys = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetPredicate = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeys {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keys is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem124 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem124 = v
		}
		p.Keys = append(p.Keys, _elem124)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraMultigetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keys: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Keys {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keys: ", p), err)
	}
	return err
}

func (p *CassandraMultigetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraMultigetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err)
	}
	return err
}

func (p *CassandraMultigetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraMultigetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraMultigetSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraMultigetSliceResult struct {
	Success map[string][]*ColumnOrSuperColumn `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException          `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException             `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException                `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraMultigetSliceResult() *CassandraMultigetSliceResult {
	return &CassandraMultigetSliceResult{}
}

var CassandraMultigetSliceResult_Success_DEFAULT map[string][]*ColumnOrSuperColumn

func (p *CassandraMultigetSliceResult) GetSuccess() map[string][]*ColumnOrSuperColumn {
	return p.Success
}

var CassandraMultigetSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraMultigetSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraMultigetSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraMultigetSliceResult_Ue_DEFAULT *UnavailableException

func (p *CassandraMultigetSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraMultigetSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraMultigetSliceResult_Te_DEFAULT *TimedOutException

func (p *CassandraMultigetSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraMultigetSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraMultigetSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraMultigetSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraMultigetSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraMultigetSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraMultigetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]*ColumnOrSuperColumn, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key125 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key125 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make([]*ColumnOrSuperColumn, 0, size)
		_val126 := tSlice
		for i := 0; i < size; i++ {
			_elem127 := &ColumnOrSuperColumn{}
			if err := _elem127.Read(iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem127), err)
			}
			_val126 = append(_val126, _elem127)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.Success[_key125] = _val126
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraMultigetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return thrift.PrependError("error writing list begin: ", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return thrift.PrependError("error writing list end: ", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraMultigetSliceResult(%+v)", *p)
}

// Attributes:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
type CassandraMultigetCountArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraMultigetCountArgs() *CassandraMultigetCountArgs {
	return &CassandraMultigetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraMultigetCountArgs) GetKeys() [][]byte {
	return p.Keys
}

var CassandraMultigetCountArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraMultigetCountArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraMultigetCountArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraMultigetCountArgs_Predicate_DEFAULT *SlicePredicate

func (p *CassandraMultigetCountArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return CassandraMultigetCountArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *CassandraMultigetCountArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraMultigetCountArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraMultigetCountArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *CassandraMultigetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeys bool = false
	var issetColumnParent bool = false
	var issetPredicate bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeys = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetPredicate = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeys {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keys is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraMultigetCountArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem128 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem128 = v
		}
		p.Keys = append(p.Keys, _elem128)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraMultigetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraMultigetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *CassandraMultigetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraMultigetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraMultigetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keys: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Keys {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keys: ", p), err)
	}
	return err
}

func (p *CassandraMultigetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraMultigetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err)
	}
	return err
}

func (p *CassandraMultigetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraMultigetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraMultigetCountArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraMultigetCountResult struct {
	Success map[string]int32         `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraMultigetCountResult() *CassandraMultigetCountResult {
	return &CassandraMultigetCountResult{}
}

var CassandraMultigetCountResult_Success_DEFAULT map[string]int32

func (p *CassandraMultigetCountResult) GetSuccess() map[string]int32 {
	return p.Success
}

var CassandraMultigetCountResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraMultigetCountResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraMultigetCountResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraMultigetCountResult_Ue_DEFAULT *UnavailableException

func (p *CassandraMultigetCountResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraMultigetCountResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraMultigetCountResult_Te_DEFAULT *TimedOutException

func (p *CassandraMultigetCountResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraMultigetCountResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraMultigetCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraMultigetCountResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraMultigetCountResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraMultigetCountResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraMultigetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]int32, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key129 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key129 = v
		}
		var _val130 int32
		if v, err := iprot.ReadI32(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val130 = v
		}
		p.Success[_key129] = _val130
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraMultigetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.I32, len(p.Success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteI32(int32(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraMultigetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraMultigetCountResult(%+v)", *p)
}

// Attributes:
//  - ColumnParent
//  - Predicate
//  - Range
//  - ConsistencyLevel
type CassandraGetRangeSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,2,required" json:"predicate"`
	Range            *KeyRange        `thrift:"range,3,required" json:"range"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraGetRangeSlicesArgs() *CassandraGetRangeSlicesArgs {
	return &CassandraGetRangeSlicesArgs{
		ConsistencyLevel: 1,
	}
}

var CassandraGetRangeSlicesArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraGetRangeSlicesArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraGetRangeSlicesArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraGetRangeSlicesArgs_Predicate_DEFAULT *SlicePredicate

func (p *CassandraGetRangeSlicesArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return CassandraGetRangeSlicesArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

var CassandraGetRangeSlicesArgs_Range_DEFAULT *KeyRange

func (p *CassandraGetRangeSlicesArgs) GetRange() *KeyRange {
	if !p.IsSetRange() {
		return CassandraGetRangeSlicesArgs_Range_DEFAULT
	}
	return p.Range
}

func (p *CassandraGetRangeSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetRangeSlicesArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraGetRangeSlicesArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *CassandraGetRangeSlicesArgs) IsSetRange() bool {
	return p.Range != nil
}

func (p *CassandraGetRangeSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnParent bool = false
	var issetPredicate bool = false
	var issetRange bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetPredicate = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetRange = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Predicate is not set"))
	}
	if !issetRange {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Range is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.Range = &KeyRange{
		Count: 100,
	}
	if err := p.Range.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Range), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraGetRangeSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:predicate: ", p), err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:predicate: ", p), err)
	}
	return err
}

func (p *CassandraGetRangeSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:range: ", p), err)
	}
	if err := p.Range.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Range), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:range: ", p), err)
	}
	return err
}

func (p *CassandraGetRangeSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetRangeSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetRangeSlicesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetRangeSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraGetRangeSlicesResult() *CassandraGetRangeSlicesResult {
	return &CassandraGetRangeSlicesResult{}
}

var CassandraGetRangeSlicesResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetRangeSlicesResult) GetSuccess() []*KeySlice {
	return p.Success
}

var CassandraGetRangeSlicesResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetRangeSlicesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetRangeSlicesResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetRangeSlicesResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetRangeSlicesResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetRangeSlicesResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetRangeSlicesResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetRangeSlicesResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetRangeSlicesResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetRangeSlicesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetRangeSlicesResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetRangeSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem131 := &KeySlice{}
		if err := _elem131.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem131), err)
		}
		p.Success = append(p.Success, _elem131)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetRangeSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetRangeSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetRangeSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetRangeSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetRangeSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetRangeSlicesResult(%+v)", *p)
}

// Attributes:
//  - ColumnFamily
//  - Range
//  - StartColumn
//  - ConsistencyLevel
type CassandraGetPagedSliceArgs struct {
	ColumnFamily     string           `thrift:"column_family,1,required" json:"column_family"`
	Range            *KeyRange        `thrift:"range,2,required" json:"range"`
	StartColumn      []byte           `thrift:"start_column,3,required" json:"start_column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraGetPagedSliceArgs() *CassandraGetPagedSliceArgs {
	return &CassandraGetPagedSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraGetPagedSliceArgs) GetColumnFamily() string {
	return p.ColumnFamily
}

var CassandraGetPagedSliceArgs_Range_DEFAULT *KeyRange

func (p *CassandraGetPagedSliceArgs) GetRange() *KeyRange {
	if !p.IsSetRange() {
		return CassandraGetPagedSliceArgs_Range_DEFAULT
	}
	return p.Range
}

func (p *CassandraGetPagedSliceArgs) GetStartColumn() []byte {
	return p.StartColumn
}

func (p *CassandraGetPagedSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetPagedSliceArgs) IsSetRange() bool {
	return p.Range != nil
}

func (p *CassandraGetPagedSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnFamily bool = false
	var issetRange bool = false
	var issetStartColumn bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetColumnFamily = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetRange = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetStartColumn = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"))
	}
	if !issetRange {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Range is not set"))
	}
	if !issetStartColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartColumn is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.Range = &KeyRange{
		Count: 100,
	}
	if err := p.Range.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Range), err)
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.StartColumn = v
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetPagedSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_family: ", p), err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_family (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_family: ", p), err)
	}
	return err
}

func (p *CassandraGetPagedSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range: ", p), err)
	}
	if err := p.Range.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Range), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range: ", p), err)
	}
	return err
}

func (p *CassandraGetPagedSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_column", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:start_column: ", p), err)
	}
	if err := oprot.WriteBinary(p.StartColumn); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_column (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:start_column: ", p), err)
	}
	return err
}

func (p *CassandraGetPagedSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetPagedSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetPagedSliceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetPagedSliceResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraGetPagedSliceResult() *CassandraGetPagedSliceResult {
	return &CassandraGetPagedSliceResult{}
}

var CassandraGetPagedSliceResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetPagedSliceResult) GetSuccess() []*KeySlice {
	return p.Success
}

var CassandraGetPagedSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetPagedSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetPagedSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetPagedSliceResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetPagedSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetPagedSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetPagedSliceResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetPagedSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetPagedSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetPagedSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetPagedSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetPagedSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetPagedSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetPagedSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem132 := &KeySlice{}
		if err := _elem132.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem132), err)
		}
		p.Success = append(p.Success, _elem132)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetPagedSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetPagedSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetPagedSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetPagedSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetPagedSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetPagedSliceResult(%+v)", *p)
}

// Attributes:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
type CassandraGetIndexedSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required" json:"column_parent"`
	IndexClause      *IndexClause     `thrift:"index_clause,2,required" json:"index_clause"`
	ColumnPredicate  *SlicePredicate  `thrift:"column_predicate,3,required" json:"column_predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraGetIndexedSlicesArgs() *CassandraGetIndexedSlicesArgs {
	return &CassandraGetIndexedSlicesArgs{
		ConsistencyLevel: 1,
	}
}

var CassandraGetIndexedSlicesArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraGetIndexedSlicesArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraGetIndexedSlicesArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraGetIndexedSlicesArgs_IndexClause_DEFAULT *IndexClause

func (p *CassandraGetIndexedSlicesArgs) GetIndexClause() *IndexClause {
	if !p.IsSetIndexClause() {
		return CassandraGetIndexedSlicesArgs_IndexClause_DEFAULT
	}
	return p.IndexClause
}

var CassandraGetIndexedSlicesArgs_ColumnPredicate_DEFAULT *SlicePredicate

func (p *CassandraGetIndexedSlicesArgs) GetColumnPredicate() *SlicePredicate {
	if !p.IsSetColumnPredicate() {
		return CassandraGetIndexedSlicesArgs_ColumnPredicate_DEFAULT
	}
	return p.ColumnPredicate
}

func (p *CassandraGetIndexedSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraGetIndexedSlicesArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraGetIndexedSlicesArgs) IsSetIndexClause() bool {
	return p.IndexClause != nil
}

func (p *CassandraGetIndexedSlicesArgs) IsSetColumnPredicate() bool {
	return p.ColumnPredicate != nil
}

func (p *CassandraGetIndexedSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnParent bool = false
	var issetIndexClause bool = false
	var issetColumnPredicate bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetIndexClause = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetColumnPredicate = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetIndexClause {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field IndexClause is not set"))
	}
	if !issetColumnPredicate {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPredicate is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.IndexClause = &IndexClause{
		Count: 100,
	}
	if err := p.IndexClause.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.IndexClause), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.ColumnPredicate = &SlicePredicate{}
	if err := p.ColumnPredicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPredicate), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("index_clause", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:index_clause: ", p), err)
	}
	if err := p.IndexClause.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.IndexClause), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:index_clause: ", p), err)
	}
	return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_predicate", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_predicate: ", p), err)
	}
	if err := p.ColumnPredicate.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPredicate), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_predicate: ", p), err)
	}
	return err
}

func (p *CassandraGetIndexedSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraGetIndexedSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetIndexedSlicesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraGetIndexedSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraGetIndexedSlicesResult() *CassandraGetIndexedSlicesResult {
	return &CassandraGetIndexedSlicesResult{}
}

var CassandraGetIndexedSlicesResult_Success_DEFAULT []*KeySlice

func (p *CassandraGetIndexedSlicesResult) GetSuccess() []*KeySlice {
	return p.Success
}

var CassandraGetIndexedSlicesResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraGetIndexedSlicesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraGetIndexedSlicesResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraGetIndexedSlicesResult_Ue_DEFAULT *UnavailableException

func (p *CassandraGetIndexedSlicesResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraGetIndexedSlicesResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraGetIndexedSlicesResult_Te_DEFAULT *TimedOutException

func (p *CassandraGetIndexedSlicesResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraGetIndexedSlicesResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraGetIndexedSlicesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraGetIndexedSlicesResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraGetIndexedSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem133 := &KeySlice{}
		if err := _elem133.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem133), err)
		}
		p.Success = append(p.Success, _elem133)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraGetIndexedSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetIndexedSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetIndexedSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetIndexedSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraGetIndexedSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraGetIndexedSlicesResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
type CassandraInsertArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Column           *Column          `thrift:"column,3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraInsertArgs() *CassandraInsertArgs {
	return &CassandraInsertArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraInsertArgs) GetKey() []byte {
	return p.Key
}

var CassandraInsertArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraInsertArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraInsertArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraInsertArgs_Column_DEFAULT *Column

func (p *CassandraInsertArgs) GetColumn() *Column {
	if !p.IsSetColumn() {
		return CassandraInsertArgs_Column_DEFAULT
	}
	return p.Column
}

func (p *CassandraInsertArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraInsertArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraInsertArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *CassandraInsertArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnParent bool = false
	var issetColumn bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetColumn = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraInsertArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraInsertArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraInsertArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = &Column{}
	if err := p.Column.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *CassandraInsertArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraInsertArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraInsertArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraInsertArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraInsertArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column: ", p), err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column: ", p), err)
	}
	return err
}

func (p *CassandraInsertArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraInsertArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraInsertArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraInsertResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraInsertResult() *CassandraInsertResult {
	return &CassandraInsertResult{}
}

var CassandraInsertResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraInsertResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraInsertResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraInsertResult_Ue_DEFAULT *UnavailableException

func (p *CassandraInsertResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraInsertResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraInsertResult_Te_DEFAULT *TimedOutException

func (p *CassandraInsertResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraInsertResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraInsertResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraInsertResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraInsertResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraInsertResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraInsertResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraInsertResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraInsertResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraInsertResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraInsertResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraInsertResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraInsertResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraInsertResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraInsertResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
type CassandraAddArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Column           *CounterColumn   `thrift:"column,3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewCassandraAddArgs() *CassandraAddArgs {
	return &CassandraAddArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraAddArgs) GetKey() []byte {
	return p.Key
}

var CassandraAddArgs_ColumnParent_DEFAULT *ColumnParent

func (p *CassandraAddArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return CassandraAddArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var CassandraAddArgs_Column_DEFAULT *CounterColumn

func (p *CassandraAddArgs) GetColumn() *CounterColumn {
	if !p.IsSetColumn() {
		return CassandraAddArgs_Column_DEFAULT
	}
	return p.Column
}

func (p *CassandraAddArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraAddArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *CassandraAddArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *CassandraAddArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnParent bool = false
	var issetColumn bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnParent = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetColumn = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnParent {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnParent is not set"))
	}
	if !issetColumn {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Column is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraAddArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraAddArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnParent), err)
	}
	return nil
}

func (p *CassandraAddArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = &CounterColumn{}
	if err := p.Column.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *CassandraAddArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraAddArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraAddArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraAddArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_parent: ", p), err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnParent), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_parent: ", p), err)
	}
	return err
}

func (p *CassandraAddArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column: ", p), err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column: ", p), err)
	}
	return err
}

func (p *CassandraAddArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraAddArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraAddArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraAddResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraAddResult() *CassandraAddResult {
	return &CassandraAddResult{}
}

var CassandraAddResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraAddResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraAddResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraAddResult_Ue_DEFAULT *UnavailableException

func (p *CassandraAddResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraAddResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraAddResult_Te_DEFAULT *TimedOutException

func (p *CassandraAddResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraAddResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraAddResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraAddResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraAddResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraAddResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraAddResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraAddResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraAddResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraAddResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraAddResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraAddResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraAddResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraAddResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraAddResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnFamily
//  - Expected
//  - Updates
//  - SerialConsistencyLevel
//  - CommitConsistencyLevel
type CassandraCasArgs struct {
	Key                    []byte           `thrift:"key,1,required" json:"key"`
	ColumnFamily           string           `thrift:"column_family,2,required" json:"column_family"`
	Expected               []*Column        `thrift:"expected,3" json:"expected"`
	Updates                []*Column        `thrift:"updates,4" json:"updates"`
	SerialConsistencyLevel ConsistencyLevel `thrift:"serial_consistency_level,5,required" json:"serial_consistency_level"`
	CommitConsistencyLevel ConsistencyLevel `thrift:"commit_consistency_level,6,required" json:"commit_consistency_level"`
}

func NewCassandraCasArgs() *CassandraCasArgs {
	return &CassandraCasArgs{
		SerialConsistencyLevel: 9,

		CommitConsistencyLevel: 2,
	}
}

func (p *CassandraCasArgs) GetKey() []byte {
	return p.Key
}

func (p *CassandraCasArgs) GetColumnFamily() string {
	return p.ColumnFamily
}

func (p *CassandraCasArgs) GetExpected() []*Column {
	return p.Expected
}

func (p *CassandraCasArgs) GetUpdates() []*Column {
	return p.Updates
}

func (p *CassandraCasArgs) GetSerialConsistencyLevel() ConsistencyLevel {
	return p.SerialConsistencyLevel
}

func (p *CassandraCasArgs) GetCommitConsistencyLevel() ConsistencyLevel {
	return p.CommitConsistencyLevel
}
func (p *CassandraCasArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnFamily bool = false
	var issetSerialConsistencyLevel bool = false
	var issetCommitConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnFamily = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
			issetSerialConsistencyLevel = true
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
			issetCommitConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"))
	}
	if !issetSerialConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SerialConsistencyLevel is not set"))
	}
	if !issetCommitConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CommitConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraCasArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraCasArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *CassandraCasArgs) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Expected = tSlice
	for i := 0; i < size; i++ {
		_elem134 := &Column{}
		if err := _elem134.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem134), err)
		}
		p.Expected = append(p.Expected, _elem134)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraCasArgs) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Updates = tSlice
	for i := 0; i < size; i++ {
		_elem135 := &Column{}
		if err := _elem135.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem135), err)
		}
		p.Updates = append(p.Updates, _elem135)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraCasArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.SerialConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraCasArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.CommitConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraCasArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cas_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraCasArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_family: ", p), err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_family (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_family: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("expected", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:expected: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expected)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Expected {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:expected: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("updates", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:updates: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Updates)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Updates {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:updates: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("serial_consistency_level", thrift.I32, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:serial_consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.SerialConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.serial_consistency_level (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:serial_consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("commit_consistency_level", thrift.I32, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:commit_consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.CommitConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.commit_consistency_level (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:commit_consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraCasArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraCasArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
type CassandraCasResult struct {
	Success *CASResult_              `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraCasResult() *CassandraCasResult {
	return &CassandraCasResult{}
}

var CassandraCasResult_Success_DEFAULT *CASResult_

func (p *CassandraCasResult) GetSuccess() *CASResult_ {
	if !p.IsSetSuccess() {
		return CassandraCasResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraCasResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraCasResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraCasResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraCasResult_Ue_DEFAULT *UnavailableException

func (p *CassandraCasResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraCasResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraCasResult_Te_DEFAULT *TimedOutException

func (p *CassandraCasResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraCasResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraCasResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraCasResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraCasResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraCasResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraCasResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraCasResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CASResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraCasResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraCasResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraCasResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraCasResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cas_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraCasResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraCasResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraCasResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraCasResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraCasResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraCasResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
type CassandraRemoveArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required" json:"column_path"`
	Timestamp        int64            `thrift:"timestamp,3,required" json:"timestamp"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4" json:"consistency_level"`
}

func NewCassandraRemoveArgs() *CassandraRemoveArgs {
	return &CassandraRemoveArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraRemoveArgs) GetKey() []byte {
	return p.Key
}

var CassandraRemoveArgs_ColumnPath_DEFAULT *ColumnPath

func (p *CassandraRemoveArgs) GetColumnPath() *ColumnPath {
	if !p.IsSetColumnPath() {
		return CassandraRemoveArgs_ColumnPath_DEFAULT
	}
	return p.ColumnPath
}

func (p *CassandraRemoveArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *CassandraRemoveArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraRemoveArgs) IsSetColumnPath() bool {
	return p.ColumnPath != nil
}

func (p *CassandraRemoveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumnPath bool = false
	var issetTimestamp bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumnPath = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetTimestamp = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumnPath {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnPath is not set"))
	}
	if !issetTimestamp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Timestamp is not set"))
	}
	return nil
}

func (p *CassandraRemoveArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraRemoveArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = &ColumnPath{}
	if err := p.ColumnPath.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnPath), err)
	}
	return nil
}

func (p *CassandraRemoveArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *CassandraRemoveArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraRemoveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraRemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraRemoveArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:column_path: ", p), err)
	}
	if err := p.ColumnPath.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnPath), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:column_path: ", p), err)
	}
	return err
}

func (p *CassandraRemoveArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
	}
	return err
}

func (p *CassandraRemoveArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraRemoveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraRemoveArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraRemoveResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraRemoveResult() *CassandraRemoveResult {
	return &CassandraRemoveResult{}
}

var CassandraRemoveResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraRemoveResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraRemoveResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraRemoveResult_Ue_DEFAULT *UnavailableException

func (p *CassandraRemoveResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraRemoveResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraRemoveResult_Te_DEFAULT *TimedOutException

func (p *CassandraRemoveResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraRemoveResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraRemoveResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraRemoveResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraRemoveResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraRemoveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraRemoveResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraRemoveResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraRemoveResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraRemoveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraRemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraRemoveResult(%+v)", *p)
}

// Attributes:
//  - Key
//  - Path
//  - ConsistencyLevel
type CassandraRemoveCounterArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	Path             *ColumnPath      `thrift:"path,2,required" json:"path"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" json:"consistency_level"`
}

func NewCassandraRemoveCounterArgs() *CassandraRemoveCounterArgs {
	return &CassandraRemoveCounterArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraRemoveCounterArgs) GetKey() []byte {
	return p.Key
}

var CassandraRemoveCounterArgs_Path_DEFAULT *ColumnPath

func (p *CassandraRemoveCounterArgs) GetPath() *ColumnPath {
	if !p.IsSetPath() {
		return CassandraRemoveCounterArgs_Path_DEFAULT
	}
	return p.Path
}

func (p *CassandraRemoveCounterArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraRemoveCounterArgs) IsSetPath() bool {
	return p.Path != nil
}

func (p *CassandraRemoveCounterArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetPath bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetPath = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetPath {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Path is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraRemoveCounterArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CassandraRemoveCounterArgs) readField2(iprot thrift.TProtocol) error {
	p.Path = &ColumnPath{}
	if err := p.Path.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Path), err)
	}
	return nil
}

func (p *CassandraRemoveCounterArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraRemoveCounterArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraRemoveCounterArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CassandraRemoveCounterArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("path", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:path: ", p), err)
	}
	if err := p.Path.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Path), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:path: ", p), err)
	}
	return err
}

func (p *CassandraRemoveCounterArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraRemoveCounterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraRemoveCounterArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraRemoveCounterResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraRemoveCounterResult() *CassandraRemoveCounterResult {
	return &CassandraRemoveCounterResult{}
}

var CassandraRemoveCounterResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraRemoveCounterResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraRemoveCounterResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraRemoveCounterResult_Ue_DEFAULT *UnavailableException

func (p *CassandraRemoveCounterResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraRemoveCounterResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraRemoveCounterResult_Te_DEFAULT *TimedOutException

func (p *CassandraRemoveCounterResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraRemoveCounterResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraRemoveCounterResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraRemoveCounterResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraRemoveCounterResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraRemoveCounterResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraRemoveCounterResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraRemoveCounterResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraRemoveCounterResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraRemoveCounterResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraRemoveCounterResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveCounterResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveCounterResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraRemoveCounterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraRemoveCounterResult(%+v)", *p)
}

// Attributes:
//  - MutationMap
//  - ConsistencyLevel
type CassandraBatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required" json:"consistency_level"`
}

func NewCassandraBatchMutateArgs() *CassandraBatchMutateArgs {
	return &CassandraBatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraBatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
	return p.MutationMap
}

func (p *CassandraBatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraBatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMutationMap bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetMutationMap = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMutationMap {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MutationMap is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraBatchMutateArgs) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]map[string][]*Mutation, size)
	p.MutationMap = tMap
	for i := 0; i < size; i++ {
		var _key136 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key136 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return thrift.PrependError("error reading map begin: ", err)
		}
		tMap := make(map[string][]*Mutation, size)
		_val137 := tMap
		for i := 0; i < size; i++ {
			var _key138 string
			if v, err := iprot.ReadString(); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_key138 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return thrift.PrependError("error reading list begin: ", err)
			}
			tSlice := make([]*Mutation, 0, size)
			_val139 := tSlice
			for i := 0; i < size; i++ {
				_elem140 := &Mutation{}
				if err := _elem140.Read(iprot); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem140), err)
				}
				_val139 = append(_val139, _elem140)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return thrift.PrependError("error reading list end: ", err)
			}
			_val137[_key138] = _val139
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return thrift.PrependError("error reading map end: ", err)
		}
		p.MutationMap[_key136] = _val137
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraBatchMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraBatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:mutation_map: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.MutationMap {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range v {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return thrift.PrependError("error writing list begin: ", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return thrift.PrependError("error writing list end: ", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:mutation_map: ", p), err)
	}
	return err
}

func (p *CassandraBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraBatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraBatchMutateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraBatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraBatchMutateResult() *CassandraBatchMutateResult {
	return &CassandraBatchMutateResult{}
}

var CassandraBatchMutateResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraBatchMutateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraBatchMutateResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraBatchMutateResult_Ue_DEFAULT *UnavailableException

func (p *CassandraBatchMutateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraBatchMutateResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraBatchMutateResult_Te_DEFAULT *TimedOutException

func (p *CassandraBatchMutateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraBatchMutateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraBatchMutateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraBatchMutateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraBatchMutateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraBatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraBatchMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraBatchMutateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraBatchMutateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraBatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraBatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraBatchMutateResult(%+v)", *p)
}

// Attributes:
//  - MutationMap
//  - ConsistencyLevel
type CassandraAtomicBatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required" json:"consistency_level"`
}

func NewCassandraAtomicBatchMutateArgs() *CassandraAtomicBatchMutateArgs {
	return &CassandraAtomicBatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *CassandraAtomicBatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
	return p.MutationMap
}

func (p *CassandraAtomicBatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *CassandraAtomicBatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetMutationMap bool = false
	var issetConsistencyLevel bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetMutationMap = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetConsistencyLevel = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetMutationMap {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field MutationMap is not set"))
	}
	if !issetConsistencyLevel {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ConsistencyLevel is not set"))
	}
	return nil
}

func (p *CassandraAtomicBatchMutateArgs) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]map[string][]*Mutation, size)
	p.MutationMap = tMap
	for i := 0; i < size; i++ {
		var _key141 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key141 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return thrift.PrependError("error reading map begin: ", err)
		}
		tMap := make(map[string][]*Mutation, size)
		_val142 := tMap
		for i := 0; i < size; i++ {
			var _key143 string
			if v, err := iprot.ReadString(); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_key143 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return thrift.PrependError("error reading list begin: ", err)
			}
			tSlice := make([]*Mutation, 0, size)
			_val144 := tSlice
			for i := 0; i < size; i++ {
				_elem145 := &Mutation{}
				if err := _elem145.Read(iprot); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem145), err)
				}
				_val144 = append(_val144, _elem145)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return thrift.PrependError("error reading list end: ", err)
			}
			_val142[_key143] = _val144
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return thrift.PrependError("error reading map end: ", err)
		}
		p.MutationMap[_key141] = _val142
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *CassandraAtomicBatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:mutation_map: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.MutationMap {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range v {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return thrift.PrependError("error writing list begin: ", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return thrift.PrependError("error writing list end: ", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:mutation_map: ", p), err)
	}
	return err
}

func (p *CassandraAtomicBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:consistency_level: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency_level (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:consistency_level: ", p), err)
	}
	return err
}

func (p *CassandraAtomicBatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraAtomicBatchMutateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraAtomicBatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraAtomicBatchMutateResult() *CassandraAtomicBatchMutateResult {
	return &CassandraAtomicBatchMutateResult{}
}

var CassandraAtomicBatchMutateResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraAtomicBatchMutateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraAtomicBatchMutateResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraAtomicBatchMutateResult_Ue_DEFAULT *UnavailableException

func (p *CassandraAtomicBatchMutateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraAtomicBatchMutateResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraAtomicBatchMutateResult_Te_DEFAULT *TimedOutException

func (p *CassandraAtomicBatchMutateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraAtomicBatchMutateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraAtomicBatchMutateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraAtomicBatchMutateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraAtomicBatchMutateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraAtomicBatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraAtomicBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraAtomicBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraAtomicBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraAtomicBatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraAtomicBatchMutateResult(%+v)", *p)
}

// Attributes:
//  - Cfname
type CassandraTruncateArgs struct {
	Cfname string `thrift:"cfname,1,required" json:"cfname"`
}

func NewCassandraTruncateArgs() *CassandraTruncateArgs {
	return &CassandraTruncateArgs{}
}

func (p *CassandraTruncateArgs) GetCfname() string {
	return p.Cfname
}
func (p *CassandraTruncateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCfname bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCfname = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCfname {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Cfname is not set"))
	}
	return nil
}

func (p *CassandraTruncateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Cfname = v
	}
	return nil
}

func (p *CassandraTruncateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraTruncateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfname", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfname: ", p), err)
	}
	if err := oprot.WriteString(string(p.Cfname)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cfname (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfname: ", p), err)
	}
	return err
}

func (p *CassandraTruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraTruncateArgs(%+v)", *p)
}

// Attributes:
//  - Ire
//  - Ue
//  - Te
type CassandraTruncateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"te,3" json:"te,omitempty"`
}

func NewCassandraTruncateResult() *CassandraTruncateResult {
	return &CassandraTruncateResult{}
}

var CassandraTruncateResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraTruncateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraTruncateResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraTruncateResult_Ue_DEFAULT *UnavailableException

func (p *CassandraTruncateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraTruncateResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraTruncateResult_Te_DEFAULT *TimedOutException

func (p *CassandraTruncateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraTruncateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CassandraTruncateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraTruncateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraTruncateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraTruncateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraTruncateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraTruncateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraTruncateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraTruncateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraTruncateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraTruncateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraTruncateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraTruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraTruncateResult(%+v)", *p)
}

type CassandraDescribeSchemaVersionsArgs struct {
}

func NewCassandraDescribeSchemaVersionsArgs() *CassandraDescribeSchemaVersionsArgs {
	return &CassandraDescribeSchemaVersionsArgs{}
}

func (p *CassandraDescribeSchemaVersionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSchemaVersionsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSchemaVersionsResult struct {
	Success map[string][]string      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeSchemaVersionsResult() *CassandraDescribeSchemaVersionsResult {
	return &CassandraDescribeSchemaVersionsResult{}
}

var CassandraDescribeSchemaVersionsResult_Success_DEFAULT map[string][]string

func (p *CassandraDescribeSchemaVersionsResult) GetSuccess() map[string][]string {
	return p.Success
}

var CassandraDescribeSchemaVersionsResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeSchemaVersionsResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeSchemaVersionsResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeSchemaVersionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeSchemaVersionsResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeSchemaVersionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string][]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key146 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key146 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make([]string, 0, size)
		_val147 := tSlice
		for i := 0; i < size; i++ {
			var _elem148 string
			if v, err := iprot.ReadString(); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_elem148 = v
			}
			_val147 = append(_val147, _elem148)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.Success[_key146] = _val147
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSchemaVersionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return thrift.PrependError("error writing list begin: ", err)
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return thrift.PrependError("error writing list end: ", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSchemaVersionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSchemaVersionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSchemaVersionsResult(%+v)", *p)
}

type CassandraDescribeKeyspacesArgs struct {
}

func NewCassandraDescribeKeyspacesArgs() *CassandraDescribeKeyspacesArgs {
	return &CassandraDescribeKeyspacesArgs{}
}

func (p *CassandraDescribeKeyspacesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeKeyspacesArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeKeyspacesResult struct {
	Success []*KsDef                 `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeKeyspacesResult() *CassandraDescribeKeyspacesResult {
	return &CassandraDescribeKeyspacesResult{}
}

var CassandraDescribeKeyspacesResult_Success_DEFAULT []*KsDef

func (p *CassandraDescribeKeyspacesResult) GetSuccess() []*KsDef {
	return p.Success
}

var CassandraDescribeKeyspacesResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeKeyspacesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeKeyspacesResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeKeyspacesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeKeyspacesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeKeyspacesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KsDef, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem149 := &KsDef{
			DurableWrites: true,
		}
		if err := _elem149.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem149), err)
		}
		p.Success = append(p.Success, _elem149)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeKeyspacesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeKeyspacesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeKeyspacesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeKeyspacesResult(%+v)", *p)
}

type CassandraDescribeClusterNameArgs struct {
}

func NewCassandraDescribeClusterNameArgs() *CassandraDescribeClusterNameArgs {
	return &CassandraDescribeClusterNameArgs{}
}

func (p *CassandraDescribeClusterNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeClusterNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeClusterNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeClusterNameArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeClusterNameResult struct {
	Success *string `thrift:"success,0" json:"success,omitempty"`
}

func NewCassandraDescribeClusterNameResult() *CassandraDescribeClusterNameResult {
	return &CassandraDescribeClusterNameResult{}
}

var CassandraDescribeClusterNameResult_Success_DEFAULT string

func (p *CassandraDescribeClusterNameResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraDescribeClusterNameResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *CassandraDescribeClusterNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeClusterNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeClusterNameResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraDescribeClusterNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeClusterNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeClusterNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeClusterNameResult(%+v)", *p)
}

type CassandraDescribeVersionArgs struct {
}

func NewCassandraDescribeVersionArgs() *CassandraDescribeVersionArgs {
	return &CassandraDescribeVersionArgs{}
}

func (p *CassandraDescribeVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeVersionResult struct {
	Success *string `thrift:"success,0" json:"success,omitempty"`
}

func NewCassandraDescribeVersionResult() *CassandraDescribeVersionResult {
	return &CassandraDescribeVersionResult{}
}

var CassandraDescribeVersionResult_Success_DEFAULT string

func (p *CassandraDescribeVersionResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraDescribeVersionResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *CassandraDescribeVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraDescribeVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeVersionResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewCassandraDescribeRingArgs() *CassandraDescribeRingArgs {
	return &CassandraDescribeRingArgs{}
}

func (p *CassandraDescribeRingArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *CassandraDescribeRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	return nil
}

func (p *CassandraDescribeRingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CassandraDescribeRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CassandraDescribeRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeRingArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeRingResult struct {
	Success []*TokenRange            `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeRingResult() *CassandraDescribeRingResult {
	return &CassandraDescribeRingResult{}
}

var CassandraDescribeRingResult_Success_DEFAULT []*TokenRange

func (p *CassandraDescribeRingResult) GetSuccess() []*TokenRange {
	return p.Success
}

var CassandraDescribeRingResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeRingResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeRingResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeRingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeRingResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeRingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TokenRange, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem150 := &TokenRange{}
		if err := _elem150.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem150), err)
		}
		p.Success = append(p.Success, _elem150)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraDescribeRingResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeRingResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeLocalRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewCassandraDescribeLocalRingArgs() *CassandraDescribeLocalRingArgs {
	return &CassandraDescribeLocalRingArgs{}
}

func (p *CassandraDescribeLocalRingArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *CassandraDescribeLocalRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	return nil
}

func (p *CassandraDescribeLocalRingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CassandraDescribeLocalRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_local_ring_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeLocalRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CassandraDescribeLocalRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeLocalRingArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeLocalRingResult struct {
	Success []*TokenRange            `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeLocalRingResult() *CassandraDescribeLocalRingResult {
	return &CassandraDescribeLocalRingResult{}
}

var CassandraDescribeLocalRingResult_Success_DEFAULT []*TokenRange

func (p *CassandraDescribeLocalRingResult) GetSuccess() []*TokenRange {
	return p.Success
}

var CassandraDescribeLocalRingResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeLocalRingResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeLocalRingResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeLocalRingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeLocalRingResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeLocalRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeLocalRingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TokenRange, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem151 := &TokenRange{}
		if err := _elem151.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem151), err)
		}
		p.Success = append(p.Success, _elem151)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraDescribeLocalRingResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeLocalRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_local_ring_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeLocalRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeLocalRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeLocalRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeLocalRingResult(%+v)", *p)
}

type CassandraDescribeTokenMapArgs struct {
}

func NewCassandraDescribeTokenMapArgs() *CassandraDescribeTokenMapArgs {
	return &CassandraDescribeTokenMapArgs{}
}

func (p *CassandraDescribeTokenMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeTokenMapArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeTokenMapResult struct {
	Success map[string]string        `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeTokenMapResult() *CassandraDescribeTokenMapResult {
	return &CassandraDescribeTokenMapResult{}
}

var CassandraDescribeTokenMapResult_Success_DEFAULT map[string]string

func (p *CassandraDescribeTokenMapResult) GetSuccess() map[string]string {
	return p.Success
}

var CassandraDescribeTokenMapResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeTokenMapResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeTokenMapResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeTokenMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeTokenMapResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeTokenMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key152 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key152 = v
		}
		var _val153 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val153 = v
		}
		p.Success[_key152] = _val153
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeTokenMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeTokenMapResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeTokenMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeTokenMapResult(%+v)", *p)
}

type CassandraDescribePartitionerArgs struct {
}

func NewCassandraDescribePartitionerArgs() *CassandraDescribePartitionerArgs {
	return &CassandraDescribePartitionerArgs{}
}

func (p *CassandraDescribePartitionerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribePartitionerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribePartitionerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribePartitionerArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribePartitionerResult struct {
	Success *string `thrift:"success,0" json:"success,omitempty"`
}

func NewCassandraDescribePartitionerResult() *CassandraDescribePartitionerResult {
	return &CassandraDescribePartitionerResult{}
}

var CassandraDescribePartitionerResult_Success_DEFAULT string

func (p *CassandraDescribePartitionerResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraDescribePartitionerResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *CassandraDescribePartitionerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribePartitionerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribePartitionerResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraDescribePartitionerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribePartitionerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribePartitionerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribePartitionerResult(%+v)", *p)
}

type CassandraDescribeSnitchArgs struct {
}

func NewCassandraDescribeSnitchArgs() *CassandraDescribeSnitchArgs {
	return &CassandraDescribeSnitchArgs{}
}

func (p *CassandraDescribeSnitchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSnitchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSnitchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSnitchArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraDescribeSnitchResult struct {
	Success *string `thrift:"success,0" json:"success,omitempty"`
}

func NewCassandraDescribeSnitchResult() *CassandraDescribeSnitchResult {
	return &CassandraDescribeSnitchResult{}
}

var CassandraDescribeSnitchResult_Success_DEFAULT string

func (p *CassandraDescribeSnitchResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraDescribeSnitchResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *CassandraDescribeSnitchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeSnitchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSnitchResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraDescribeSnitchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSnitchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSnitchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSnitchResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraDescribeKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewCassandraDescribeKeyspaceArgs() *CassandraDescribeKeyspaceArgs {
	return &CassandraDescribeKeyspaceArgs{}
}

func (p *CassandraDescribeKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *CassandraDescribeKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	return nil
}

func (p *CassandraDescribeKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CassandraDescribeKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CassandraDescribeKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Nfe
//  - Ire
type CassandraDescribeKeyspaceResult struct {
	Success *KsDef                   `thrift:"success,0" json:"success,omitempty"`
	Nfe     *NotFoundException       `thrift:"nfe,1" json:"nfe,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,2" json:"ire,omitempty"`
}

func NewCassandraDescribeKeyspaceResult() *CassandraDescribeKeyspaceResult {
	return &CassandraDescribeKeyspaceResult{}
}

var CassandraDescribeKeyspaceResult_Success_DEFAULT *KsDef

func (p *CassandraDescribeKeyspaceResult) GetSuccess() *KsDef {
	if !p.IsSetSuccess() {
		return CassandraDescribeKeyspaceResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraDescribeKeyspaceResult_Nfe_DEFAULT *NotFoundException

func (p *CassandraDescribeKeyspaceResult) GetNfe() *NotFoundException {
	if !p.IsSetNfe() {
		return CassandraDescribeKeyspaceResult_Nfe_DEFAULT
	}
	return p.Nfe
}

var CassandraDescribeKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeKeyspaceResult) IsSetNfe() bool {
	return p.Nfe != nil
}

func (p *CassandraDescribeKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &KsDef{
		DurableWrites: true,
	}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Nfe = &NotFoundException{}
	if err := p.Nfe.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Nfe), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetNfe() {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nfe: ", p), err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Nfe), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nfe: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
type CassandraDescribeSplitsArgs struct {
	CfName       string `thrift:"cfName,1,required" json:"cfName"`
	StartToken   string `thrift:"start_token,2,required" json:"start_token"`
	EndToken     string `thrift:"end_token,3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required" json:"keys_per_split"`
}

func NewCassandraDescribeSplitsArgs() *CassandraDescribeSplitsArgs {
	return &CassandraDescribeSplitsArgs{}
}

func (p *CassandraDescribeSplitsArgs) GetCfName() string {
	return p.CfName
}

func (p *CassandraDescribeSplitsArgs) GetStartToken() string {
	return p.StartToken
}

func (p *CassandraDescribeSplitsArgs) GetEndToken() string {
	return p.EndToken
}

func (p *CassandraDescribeSplitsArgs) GetKeysPerSplit() int32 {
	return p.KeysPerSplit
}
func (p *CassandraDescribeSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCfName bool = false
	var issetStartToken bool = false
	var issetEndToken bool = false
	var issetKeysPerSplit bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCfName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetStartToken = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetEndToken = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetKeysPerSplit = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCfName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfName is not set"))
	}
	if !issetStartToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"))
	}
	if !issetEndToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"))
	}
	if !issetKeysPerSplit {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KeysPerSplit is not set"))
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.CfName = v
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfName: ", p), err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cfName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfName: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_token (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_token: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:end_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.end_token (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:end_token: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:keys_per_split: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keys_per_split (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:keys_per_split: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSplitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSplitsResult struct {
	Success []string                 `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeSplitsResult() *CassandraDescribeSplitsResult {
	return &CassandraDescribeSplitsResult{}
}

var CassandraDescribeSplitsResult_Success_DEFAULT []string

func (p *CassandraDescribeSplitsResult) GetSuccess() []string {
	return p.Success
}

var CassandraDescribeSplitsResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeSplitsResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeSplitsResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeSplitsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeSplitsResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSplitsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem154 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem154 = v
		}
		p.Success = append(p.Success, _elem154)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSplitsResult(%+v)", *p)
}

type CassandraTraceNextQueryArgs struct {
}

func NewCassandraTraceNextQueryArgs() *CassandraTraceNextQueryArgs {
	return &CassandraTraceNextQueryArgs{}
}

func (p *CassandraTraceNextQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraTraceNextQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraTraceNextQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraTraceNextQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
type CassandraTraceNextQueryResult struct {
	Success []byte `thrift:"success,0" json:"success,omitempty"`
}

func NewCassandraTraceNextQueryResult() *CassandraTraceNextQueryResult {
	return &CassandraTraceNextQueryResult{}
}

var CassandraTraceNextQueryResult_Success_DEFAULT []byte

func (p *CassandraTraceNextQueryResult) GetSuccess() []byte {
	return p.Success
}
func (p *CassandraTraceNextQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraTraceNextQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraTraceNextQueryResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *CassandraTraceNextQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraTraceNextQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraTraceNextQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraTraceNextQueryResult(%+v)", *p)
}

// Attributes:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
type CassandraDescribeSplitsExArgs struct {
	CfName       string `thrift:"cfName,1,required" json:"cfName"`
	StartToken   string `thrift:"start_token,2,required" json:"start_token"`
	EndToken     string `thrift:"end_token,3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required" json:"keys_per_split"`
}

func NewCassandraDescribeSplitsExArgs() *CassandraDescribeSplitsExArgs {
	return &CassandraDescribeSplitsExArgs{}
}

func (p *CassandraDescribeSplitsExArgs) GetCfName() string {
	return p.CfName
}

func (p *CassandraDescribeSplitsExArgs) GetStartToken() string {
	return p.StartToken
}

func (p *CassandraDescribeSplitsExArgs) GetEndToken() string {
	return p.EndToken
}

func (p *CassandraDescribeSplitsExArgs) GetKeysPerSplit() int32 {
	return p.KeysPerSplit
}
func (p *CassandraDescribeSplitsExArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCfName bool = false
	var issetStartToken bool = false
	var issetEndToken bool = false
	var issetKeysPerSplit bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCfName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetStartToken = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetEndToken = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetKeysPerSplit = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCfName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfName is not set"))
	}
	if !issetStartToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"))
	}
	if !issetEndToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"))
	}
	if !issetKeysPerSplit {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KeysPerSplit is not set"))
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.CfName = v
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsExArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cfName: ", p), err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cfName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cfName: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsExArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_token (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_token: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsExArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:end_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.end_token (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:end_token: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsExArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:keys_per_split: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keys_per_split (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:keys_per_split: ", p), err)
	}
	return err
}

func (p *CassandraDescribeSplitsExArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSplitsExArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraDescribeSplitsExResult struct {
	Success []*CfSplit               `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraDescribeSplitsExResult() *CassandraDescribeSplitsExResult {
	return &CassandraDescribeSplitsExResult{}
}

var CassandraDescribeSplitsExResult_Success_DEFAULT []*CfSplit

func (p *CassandraDescribeSplitsExResult) GetSuccess() []*CfSplit {
	return p.Success
}

var CassandraDescribeSplitsExResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraDescribeSplitsExResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraDescribeSplitsExResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraDescribeSplitsExResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraDescribeSplitsExResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraDescribeSplitsExResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraDescribeSplitsExResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CfSplit, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem155 := &CfSplit{}
		if err := _elem155.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem155), err)
		}
		p.Success = append(p.Success, _elem155)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsExResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraDescribeSplitsExResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraDescribeSplitsExResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSplitsExResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraDescribeSplitsExResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraDescribeSplitsExResult(%+v)", *p)
}

// Attributes:
//  - CfDef
type CassandraSystemAddColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required" json:"cf_def"`
}

func NewCassandraSystemAddColumnFamilyArgs() *CassandraSystemAddColumnFamilyArgs {
	return &CassandraSystemAddColumnFamilyArgs{}
}

var CassandraSystemAddColumnFamilyArgs_CfDef_DEFAULT *CfDef

func (p *CassandraSystemAddColumnFamilyArgs) GetCfDef() *CfDef {
	if !p.IsSetCfDef() {
		return CassandraSystemAddColumnFamilyArgs_CfDef_DEFAULT
	}
	return p.CfDef
}
func (p *CassandraSystemAddColumnFamilyArgs) IsSetCfDef() bool {
	return p.CfDef != nil
}

func (p *CassandraSystemAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCfDef bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCfDef = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCfDef {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDef is not set"))
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		SpeculativeRetry: "NONE",
	}
	if err := p.CfDef.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CfDef), err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cf_def: ", p), err)
	}
	if err := p.CfDef.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CfDef), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cf_def: ", p), err)
	}
	return err
}

func (p *CassandraSystemAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemAddColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemAddColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemAddColumnFamilyResult() *CassandraSystemAddColumnFamilyResult {
	return &CassandraSystemAddColumnFamilyResult{}
}

var CassandraSystemAddColumnFamilyResult_Success_DEFAULT string

func (p *CassandraSystemAddColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemAddColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemAddColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemAddColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemAddColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemAddColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemAddColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemAddColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemAddColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemAddColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemAddColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemAddColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemAddColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - ColumnFamily
type CassandraSystemDropColumnFamilyArgs struct {
	ColumnFamily string `thrift:"column_family,1,required" json:"column_family"`
}

func NewCassandraSystemDropColumnFamilyArgs() *CassandraSystemDropColumnFamilyArgs {
	return &CassandraSystemDropColumnFamilyArgs{}
}

func (p *CassandraSystemDropColumnFamilyArgs) GetColumnFamily() string {
	return p.ColumnFamily
}
func (p *CassandraSystemDropColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnFamily bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetColumnFamily = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"))
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_family: ", p), err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_family (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_family: ", p), err)
	}
	return err
}

func (p *CassandraSystemDropColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemDropColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemDropColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemDropColumnFamilyResult() *CassandraSystemDropColumnFamilyResult {
	return &CassandraSystemDropColumnFamilyResult{}
}

var CassandraSystemDropColumnFamilyResult_Success_DEFAULT string

func (p *CassandraSystemDropColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemDropColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemDropColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemDropColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemDropColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemDropColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemDropColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemDropColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemDropColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemDropColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemDropColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemDropColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemDropColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemDropColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - KsDef
type CassandraSystemAddKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required" json:"ks_def"`
}

func NewCassandraSystemAddKeyspaceArgs() *CassandraSystemAddKeyspaceArgs {
	return &CassandraSystemAddKeyspaceArgs{}
}

var CassandraSystemAddKeyspaceArgs_KsDef_DEFAULT *KsDef

func (p *CassandraSystemAddKeyspaceArgs) GetKsDef() *KsDef {
	if !p.IsSetKsDef() {
		return CassandraSystemAddKeyspaceArgs_KsDef_DEFAULT
	}
	return p.KsDef
}
func (p *CassandraSystemAddKeyspaceArgs) IsSetKsDef() bool {
	return p.KsDef != nil
}

func (p *CassandraSystemAddKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKsDef bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKsDef = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKsDef {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KsDef is not set"))
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = &KsDef{
		DurableWrites: true,
	}
	if err := p.KsDef.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.KsDef), err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ks_def: ", p), err)
	}
	if err := p.KsDef.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.KsDef), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ks_def: ", p), err)
	}
	return err
}

func (p *CassandraSystemAddKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemAddKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemAddKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemAddKeyspaceResult() *CassandraSystemAddKeyspaceResult {
	return &CassandraSystemAddKeyspaceResult{}
}

var CassandraSystemAddKeyspaceResult_Success_DEFAULT string

func (p *CassandraSystemAddKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemAddKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemAddKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemAddKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemAddKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemAddKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemAddKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemAddKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemAddKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemAddKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemAddKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemAddKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemAddKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemAddKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemAddKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - Keyspace
type CassandraSystemDropKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewCassandraSystemDropKeyspaceArgs() *CassandraSystemDropKeyspaceArgs {
	return &CassandraSystemDropKeyspaceArgs{}
}

func (p *CassandraSystemDropKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *CassandraSystemDropKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CassandraSystemDropKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemDropKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemDropKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemDropKeyspaceResult() *CassandraSystemDropKeyspaceResult {
	return &CassandraSystemDropKeyspaceResult{}
}

var CassandraSystemDropKeyspaceResult_Success_DEFAULT string

func (p *CassandraSystemDropKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemDropKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemDropKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemDropKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemDropKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemDropKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemDropKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemDropKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemDropKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemDropKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemDropKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemDropKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemDropKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemDropKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemDropKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - KsDef
type CassandraSystemUpdateKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required" json:"ks_def"`
}

func NewCassandraSystemUpdateKeyspaceArgs() *CassandraSystemUpdateKeyspaceArgs {
	return &CassandraSystemUpdateKeyspaceArgs{}
}

var CassandraSystemUpdateKeyspaceArgs_KsDef_DEFAULT *KsDef

func (p *CassandraSystemUpdateKeyspaceArgs) GetKsDef() *KsDef {
	if !p.IsSetKsDef() {
		return CassandraSystemUpdateKeyspaceArgs_KsDef_DEFAULT
	}
	return p.KsDef
}
func (p *CassandraSystemUpdateKeyspaceArgs) IsSetKsDef() bool {
	return p.KsDef != nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKsDef bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKsDef = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKsDef {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field KsDef is not set"))
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = &KsDef{
		DurableWrites: true,
	}
	if err := p.KsDef.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.KsDef), err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ks_def: ", p), err)
	}
	if err := p.KsDef.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.KsDef), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ks_def: ", p), err)
	}
	return err
}

func (p *CassandraSystemUpdateKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemUpdateKeyspaceArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemUpdateKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemUpdateKeyspaceResult() *CassandraSystemUpdateKeyspaceResult {
	return &CassandraSystemUpdateKeyspaceResult{}
}

var CassandraSystemUpdateKeyspaceResult_Success_DEFAULT string

func (p *CassandraSystemUpdateKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemUpdateKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemUpdateKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemUpdateKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemUpdateKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemUpdateKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemUpdateKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemUpdateKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemUpdateKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemUpdateKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemUpdateKeyspaceResult(%+v)", *p)
}

// Attributes:
//  - CfDef
type CassandraSystemUpdateColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required" json:"cf_def"`
}

func NewCassandraSystemUpdateColumnFamilyArgs() *CassandraSystemUpdateColumnFamilyArgs {
	return &CassandraSystemUpdateColumnFamilyArgs{}
}

var CassandraSystemUpdateColumnFamilyArgs_CfDef_DEFAULT *CfDef

func (p *CassandraSystemUpdateColumnFamilyArgs) GetCfDef() *CfDef {
	if !p.IsSetCfDef() {
		return CassandraSystemUpdateColumnFamilyArgs_CfDef_DEFAULT
	}
	return p.CfDef
}
func (p *CassandraSystemUpdateColumnFamilyArgs) IsSetCfDef() bool {
	return p.CfDef != nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCfDef bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCfDef = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCfDef {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDef is not set"))
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		SpeculativeRetry: "NONE",
	}
	if err := p.CfDef.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CfDef), err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cf_def: ", p), err)
	}
	if err := p.CfDef.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CfDef), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cf_def: ", p), err)
	}
	return err
}

func (p *CassandraSystemUpdateColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemUpdateColumnFamilyArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Sde
type CassandraSystemUpdateColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde,omitempty"`
}

func NewCassandraSystemUpdateColumnFamilyResult() *CassandraSystemUpdateColumnFamilyResult {
	return &CassandraSystemUpdateColumnFamilyResult{}
}

var CassandraSystemUpdateColumnFamilyResult_Success_DEFAULT string

func (p *CassandraSystemUpdateColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return CassandraSystemUpdateColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var CassandraSystemUpdateColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSystemUpdateColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSystemUpdateColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraSystemUpdateColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraSystemUpdateColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraSystemUpdateColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraSystemUpdateColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraSystemUpdateColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSystemUpdateColumnFamilyResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraExecuteCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewCassandraExecuteCqlQueryArgs() *CassandraExecuteCqlQueryArgs {
	return &CassandraExecuteCqlQueryArgs{}
}

func (p *CassandraExecuteCqlQueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *CassandraExecuteCqlQueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *CassandraExecuteCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false
	var issetCompression bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetQuery = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCompression = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"))
	}
	if !issetCompression {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"))
	}
	return nil
}

func (p *CassandraExecuteCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *CassandraExecuteCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *CassandraExecuteCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *CassandraExecuteCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err)
	}
	return err
}

func (p *CassandraExecuteCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecuteCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecuteCqlQueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException           `thrift:"te,3" json:"te,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde,omitempty"`
}

func NewCassandraExecuteCqlQueryResult() *CassandraExecuteCqlQueryResult {
	return &CassandraExecuteCqlQueryResult{}
}

var CassandraExecuteCqlQueryResult_Success_DEFAULT *CqlResult_

func (p *CassandraExecuteCqlQueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return CassandraExecuteCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraExecuteCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraExecuteCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraExecuteCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraExecuteCqlQueryResult_Ue_DEFAULT *UnavailableException

func (p *CassandraExecuteCqlQueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraExecuteCqlQueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraExecuteCqlQueryResult_Te_DEFAULT *TimedOutException

func (p *CassandraExecuteCqlQueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraExecuteCqlQueryResult_Te_DEFAULT
	}
	return p.Te
}

var CassandraExecuteCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraExecuteCqlQueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraExecuteCqlQueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraExecuteCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraExecuteCqlQueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraExecuteCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecuteCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecuteCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
//  - Consistency
type CassandraExecuteCql3QueryArgs struct {
	Query       []byte           `thrift:"query,1,required" json:"query"`
	Compression Compression      `thrift:"compression,2,required" json:"compression"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required" json:"consistency"`
}

func NewCassandraExecuteCql3QueryArgs() *CassandraExecuteCql3QueryArgs {
	return &CassandraExecuteCql3QueryArgs{}
}

func (p *CassandraExecuteCql3QueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *CassandraExecuteCql3QueryArgs) GetCompression() Compression {
	return p.Compression
}

func (p *CassandraExecuteCql3QueryArgs) GetConsistency() ConsistencyLevel {
	return p.Consistency
}
func (p *CassandraExecuteCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false
	var issetCompression bool = false
	var issetConsistency bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetQuery = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCompression = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetConsistency = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"))
	}
	if !issetCompression {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"))
	}
	if !issetConsistency {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Consistency is not set"))
	}
	return nil
}

func (p *CassandraExecuteCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *CassandraExecuteCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *CassandraExecuteCql3QueryArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.Consistency = temp
	}
	return nil
}

func (p *CassandraExecuteCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *CassandraExecuteCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err)
	}
	return err
}

func (p *CassandraExecuteCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency: ", p), err)
	}
	return err
}

func (p *CassandraExecuteCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecuteCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecuteCql3QueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException           `thrift:"te,3" json:"te,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde,omitempty"`
}

func NewCassandraExecuteCql3QueryResult() *CassandraExecuteCql3QueryResult {
	return &CassandraExecuteCql3QueryResult{}
}

var CassandraExecuteCql3QueryResult_Success_DEFAULT *CqlResult_

func (p *CassandraExecuteCql3QueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return CassandraExecuteCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraExecuteCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraExecuteCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraExecuteCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraExecuteCql3QueryResult_Ue_DEFAULT *UnavailableException

func (p *CassandraExecuteCql3QueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraExecuteCql3QueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraExecuteCql3QueryResult_Te_DEFAULT *TimedOutException

func (p *CassandraExecuteCql3QueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraExecuteCql3QueryResult_Te_DEFAULT
	}
	return p.Te
}

var CassandraExecuteCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraExecuteCql3QueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraExecuteCql3QueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraExecuteCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraExecuteCql3QueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraExecuteCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecuteCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecuteCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecuteCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraPrepareCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewCassandraPrepareCqlQueryArgs() *CassandraPrepareCqlQueryArgs {
	return &CassandraPrepareCqlQueryArgs{}
}

func (p *CassandraPrepareCqlQueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *CassandraPrepareCqlQueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *CassandraPrepareCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false
	var issetCompression bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetQuery = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCompression = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"))
	}
	if !issetCompression {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"))
	}
	return nil
}

func (p *CassandraPrepareCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *CassandraPrepareCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *CassandraPrepareCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraPrepareCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *CassandraPrepareCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err)
	}
	return err
}

func (p *CassandraPrepareCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraPrepareCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraPrepareCqlQueryResult struct {
	Success *CqlPreparedResult_      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraPrepareCqlQueryResult() *CassandraPrepareCqlQueryResult {
	return &CassandraPrepareCqlQueryResult{}
}

var CassandraPrepareCqlQueryResult_Success_DEFAULT *CqlPreparedResult_

func (p *CassandraPrepareCqlQueryResult) GetSuccess() *CqlPreparedResult_ {
	if !p.IsSetSuccess() {
		return CassandraPrepareCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraPrepareCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraPrepareCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraPrepareCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraPrepareCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraPrepareCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraPrepareCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraPrepareCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlPreparedResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraPrepareCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraPrepareCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraPrepareCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraPrepareCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraPrepareCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraPrepareCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - Query
//  - Compression
type CassandraPrepareCql3QueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewCassandraPrepareCql3QueryArgs() *CassandraPrepareCql3QueryArgs {
	return &CassandraPrepareCql3QueryArgs{}
}

func (p *CassandraPrepareCql3QueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *CassandraPrepareCql3QueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *CassandraPrepareCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false
	var issetCompression bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetQuery = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCompression = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"))
	}
	if !issetCompression {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Compression is not set"))
	}
	return nil
}

func (p *CassandraPrepareCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *CassandraPrepareCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *CassandraPrepareCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraPrepareCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *CassandraPrepareCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:compression: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.compression (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:compression: ", p), err)
	}
	return err
}

func (p *CassandraPrepareCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraPrepareCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
type CassandraPrepareCql3QueryResult struct {
	Success *CqlPreparedResult_      `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraPrepareCql3QueryResult() *CassandraPrepareCql3QueryResult {
	return &CassandraPrepareCql3QueryResult{}
}

var CassandraPrepareCql3QueryResult_Success_DEFAULT *CqlPreparedResult_

func (p *CassandraPrepareCql3QueryResult) GetSuccess() *CqlPreparedResult_ {
	if !p.IsSetSuccess() {
		return CassandraPrepareCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraPrepareCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraPrepareCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraPrepareCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraPrepareCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraPrepareCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraPrepareCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraPrepareCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlPreparedResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraPrepareCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraPrepareCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraPrepareCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraPrepareCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraPrepareCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraPrepareCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Values
type CassandraExecutePreparedCqlQueryArgs struct {
	ItemId int32    `thrift:"itemId,1,required" json:"itemId"`
	Values [][]byte `thrift:"values,2,required" json:"values"`
}

func NewCassandraExecutePreparedCqlQueryArgs() *CassandraExecutePreparedCqlQueryArgs {
	return &CassandraExecutePreparedCqlQueryArgs{}
}

func (p *CassandraExecutePreparedCqlQueryArgs) GetItemId() int32 {
	return p.ItemId
}

func (p *CassandraExecutePreparedCqlQueryArgs) GetValues() [][]byte {
	return p.Values
}
func (p *CassandraExecutePreparedCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItemId bool = false
	var issetValues bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetItemId = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetValues = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItemId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"))
	}
	if !issetValues {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Values is not set"))
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem156 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem156 = v
		}
		p.Values = append(p.Values, _elem156)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err)
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Values {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err)
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecutePreparedCqlQueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecutePreparedCqlQueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException           `thrift:"te,3" json:"te,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde,omitempty"`
}

func NewCassandraExecutePreparedCqlQueryResult() *CassandraExecutePreparedCqlQueryResult {
	return &CassandraExecutePreparedCqlQueryResult{}
}

var CassandraExecutePreparedCqlQueryResult_Success_DEFAULT *CqlResult_

func (p *CassandraExecutePreparedCqlQueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return CassandraExecutePreparedCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraExecutePreparedCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraExecutePreparedCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraExecutePreparedCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraExecutePreparedCqlQueryResult_Ue_DEFAULT *UnavailableException

func (p *CassandraExecutePreparedCqlQueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraExecutePreparedCqlQueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraExecutePreparedCqlQueryResult_Te_DEFAULT *TimedOutException

func (p *CassandraExecutePreparedCqlQueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraExecutePreparedCqlQueryResult_Te_DEFAULT
	}
	return p.Te
}

var CassandraExecutePreparedCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraExecutePreparedCqlQueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraExecutePreparedCqlQueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraExecutePreparedCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraExecutePreparedCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecutePreparedCqlQueryResult(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Values
//  - Consistency
type CassandraExecutePreparedCql3QueryArgs struct {
	ItemId      int32            `thrift:"itemId,1,required" json:"itemId"`
	Values      [][]byte         `thrift:"values,2,required" json:"values"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required" json:"consistency"`
}

func NewCassandraExecutePreparedCql3QueryArgs() *CassandraExecutePreparedCql3QueryArgs {
	return &CassandraExecutePreparedCql3QueryArgs{}
}

func (p *CassandraExecutePreparedCql3QueryArgs) GetItemId() int32 {
	return p.ItemId
}

func (p *CassandraExecutePreparedCql3QueryArgs) GetValues() [][]byte {
	return p.Values
}

func (p *CassandraExecutePreparedCql3QueryArgs) GetConsistency() ConsistencyLevel {
	return p.Consistency
}
func (p *CassandraExecutePreparedCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItemId bool = false
	var issetValues bool = false
	var issetConsistency bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetItemId = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetValues = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetConsistency = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItemId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"))
	}
	if !issetValues {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Values is not set"))
	}
	if !issetConsistency {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Consistency is not set"))
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem157 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem157 = v
		}
		p.Values = append(p.Values, _elem157)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := ConsistencyLevel(v)
		p.Consistency = temp
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err)
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Values {
		if err := oprot.WriteBinary(v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err)
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consistency: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consistency (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consistency: ", p), err)
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecutePreparedCql3QueryArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Ire
//  - Ue
//  - Te
//  - Sde
type CassandraExecutePreparedCql3QueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success,omitempty"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire,omitempty"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue,omitempty"`
	Te      *TimedOutException           `thrift:"te,3" json:"te,omitempty"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde,omitempty"`
}

func NewCassandraExecutePreparedCql3QueryResult() *CassandraExecutePreparedCql3QueryResult {
	return &CassandraExecutePreparedCql3QueryResult{}
}

var CassandraExecutePreparedCql3QueryResult_Success_DEFAULT *CqlResult_

func (p *CassandraExecutePreparedCql3QueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return CassandraExecutePreparedCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var CassandraExecutePreparedCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraExecutePreparedCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraExecutePreparedCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var CassandraExecutePreparedCql3QueryResult_Ue_DEFAULT *UnavailableException

func (p *CassandraExecutePreparedCql3QueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CassandraExecutePreparedCql3QueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var CassandraExecutePreparedCql3QueryResult_Te_DEFAULT *TimedOutException

func (p *CassandraExecutePreparedCql3QueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CassandraExecutePreparedCql3QueryResult_Te_DEFAULT
	}
	return p.Te
}

var CassandraExecutePreparedCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *CassandraExecutePreparedCql3QueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return CassandraExecutePreparedCql3QueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *CassandraExecutePreparedCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *CassandraExecutePreparedCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ue), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Te), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Sde), err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ue: ", p), err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ue), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ue: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:te: ", p), err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Te), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:te: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:sde: ", p), err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Sde), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:sde: ", p), err)
		}
	}
	return err
}

func (p *CassandraExecutePreparedCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraExecutePreparedCql3QueryResult(%+v)", *p)
}

// Attributes:
//  - Version
type CassandraSetCqlVersionArgs struct {
	Version string `thrift:"version,1,required" json:"version"`
}

func NewCassandraSetCqlVersionArgs() *CassandraSetCqlVersionArgs {
	return &CassandraSetCqlVersionArgs{}
}

func (p *CassandraSetCqlVersionArgs) GetVersion() string {
	return p.Version
}
func (p *CassandraSetCqlVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetVersion bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetVersion = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetVersion {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Version is not set"))
	}
	return nil
}

func (p *CassandraSetCqlVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Version = v
	}
	return nil
}

func (p *CassandraSetCqlVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSetCqlVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("version", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:version: ", p), err)
	}
	if err := oprot.WriteString(string(p.Version)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.version (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:version: ", p), err)
	}
	return err
}

func (p *CassandraSetCqlVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSetCqlVersionArgs(%+v)", *p)
}

// Attributes:
//  - Ire
type CassandraSetCqlVersionResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire,omitempty"`
}

func NewCassandraSetCqlVersionResult() *CassandraSetCqlVersionResult {
	return &CassandraSetCqlVersionResult{}
}

var CassandraSetCqlVersionResult_Ire_DEFAULT *InvalidRequestException

func (p *CassandraSetCqlVersionResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CassandraSetCqlVersionResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *CassandraSetCqlVersionResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CassandraSetCqlVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CassandraSetCqlVersionResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Ire), err)
	}
	return nil
}

func (p *CassandraSetCqlVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CassandraSetCqlVersionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ire: ", p), err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Ire), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ire: ", p), err)
		}
	}
	return err
}

func (p *CassandraSetCqlVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CassandraSetCqlVersionResult(%+v)", *p)
}
