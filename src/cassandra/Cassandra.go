// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"bytes"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type Cassandra interface {
	// Parameters:
	//  - AuthRequest
	Login(auth_request *AuthenticationRequest) (err error)
	// Parameters:
	//  - Keyspace
	SetKeyspace(keyspace string) (err error)
	// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
	// the only method that can throw an exception under non-failure conditions.)
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - ConsistencyLevel
	Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error)
	// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
	// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error)
	// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
	// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error)
	// Performs a get_slice for column_parent and predicate for the given keys in parallel.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error)
	// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error)
	// returns a subset of columns for a contiguous range of keys.
	//
	// Parameters:
	//  - ColumnParent
	//  - Predicate
	//  - RangeA1
	//  - ConsistencyLevel
	GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
	//
	// Parameters:
	//  - ColumnFamily
	//  - RangeA1
	//  - StartColumn
	//  - ConsistencyLevel
	GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
	// @deprecated use get_range_slices instead with range.row_filter specified
	//
	// Parameters:
	//  - ColumnParent
	//  - IndexClause
	//  - ColumnPredicate
	//  - ConsistencyLevel
	GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error)
	// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error)
	// Increment or decrement a counter.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error)
	// Atomic compare and set.
	//
	// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
	// Otherwise, success will be false and current_values will contain the current values for the columns in
	// expected (that, by definition of compare-and-set, will differ from the values in expected).
	//
	// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
	// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
	// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
	// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
	// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
	// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
	// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
	// the write.
	//
	// Parameters:
	//  - Key
	//  - ColumnFamily
	//  - Expected
	//  - Updates
	//  - SerialConsistencyLevel
	//  - CommitConsistencyLevel
	Cas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error)
	// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
	// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
	// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - Timestamp
	//  - ConsistencyLevel
	Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error)
	// Remove a counter at the specified location.
	// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
	// until the delete has reached all the nodes and all of them have been fully compacted.
	//
	// Parameters:
	//  - Key
	//  - Path
	//  - ConsistencyLevel
	RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error)
	//   Mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
	//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error)
	// Truncate will mark and entire column family as deleted.
	// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
	// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
	// only marks the data as deleted.
	// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
	// some hosts are down.
	//
	// Parameters:
	//  - Cfname
	Truncate(cfname string) (err error)
	// for each schema version present in the cluster, returns a list of nodes at that version.
	// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
	// the cluster is all on the same version if the size of the map is 1.
	DescribeSchemaVersions() (r map[string][]string, err error)
	// list the defined keyspaces in this cluster
	DescribeKeyspaces() (r []*KsDef, err error)
	// get the cluster name
	DescribeClusterName() (r string, err error)
	// get the thrift api version
	DescribeVersion() (r string, err error)
	// get the token ring: a map of ranges to host addresses,
	// represented as a set of TokenRange instead of a map from range
	// to list of endpoints, because you can't use Thrift structs as
	// map keys:
	// https://issues.apache.org/jira/browse/THRIFT-162
	//
	// for the same reason, we can't return a set here, even though
	// order is neither important nor predictable.
	//
	// Parameters:
	//  - Keyspace
	DescribeRing(keyspace string) (r []*TokenRange, err error)
	// same as describe_ring, but considers only nodes in the local DC
	//
	// Parameters:
	//  - Keyspace
	DescribeLocalRing(keyspace string) (r []*TokenRange, err error)
	// get the mapping between token->node ip
	// without taking replication into consideration
	// https://issues.apache.org/jira/browse/CASSANDRA-4092
	DescribeTokenMap() (r map[string]string, err error)
	// returns the partitioner used by this cluster
	DescribePartitioner() (r string, err error)
	// returns the snitch used by this cluster
	DescribeSnitch() (r string, err error)
	// describe specified keyspace
	//
	// Parameters:
	//  - Keyspace
	DescribeKeyspace(keyspace string) (r *KsDef, err error)
	// experimental API for hadoop/parallel query support.
	// may change violently and without warning.
	//
	// returns list of token strings such that first subrange is (list[0], list[1]],
	// next is (list[1], list[2]], etc.
	//
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error)
	// Enables tracing for the next query in this connection and returns the UUID for that trace session
	// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
	TraceNextQuery() (r []byte, err error)
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error)
	// adds a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemAddColumnFamily(cf_def *CfDef) (r string, err error)
	// drops a column family. returns the new schema id.
	//
	// Parameters:
	//  - ColumnFamily
	SystemDropColumnFamily(column_family string) (r string, err error)
	// adds a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemAddKeyspace(ks_def *KsDef) (r string, err error)
	// drops a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - Keyspace
	SystemDropKeyspace(keyspace string) (r string, err error)
	// updates properties of a keyspace. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemUpdateKeyspace(ks_def *KsDef) (r string, err error)
	// updates properties of a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - Query
	//  - Compression
	ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult_, err error)
	// Executes a CQL3 (Cassandra Query Language) statement and returns a
	// CqlResult containing the results.
	//
	// Parameters:
	//  - Query
	//  - Compression
	//  - Consistency
	ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult_, err error)
	// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
	// - the type of CQL statement
	// - an id token of the compiled CQL stored on the server side.
	// - a count of the discovered bound markers in the statement
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult_, err error)
	// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult_, err error)
	// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
	// to bind, and the consistency level, and returns a CqlResult containing the results.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	//  - Consistency
	ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error)
	// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
	//
	// Parameters:
	//  - Version
	SetCqlVersion(version string) (err error)
}

type CassandraClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewCassandraClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewCassandraClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - AuthRequest
func (p *CassandraClient) Login(auth_request *AuthenticationRequest) (err error) {
	if err = p.sendLogin(auth_request); err != nil {
		return
	}
	return p.recvLogin()
}

func (p *CassandraClient) sendLogin(auth_request *AuthenticationRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("login", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := LoginArgs{
		AuthRequest: auth_request,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvLogin() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error33 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error34 error
		error34, err = error33.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error34
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "login failed: out of sequence response")
		return
	}
	result := LoginResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Authnx != nil {
		err = result.Authnx
		return
	} else if result.Authzx != nil {
		err = result.Authzx
		return
	}
	return
}

// Parameters:
//  - Keyspace
func (p *CassandraClient) SetKeyspace(keyspace string) (err error) {
	if err = p.sendSetKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSetKeyspace()
}

func (p *CassandraClient) sendSetKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("set_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SetKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSetKeyspace() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "set_keyspace failed: out of sequence response")
		return
	}
	result := SetKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	return
}

// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
// the only method that can throw an exception under non-failure conditions.)
//
// Parameters:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
func (p *CassandraClient) Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, err error) {
	if err = p.sendGet(key, column_path, consistency_level); err != nil {
		return
	}
	return p.recvGet()
}

func (p *CassandraClient) sendGet(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetArgs{
		Key:              key,
		ColumnPath:       column_path,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGet() (value *ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error37 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error38 error
		error38, err = error37.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error38
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result := GetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Nfe != nil {
		err = result.Nfe
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, err error) {
	if err = p.sendGetSlice(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetSlice()
}

func (p *CassandraClient) sendGetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetSliceArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetSlice() (value []*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_slice failed: out of sequence response")
		return
	}
	result := GetSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, err error) {
	if err = p.sendGetCount(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetCount()
}

func (p *CassandraClient) sendGetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetCountArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetCount() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error41 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error42 error
		error42, err = error41.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error42
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_count failed: out of sequence response")
		return
	}
	result := GetCountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Performs a get_slice for column_parent and predicate for the given keys in parallel.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, err error) {
	if err = p.sendMultigetSlice(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetSlice()
}

func (p *CassandraClient) sendMultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MultigetSliceArgs{
		Keys:             keys,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetSlice() (value map[string][]*ColumnOrSuperColumn, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_slice failed: out of sequence response")
		return
	}
	result := MultigetSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, err error) {
	if err = p.sendMultigetCount(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetCount()
}

func (p *CassandraClient) sendMultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("multiget_count", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MultigetCountArgs{
		Keys:             keys,
		ColumnParent:     column_parent,
		Predicate:        predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvMultigetCount() (value map[string]int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error45 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error46 error
		error46, err = error45.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error46
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "multiget_count failed: out of sequence response")
		return
	}
	result := MultigetCountResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns a subset of columns for a contiguous range of keys.
//
// Parameters:
//  - ColumnParent
//  - Predicate
//  - RangeA1
//  - ConsistencyLevel
func (p *CassandraClient) GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetRangeSlices(column_parent, predicate, range_a1, consistency_level); err != nil {
		return
	}
	return p.recvGetRangeSlices()
}

func (p *CassandraClient) sendGetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_range_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRangeSlicesArgs{
		ColumnParent:     column_parent,
		Predicate:        predicate,
		RangeA1:          range_a1,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetRangeSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_range_slices failed: out of sequence response")
		return
	}
	result := GetRangeSlicesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
//
// Parameters:
//  - ColumnFamily
//  - RangeA1
//  - StartColumn
//  - ConsistencyLevel
func (p *CassandraClient) GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetPagedSlice(column_family, range_a1, start_column, consistency_level); err != nil {
		return
	}
	return p.recvGetPagedSlice()
}

func (p *CassandraClient) sendGetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_paged_slice", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetPagedSliceArgs{
		ColumnFamily:     column_family,
		RangeA1:          range_a1,
		StartColumn:      start_column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetPagedSlice() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error49 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error50 error
		error50, err = error49.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error50
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_paged_slice failed: out of sequence response")
		return
	}
	result := GetPagedSliceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
// @deprecated use get_range_slices instead with range.row_filter specified
//
// Parameters:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
func (p *CassandraClient) GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, err error) {
	if err = p.sendGetIndexedSlices(column_parent, index_clause, column_predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetIndexedSlices()
}

func (p *CassandraClient) sendGetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_indexed_slices", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetIndexedSlicesArgs{
		ColumnParent:     column_parent,
		IndexClause:      index_clause,
		ColumnPredicate:  column_predicate,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvGetIndexedSlices() (value []*KeySlice, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_indexed_slices failed: out of sequence response")
		return
	}
	result := GetIndexedSlicesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendInsert(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvInsert()
}

func (p *CassandraClient) sendInsert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("insert", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := InsertArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Column:           column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvInsert() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error53 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error54 error
		error54, err = error53.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error54
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "insert failed: out of sequence response")
		return
	}
	result := InsertResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Increment or decrement a counter.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendAdd(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CassandraClient) sendAdd(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("add", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AddArgs{
		Key:              key,
		ColumnParent:     column_parent,
		Column:           column,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvAdd() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "add failed: out of sequence response")
		return
	}
	result := AddResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Atomic compare and set.
//
// If the cas is successfull, the success boolean in CASResult will be true and there will be no current_values.
// Otherwise, success will be false and current_values will contain the current values for the columns in
// expected (that, by definition of compare-and-set, will differ from the values in expected).
//
// A cas operation takes 2 consistency level. The first one, serial_consistency_level, simply indicates the
// level of serialization required. This can be either ConsistencyLevel.SERIAL or ConsistencyLevel.LOCAL_SERIAL.
// The second one, commit_consistency_level, defines the consistency level for the commit phase of the cas. This
// is a more traditional consistency level (the same CL than for traditional writes are accepted) that impact
// the visibility for reads of the operation. For instance, if commit_consistency_level is QUORUM, then it is
// guaranteed that a followup QUORUM read will see the cas write (if that one was successful obviously). If
// commit_consistency_level is ANY, you will need to use a SERIAL/LOCAL_SERIAL read to be guaranteed to see
// the write.
//
// Parameters:
//  - Key
//  - ColumnFamily
//  - Expected
//  - Updates
//  - SerialConsistencyLevel
//  - CommitConsistencyLevel
func (p *CassandraClient) Cas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (r *CASResult_, err error) {
	if err = p.sendCas(key, column_family, expected, updates, serial_consistency_level, commit_consistency_level); err != nil {
		return
	}
	return p.recvCas()
}

func (p *CassandraClient) sendCas(key []byte, column_family string, expected []*Column, updates []*Column, serial_consistency_level ConsistencyLevel, commit_consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("cas", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CasArgs{
		Key:                    key,
		ColumnFamily:           column_family,
		Expected:               expected,
		Updates:                updates,
		SerialConsistencyLevel: serial_consistency_level,
		CommitConsistencyLevel: commit_consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvCas() (value *CASResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error57 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error58 error
		error58, err = error57.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error58
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "cas failed: out of sequence response")
		return
	}
	result := CasResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	value = result.GetSuccess()
	return
}

// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
//
// Parameters:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
func (p *CassandraClient) Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemove(key, column_path, timestamp, consistency_level); err != nil {
		return
	}
	return p.recvRemove()
}

func (p *CassandraClient) sendRemove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RemoveArgs{
		Key:              key,
		ColumnPath:       column_path,
		Timestamp:        timestamp,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemove() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove failed: out of sequence response")
		return
	}
	result := RemoveResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Remove a counter at the specified location.
// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
// until the delete has reached all the nodes and all of them have been fully compacted.
//
// Parameters:
//  - Key
//  - Path
//  - ConsistencyLevel
func (p *CassandraClient) RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendRemoveCounter(key, path, consistency_level); err != nil {
		return
	}
	return p.recvRemoveCounter()
}

func (p *CassandraClient) sendRemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("remove_counter", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := RemoveCounterArgs{
		Key:              key,
		Path:             path,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvRemoveCounter() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error61 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error62 error
		error62, err = error61.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error62
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "remove_counter failed: out of sequence response")
		return
	}
	result := RemoveCounterResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

//   Mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvBatchMutate()
}

func (p *CassandraClient) sendBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("batch_mutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := BatchMutateArgs{
		MutationMap:      mutation_map,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvBatchMutate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "batch_mutate failed: out of sequence response")
		return
	}
	result := BatchMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	if err = p.sendAtomicBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvAtomicBatchMutate()
}

func (p *CassandraClient) sendAtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("atomic_batch_mutate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AtomicBatchMutateArgs{
		MutationMap:      mutation_map,
		ConsistencyLevel: consistency_level,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvAtomicBatchMutate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error65 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error66 error
		error66, err = error65.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error66
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "atomic_batch_mutate failed: out of sequence response")
		return
	}
	result := AtomicBatchMutateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// Truncate will mark and entire column family as deleted.
// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
// only marks the data as deleted.
// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
// some hosts are down.
//
// Parameters:
//  - Cfname
func (p *CassandraClient) Truncate(cfname string) (err error) {
	if err = p.sendTruncate(cfname); err != nil {
		return
	}
	return p.recvTruncate()
}

func (p *CassandraClient) sendTruncate(cfname string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("truncate", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TruncateArgs{
		Cfname: cfname,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvTruncate() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "truncate failed: out of sequence response")
		return
	}
	result := TruncateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	}
	return
}

// for each schema version present in the cluster, returns a list of nodes at that version.
// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
// the cluster is all on the same version if the size of the map is 1.
func (p *CassandraClient) DescribeSchemaVersions() (r map[string][]string, err error) {
	if err = p.sendDescribeSchemaVersions(); err != nil {
		return
	}
	return p.recvDescribeSchemaVersions()
}

func (p *CassandraClient) sendDescribeSchemaVersions() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_schema_versions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeSchemaVersionsArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSchemaVersions() (value map[string][]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error69 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error70 error
		error70, err = error69.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error70
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_schema_versions failed: out of sequence response")
		return
	}
	result := DescribeSchemaVersionsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// list the defined keyspaces in this cluster
func (p *CassandraClient) DescribeKeyspaces() (r []*KsDef, err error) {
	if err = p.sendDescribeKeyspaces(); err != nil {
		return
	}
	return p.recvDescribeKeyspaces()
}

func (p *CassandraClient) sendDescribeKeyspaces() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspaces", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeKeyspacesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspaces() (value []*KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspaces failed: out of sequence response")
		return
	}
	result := DescribeKeyspacesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// get the cluster name
func (p *CassandraClient) DescribeClusterName() (r string, err error) {
	if err = p.sendDescribeClusterName(); err != nil {
		return
	}
	return p.recvDescribeClusterName()
}

func (p *CassandraClient) sendDescribeClusterName() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_cluster_name", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeClusterNameArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeClusterName() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error73 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error74 error
		error74, err = error73.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error74
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_cluster_name failed: out of sequence response")
		return
	}
	result := DescribeClusterNameResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// get the thrift api version
func (p *CassandraClient) DescribeVersion() (r string, err error) {
	if err = p.sendDescribeVersion(); err != nil {
		return
	}
	return p.recvDescribeVersion()
}

func (p *CassandraClient) sendDescribeVersion() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_version", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeVersionArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeVersion() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_version failed: out of sequence response")
		return
	}
	result := DescribeVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// get the token ring: a map of ranges to host addresses,
// represented as a set of TokenRange instead of a map from range
// to list of endpoints, because you can't use Thrift structs as
// map keys:
// https://issues.apache.org/jira/browse/THRIFT-162
//
// for the same reason, we can't return a set here, even though
// order is neither important nor predictable.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeRing(keyspace string) (r []*TokenRange, err error) {
	if err = p.sendDescribeRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeRing()
}

func (p *CassandraClient) sendDescribeRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_ring", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeRingArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeRing() (value []*TokenRange, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error77 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error78 error
		error78, err = error77.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error78
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_ring failed: out of sequence response")
		return
	}
	result := DescribeRingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// same as describe_ring, but considers only nodes in the local DC
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeLocalRing(keyspace string) (r []*TokenRange, err error) {
	if err = p.sendDescribeLocalRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeLocalRing()
}

func (p *CassandraClient) sendDescribeLocalRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_local_ring", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeLocalRingArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeLocalRing() (value []*TokenRange, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_local_ring failed: out of sequence response")
		return
	}
	result := DescribeLocalRingResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// get the mapping between token->node ip
// without taking replication into consideration
// https://issues.apache.org/jira/browse/CASSANDRA-4092
func (p *CassandraClient) DescribeTokenMap() (r map[string]string, err error) {
	if err = p.sendDescribeTokenMap(); err != nil {
		return
	}
	return p.recvDescribeTokenMap()
}

func (p *CassandraClient) sendDescribeTokenMap() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_token_map", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeTokenMapArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeTokenMap() (value map[string]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error81 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error82 error
		error82, err = error81.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error82
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_token_map failed: out of sequence response")
		return
	}
	result := DescribeTokenMapResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// returns the partitioner used by this cluster
func (p *CassandraClient) DescribePartitioner() (r string, err error) {
	if err = p.sendDescribePartitioner(); err != nil {
		return
	}
	return p.recvDescribePartitioner()
}

func (p *CassandraClient) sendDescribePartitioner() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_partitioner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribePartitionerArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribePartitioner() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_partitioner failed: out of sequence response")
		return
	}
	result := DescribePartitionerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// returns the snitch used by this cluster
func (p *CassandraClient) DescribeSnitch() (r string, err error) {
	if err = p.sendDescribeSnitch(); err != nil {
		return
	}
	return p.recvDescribeSnitch()
}

func (p *CassandraClient) sendDescribeSnitch() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_snitch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeSnitchArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSnitch() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error85 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error86 error
		error86, err = error85.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error86
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_snitch failed: out of sequence response")
		return
	}
	result := DescribeSnitchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// describe specified keyspace
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeKeyspace(keyspace string) (r *KsDef, err error) {
	if err = p.sendDescribeKeyspace(keyspace); err != nil {
		return
	}
	return p.recvDescribeKeyspace()
}

func (p *CassandraClient) sendDescribeKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeKeyspace() (value *KsDef, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_keyspace failed: out of sequence response")
		return
	}
	result := DescribeKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Nfe != nil {
		err = result.Nfe
		return
	} else if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// experimental API for hadoop/parallel query support.
// may change violently and without warning.
//
// returns list of token strings such that first subrange is (list[0], list[1]],
// next is (list[1], list[2]], etc.
//
// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, err error) {
	if err = p.sendDescribeSplits(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplits()
}

func (p *CassandraClient) sendDescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_splits", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeSplitsArgs{
		CfName:       cfName,
		StartToken:   start_token,
		EndToken:     end_token,
		KeysPerSplit: keys_per_split,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSplits() (value []string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error89 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error90 error
		error90, err = error89.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error90
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_splits failed: out of sequence response")
		return
	}
	result := DescribeSplitsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// Enables tracing for the next query in this connection and returns the UUID for that trace session
// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
func (p *CassandraClient) TraceNextQuery() (r []byte, err error) {
	if err = p.sendTraceNextQuery(); err != nil {
		return
	}
	return p.recvTraceNextQuery()
}

func (p *CassandraClient) sendTraceNextQuery() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("trace_next_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TraceNextQueryArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvTraceNextQuery() (value []byte, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "trace_next_query failed: out of sequence response")
		return
	}
	result := TraceNextQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, err error) {
	if err = p.sendDescribeSplitsEx(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplitsEx()
}

func (p *CassandraClient) sendDescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("describe_splits_ex", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DescribeSplitsExArgs{
		CfName:       cfName,
		StartToken:   start_token,
		EndToken:     end_token,
		KeysPerSplit: keys_per_split,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvDescribeSplitsEx() (value []*CfSplit, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error93 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error94 error
		error94, err = error93.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error94
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "describe_splits_ex failed: out of sequence response")
		return
	}
	result := DescribeSplitsExResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// adds a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemAddColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemAddColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemAddColumnFamily()
}

func (p *CassandraClient) sendSystemAddColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemAddColumnFamilyArgs{
		CfDef: cf_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_column_family failed: out of sequence response")
		return
	}
	result := SystemAddColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// drops a column family. returns the new schema id.
//
// Parameters:
//  - ColumnFamily
func (p *CassandraClient) SystemDropColumnFamily(column_family string) (r string, err error) {
	if err = p.sendSystemDropColumnFamily(column_family); err != nil {
		return
	}
	return p.recvSystemDropColumnFamily()
}

func (p *CassandraClient) sendSystemDropColumnFamily(column_family string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemDropColumnFamilyArgs{
		ColumnFamily: column_family,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error97 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error98 error
		error98, err = error97.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error98
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_column_family failed: out of sequence response")
		return
	}
	result := SystemDropColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// adds a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemAddKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemAddKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemAddKeyspace()
}

func (p *CassandraClient) sendSystemAddKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_add_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemAddKeyspaceArgs{
		KsDef: ks_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemAddKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_add_keyspace failed: out of sequence response")
		return
	}
	result := SystemAddKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// drops a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) SystemDropKeyspace(keyspace string) (r string, err error) {
	if err = p.sendSystemDropKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSystemDropKeyspace()
}

func (p *CassandraClient) sendSystemDropKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_drop_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemDropKeyspaceArgs{
		Keyspace: keyspace,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemDropKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error101 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error102 error
		error102, err = error101.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error102
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_drop_keyspace failed: out of sequence response")
		return
	}
	result := SystemDropKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// updates properties of a keyspace. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemUpdateKeyspace(ks_def *KsDef) (r string, err error) {
	if err = p.sendSystemUpdateKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemUpdateKeyspace()
}

func (p *CassandraClient) sendSystemUpdateKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_keyspace", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemUpdateKeyspaceArgs{
		KsDef: ks_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateKeyspace() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		error104, err = error103.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error104
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_keyspace failed: out of sequence response")
		return
	}
	result := SystemUpdateKeyspaceResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// updates properties of a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemUpdateColumnFamily(cf_def *CfDef) (r string, err error) {
	if err = p.sendSystemUpdateColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemUpdateColumnFamily()
}

func (p *CassandraClient) sendSystemUpdateColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("system_update_column_family", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SystemUpdateColumnFamilyArgs{
		CfDef: cf_def,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSystemUpdateColumnFamily() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error105 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error106 error
		error106, err = error105.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error106
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "system_update_column_family failed: out of sequence response")
		return
	}
	result := SystemUpdateColumnFamilyResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult_, err error) {
	if err = p.sendExecuteCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvExecuteCqlQuery()
}

func (p *CassandraClient) sendExecuteCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecuteCqlQueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecuteCqlQuery() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		error108, err = error107.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error108
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_cql_query failed: out of sequence response")
		return
	}
	result := ExecuteCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// Executes a CQL3 (Cassandra Query Language) statement and returns a
// CqlResult containing the results.
//
// Parameters:
//  - Query
//  - Compression
//  - Consistency
func (p *CassandraClient) ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult_, err error) {
	if err = p.sendExecuteCql3Query(query, compression, consistency); err != nil {
		return
	}
	return p.recvExecuteCql3Query()
}

func (p *CassandraClient) sendExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecuteCql3QueryArgs{
		Query:       query,
		Compression: compression,
		Consistency: consistency,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecuteCql3Query() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error109 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error110 error
		error110, err = error109.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error110
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_cql3_query failed: out of sequence response")
		return
	}
	result := ExecuteCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
	if err = p.sendPrepareCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvPrepareCqlQuery()
}

func (p *CassandraClient) sendPrepareCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("prepare_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PrepareCqlQueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvPrepareCqlQuery() (value *CqlPreparedResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		error112, err = error111.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error112
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "prepare_cql_query failed: out of sequence response")
		return
	}
	result := PrepareCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// Prepare a CQL3 (Cassandra Query Language) statement by compiling and returning
// - the type of CQL statement
// - an id token of the compiled CQL stored on the server side.
// - a count of the discovered bound markers in the statement
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult_, err error) {
	if err = p.sendPrepareCql3Query(query, compression); err != nil {
		return
	}
	return p.recvPrepareCql3Query()
}

func (p *CassandraClient) sendPrepareCql3Query(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("prepare_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PrepareCql3QueryArgs{
		Query:       query,
		Compression: compression,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvPrepareCql3Query() (value *CqlPreparedResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error113 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error114 error
		error114, err = error113.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error114
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "prepare_cql3_query failed: out of sequence response")
		return
	}
	result := PrepareCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated Will become a no-op in 2.2. Please use the CQL3 version instead.
//
// Parameters:
//  - ItemId
//  - Values
func (p *CassandraClient) ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult_, err error) {
	if err = p.sendExecutePreparedCqlQuery(itemId, values); err != nil {
		return
	}
	return p.recvExecutePreparedCqlQuery()
}

func (p *CassandraClient) sendExecutePreparedCqlQuery(itemId int32, values [][]byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecutePreparedCqlQueryArgs{
		ItemId: itemId,
		Values: values,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecutePreparedCqlQuery() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		error116, err = error115.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error116
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_prepared_cql_query failed: out of sequence response")
		return
	}
	result := ExecutePreparedCqlQueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// Executes a prepared CQL3 (Cassandra Query Language) statement by passing an id token, a list of variables
// to bind, and the consistency level, and returns a CqlResult containing the results.
//
// Parameters:
//  - ItemId
//  - Values
//  - Consistency
func (p *CassandraClient) ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult_, err error) {
	if err = p.sendExecutePreparedCql3Query(itemId, values, consistency); err != nil {
		return
	}
	return p.recvExecutePreparedCql3Query()
}

func (p *CassandraClient) sendExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecutePreparedCql3QueryArgs{
		ItemId:      itemId,
		Values:      values,
		Consistency: consistency,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvExecutePreparedCql3Query() (value *CqlResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error117 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error118 error
		error118, err = error117.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error118
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "execute_prepared_cql3_query failed: out of sequence response")
		return
	}
	result := ExecutePreparedCql3QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	} else if result.Ue != nil {
		err = result.Ue
		return
	} else if result.Te != nil {
		err = result.Te
		return
	} else if result.Sde != nil {
		err = result.Sde
		return
	}
	value = result.GetSuccess()
	return
}

// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
//
// Parameters:
//  - Version
func (p *CassandraClient) SetCqlVersion(version string) (err error) {
	if err = p.sendSetCqlVersion(version); err != nil {
		return
	}
	return p.recvSetCqlVersion()
}

func (p *CassandraClient) sendSetCqlVersion(version string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("set_cql_version", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := SetCqlVersionArgs{
		Version: version,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *CassandraClient) recvSetCqlVersion() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		error120, err = error119.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error120
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "set_cql_version failed: out of sequence response")
		return
	}
	result := SetCqlVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Ire != nil {
		err = result.Ire
		return
	}
	return
}

type CassandraProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Cassandra
}

func (p *CassandraProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *CassandraProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *CassandraProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewCassandraProcessor(handler Cassandra) *CassandraProcessor {

	self121 := &CassandraProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self121.processorMap["login"] = &cassandraProcessorLogin{handler: handler}
	self121.processorMap["set_keyspace"] = &cassandraProcessorSetKeyspace{handler: handler}
	self121.processorMap["get"] = &cassandraProcessorGet{handler: handler}
	self121.processorMap["get_slice"] = &cassandraProcessorGetSlice{handler: handler}
	self121.processorMap["get_count"] = &cassandraProcessorGetCount{handler: handler}
	self121.processorMap["multiget_slice"] = &cassandraProcessorMultigetSlice{handler: handler}
	self121.processorMap["multiget_count"] = &cassandraProcessorMultigetCount{handler: handler}
	self121.processorMap["get_range_slices"] = &cassandraProcessorGetRangeSlices{handler: handler}
	self121.processorMap["get_paged_slice"] = &cassandraProcessorGetPagedSlice{handler: handler}
	self121.processorMap["get_indexed_slices"] = &cassandraProcessorGetIndexedSlices{handler: handler}
	self121.processorMap["insert"] = &cassandraProcessorInsert{handler: handler}
	self121.processorMap["add"] = &cassandraProcessorAdd{handler: handler}
	self121.processorMap["cas"] = &cassandraProcessorCas{handler: handler}
	self121.processorMap["remove"] = &cassandraProcessorRemove{handler: handler}
	self121.processorMap["remove_counter"] = &cassandraProcessorRemoveCounter{handler: handler}
	self121.processorMap["batch_mutate"] = &cassandraProcessorBatchMutate{handler: handler}
	self121.processorMap["atomic_batch_mutate"] = &cassandraProcessorAtomicBatchMutate{handler: handler}
	self121.processorMap["truncate"] = &cassandraProcessorTruncate{handler: handler}
	self121.processorMap["describe_schema_versions"] = &cassandraProcessorDescribeSchemaVersions{handler: handler}
	self121.processorMap["describe_keyspaces"] = &cassandraProcessorDescribeKeyspaces{handler: handler}
	self121.processorMap["describe_cluster_name"] = &cassandraProcessorDescribeClusterName{handler: handler}
	self121.processorMap["describe_version"] = &cassandraProcessorDescribeVersion{handler: handler}
	self121.processorMap["describe_ring"] = &cassandraProcessorDescribeRing{handler: handler}
	self121.processorMap["describe_local_ring"] = &cassandraProcessorDescribeLocalRing{handler: handler}
	self121.processorMap["describe_token_map"] = &cassandraProcessorDescribeTokenMap{handler: handler}
	self121.processorMap["describe_partitioner"] = &cassandraProcessorDescribePartitioner{handler: handler}
	self121.processorMap["describe_snitch"] = &cassandraProcessorDescribeSnitch{handler: handler}
	self121.processorMap["describe_keyspace"] = &cassandraProcessorDescribeKeyspace{handler: handler}
	self121.processorMap["describe_splits"] = &cassandraProcessorDescribeSplits{handler: handler}
	self121.processorMap["trace_next_query"] = &cassandraProcessorTraceNextQuery{handler: handler}
	self121.processorMap["describe_splits_ex"] = &cassandraProcessorDescribeSplitsEx{handler: handler}
	self121.processorMap["system_add_column_family"] = &cassandraProcessorSystemAddColumnFamily{handler: handler}
	self121.processorMap["system_drop_column_family"] = &cassandraProcessorSystemDropColumnFamily{handler: handler}
	self121.processorMap["system_add_keyspace"] = &cassandraProcessorSystemAddKeyspace{handler: handler}
	self121.processorMap["system_drop_keyspace"] = &cassandraProcessorSystemDropKeyspace{handler: handler}
	self121.processorMap["system_update_keyspace"] = &cassandraProcessorSystemUpdateKeyspace{handler: handler}
	self121.processorMap["system_update_column_family"] = &cassandraProcessorSystemUpdateColumnFamily{handler: handler}
	self121.processorMap["execute_cql_query"] = &cassandraProcessorExecuteCqlQuery{handler: handler}
	self121.processorMap["execute_cql3_query"] = &cassandraProcessorExecuteCql3Query{handler: handler}
	self121.processorMap["prepare_cql_query"] = &cassandraProcessorPrepareCqlQuery{handler: handler}
	self121.processorMap["prepare_cql3_query"] = &cassandraProcessorPrepareCql3Query{handler: handler}
	self121.processorMap["execute_prepared_cql_query"] = &cassandraProcessorExecutePreparedCqlQuery{handler: handler}
	self121.processorMap["execute_prepared_cql3_query"] = &cassandraProcessorExecutePreparedCql3Query{handler: handler}
	self121.processorMap["set_cql_version"] = &cassandraProcessorSetCqlVersion{handler: handler}
	return self121
}

func (p *CassandraProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x122 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x122.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x122

}

type cassandraProcessorLogin struct {
	handler Cassandra
}

func (p *cassandraProcessorLogin) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := LoginArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := LoginResult{}
	var err2 error
	if err2 = p.handler.Login(args.AuthRequest); err2 != nil {
		switch v := err2.(type) {
		case *AuthenticationException:
			result.Authnx = v
		case *AuthorizationException:
			result.Authzx = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing login: "+err2.Error())
			oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("login", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSetKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SetKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SetKeyspaceResult{}
	var err2 error
	if err2 = p.handler.SetKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("set_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGet struct {
	handler Cassandra
}

func (p *cassandraProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResult{}
	var err2 error
	if result.Success, err2 = p.handler.Get(args.Key, args.ColumnPath, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *NotFoundException:
			result.Nfe = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetSliceResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetSlice(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_slice: "+err2.Error())
			oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorGetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetCountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetCountResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.GetCount(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_count: "+err2.Error())
			oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("get_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MultigetSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MultigetSliceResult{}
	var err2 error
	if result.Success, err2 = p.handler.MultigetSlice(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_slice: "+err2.Error())
			oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("multiget_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MultigetCountArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MultigetCountResult{}
	var err2 error
	if result.Success, err2 = p.handler.MultigetCount(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_count: "+err2.Error())
			oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("multiget_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetRangeSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetRangeSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRangeSlicesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRangeSlicesResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetRangeSlices(args.ColumnParent, args.Predicate, args.RangeA1, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_range_slices: "+err2.Error())
			oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_range_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetPagedSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetPagedSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetPagedSliceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetPagedSliceResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetPagedSlice(args.ColumnFamily, args.RangeA1, args.StartColumn, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_paged_slice: "+err2.Error())
			oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_paged_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetIndexedSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetIndexedSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetIndexedSlicesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetIndexedSlicesResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetIndexedSlices(args.ColumnParent, args.IndexClause, args.ColumnPredicate, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_indexed_slices: "+err2.Error())
			oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get_indexed_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorInsert struct {
	handler Cassandra
}

func (p *cassandraProcessorInsert) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := InsertArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := InsertResult{}
	var err2 error
	if err2 = p.handler.Insert(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing insert: "+err2.Error())
			oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("insert", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAdd struct {
	handler Cassandra
}

func (p *cassandraProcessorAdd) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AddArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AddResult{}
	var err2 error
	if err2 = p.handler.Add(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing add: "+err2.Error())
			oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("add", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorCas struct {
	handler Cassandra
}

func (p *cassandraProcessorCas) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CasArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CasResult{}
	var err2 error
	if result.Success, err2 = p.handler.Cas(args.Key, args.ColumnFamily, args.Expected, args.Updates, args.SerialConsistencyLevel, args.CommitConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing cas: "+err2.Error())
			oprot.WriteMessageBegin("cas", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("cas", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemove struct {
	handler Cassandra
}

func (p *cassandraProcessorRemove) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoveArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RemoveResult{}
	var err2 error
	if err2 = p.handler.Remove(args.Key, args.ColumnPath, args.Timestamp, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: "+err2.Error())
			oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemoveCounter struct {
	handler Cassandra
}

func (p *cassandraProcessorRemoveCounter) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := RemoveCounterArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := RemoveCounterResult{}
	var err2 error
	if err2 = p.handler.RemoveCounter(args.Key, args.Path, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove_counter: "+err2.Error())
			oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("remove_counter", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := BatchMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := BatchMutateResult{}
	var err2 error
	if err2 = p.handler.BatchMutate(args.MutationMap, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch_mutate: "+err2.Error())
			oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAtomicBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorAtomicBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AtomicBatchMutateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AtomicBatchMutateResult{}
	var err2 error
	if err2 = p.handler.AtomicBatchMutate(args.MutationMap, args.ConsistencyLevel); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomic_batch_mutate: "+err2.Error())
			oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("atomic_batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTruncate struct {
	handler Cassandra
}

func (p *cassandraProcessorTruncate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TruncateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TruncateResult{}
	var err2 error
	if err2 = p.handler.Truncate(args.Cfname); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: "+err2.Error())
			oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("truncate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSchemaVersions struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSchemaVersions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeSchemaVersionsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeSchemaVersionsResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeSchemaVersions(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_schema_versions: "+err2.Error())
			oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_schema_versions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspaces struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspaces) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeKeyspacesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeKeyspacesResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeKeyspaces(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspaces: "+err2.Error())
			oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspaces", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeClusterName struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeClusterName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeClusterNameArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeClusterNameResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeClusterName(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_cluster_name: "+err2.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("describe_cluster_name", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeVersionResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeVersion(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_version: "+err2.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("describe_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeRingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeRingResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeRing(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_ring: "+err2.Error())
			oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeLocalRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeLocalRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeLocalRingArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeLocalRingResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeLocalRing(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_local_ring: "+err2.Error())
			oprot.WriteMessageBegin("describe_local_ring", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_local_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeTokenMap struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeTokenMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeTokenMapArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeTokenMapResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeTokenMap(); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_token_map: "+err2.Error())
			oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_token_map", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribePartitioner struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribePartitioner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribePartitionerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribePartitionerResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribePartitioner(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_partitioner: "+err2.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("describe_partitioner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSnitch struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSnitch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeSnitchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeSnitchResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DescribeSnitch(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_snitch: "+err2.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("describe_snitch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeKeyspaceResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *NotFoundException:
			result.Nfe = v
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplits struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeSplitsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeSplitsResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeSplits(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits: "+err2.Error())
			oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTraceNextQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorTraceNextQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TraceNextQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TraceNextQueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.TraceNextQuery(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing trace_next_query: "+err2.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	if err2 = oprot.WriteMessageBegin("trace_next_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplitsEx struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplitsEx) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DescribeSplitsExArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DescribeSplitsExResult{}
	var err2 error
	if result.Success, err2 = p.handler.DescribeSplitsEx(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits_ex: "+err2.Error())
			oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("describe_splits_ex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemAddColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemAddColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemAddColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_add_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemDropColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemDropColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemDropColumnFamily(args.ColumnFamily); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_drop_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemAddKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemAddKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemAddKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_add_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemDropKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemDropKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemDropKeyspace(args.Keyspace); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_drop_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemUpdateKeyspaceArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemUpdateKeyspaceResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemUpdateKeyspace(args.KsDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_keyspace: "+err2.Error())
			oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_update_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SystemUpdateColumnFamilyArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SystemUpdateColumnFamilyResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.SystemUpdateColumnFamily(args.CfDef); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_column_family: "+err2.Error())
			oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("system_update_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecuteCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecuteCqlQueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.ExecuteCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecuteCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecuteCql3QueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.ExecuteCql3Query(args.Query, args.Compression, args.Consistency); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PrepareCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PrepareCqlQueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.PrepareCqlQuery(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("prepare_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PrepareCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PrepareCql3QueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.PrepareCql3Query(args.Query, args.Compression); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("prepare_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecutePreparedCqlQueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecutePreparedCqlQueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.ExecutePreparedCqlQuery(args.ItemId, args.Values); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecutePreparedCql3QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecutePreparedCql3QueryResult{}
	var err2 error
	if result.Success, err2 = p.handler.ExecutePreparedCql3Query(args.ItemId, args.Values, args.Consistency); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		case *UnavailableException:
			result.Ue = v
		case *TimedOutException:
			result.Te = v
		case *SchemaDisagreementException:
			result.Sde = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql3_query: "+err2.Error())
			oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetCqlVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorSetCqlVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := SetCqlVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := SetCqlVersionResult{}
	var err2 error
	if err2 = p.handler.SetCqlVersion(args.Version); err2 != nil {
		switch v := err2.(type) {
		case *InvalidRequestException:
			result.Ire = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cql_version: "+err2.Error())
			oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("set_cql_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type LoginArgs struct {
	AuthRequest *AuthenticationRequest `thrift:"auth_request,1,required" json:"auth_request"`
}

func NewLoginArgs() *LoginArgs {
	return &LoginArgs{}
}

var LoginArgs_AuthRequest_DEFAULT *AuthenticationRequest

func (p *LoginArgs) GetAuthRequest() *AuthenticationRequest {
	if !p.IsSetAuthRequest() {
		return LoginArgs_AuthRequest_DEFAULT
	}
	return p.AuthRequest
}
func (p *LoginArgs) IsSetAuthRequest() bool {
	return p.AuthRequest != nil
}

func (p *LoginArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginArgs) ReadField1(iprot thrift.TProtocol) error {
	p.AuthRequest = &AuthenticationRequest{}
	if err := p.AuthRequest.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.AuthRequest, err)
	}
	return nil
}

func (p *LoginArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("auth_request", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:auth_request: %s", p, err)
	}
	if err := p.AuthRequest.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.AuthRequest, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:auth_request: %s", p, err)
	}
	return err
}

func (p *LoginArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginArgs(%+v)", *p)
}

type LoginResult struct {
	Authnx *AuthenticationException `thrift:"authnx,1" json:"authnx"`
	Authzx *AuthorizationException  `thrift:"authzx,2" json:"authzx"`
}

func NewLoginResult() *LoginResult {
	return &LoginResult{}
}

var LoginResult_Authnx_DEFAULT *AuthenticationException

func (p *LoginResult) GetAuthnx() *AuthenticationException {
	if !p.IsSetAuthnx() {
		return LoginResult_Authnx_DEFAULT
	}
	return p.Authnx
}

var LoginResult_Authzx_DEFAULT *AuthorizationException

func (p *LoginResult) GetAuthzx() *AuthorizationException {
	if !p.IsSetAuthzx() {
		return LoginResult_Authzx_DEFAULT
	}
	return p.Authzx
}
func (p *LoginResult) IsSetAuthnx() bool {
	return p.Authnx != nil
}

func (p *LoginResult) IsSetAuthzx() bool {
	return p.Authzx != nil
}

func (p *LoginResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginResult) ReadField1(iprot thrift.TProtocol) error {
	p.Authnx = &AuthenticationException{}
	if err := p.Authnx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authnx, err)
	}
	return nil
}

func (p *LoginResult) ReadField2(iprot thrift.TProtocol) error {
	p.Authzx = &AuthorizationException{}
	if err := p.Authzx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authzx, err)
	}
	return nil
}

func (p *LoginResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthnx() {
		if err := oprot.WriteFieldBegin("authnx", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:authnx: %s", p, err)
		}
		if err := p.Authnx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authnx, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:authnx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAuthzx() {
		if err := oprot.WriteFieldBegin("authzx", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:authzx: %s", p, err)
		}
		if err := p.Authzx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authzx, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:authzx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginResult(%+v)", *p)
}

type SetKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewSetKeyspaceArgs() *SetKeyspaceArgs {
	return &SetKeyspaceArgs{}
}

func (p *SetKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *SetKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SetKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SetKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceArgs(%+v)", *p)
}

type SetKeyspaceResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewSetKeyspaceResult() *SetKeyspaceResult {
	return &SetKeyspaceResult{}
}

var SetKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *SetKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SetKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *SetKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SetKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SetKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SetKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceResult(%+v)", *p)
}

type GetArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required" json:"column_path"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" json:"consistency_level"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetArgs) GetKey() []byte {
	return p.Key
}

var GetArgs_ColumnPath_DEFAULT *ColumnPath

func (p *GetArgs) GetColumnPath() *ColumnPath {
	if !p.IsSetColumnPath() {
		return GetArgs_ColumnPath_DEFAULT
	}
	return p.ColumnPath
}

func (p *GetArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetArgs) IsSetColumnPath() bool {
	return p.ColumnPath != nil
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnPath = &ColumnPath{}
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath, err)
	}
	return nil
}

func (p *GetArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
	}
	if err := p.ColumnPath.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnPath, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *ColumnOrSuperColumn     `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Nfe     *NotFoundException       `thrift:"nfe,2" json:"nfe"`
	Ue      *UnavailableException    `thrift:"ue,3" json:"ue"`
	Te      *TimedOutException       `thrift:"te,4" json:"te"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

var GetResult_Success_DEFAULT *ColumnOrSuperColumn

func (p *GetResult) GetSuccess() *ColumnOrSuperColumn {
	if !p.IsSetSuccess() {
		return GetResult_Success_DEFAULT
	}
	return p.Success
}

var GetResult_Ire_DEFAULT *InvalidRequestException

func (p *GetResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetResult_Nfe_DEFAULT *NotFoundException

func (p *GetResult) GetNfe() *NotFoundException {
	if !p.IsSetNfe() {
		return GetResult_Nfe_DEFAULT
	}
	return p.Nfe
}

var GetResult_Ue_DEFAULT *UnavailableException

func (p *GetResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetResult_Te_DEFAULT *TimedOutException

func (p *GetResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetResult) IsSetNfe() bool {
	return p.Nfe != nil
}

func (p *GetResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ColumnOrSuperColumn{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetResult) ReadField2(iprot thrift.TProtocol) error {
	p.Nfe = &NotFoundException{}
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe, err)
	}
	return nil
}

func (p *GetResult) ReadField3(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetResult) ReadField4(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetNfe() {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:nfe: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:te: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetSliceArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewGetSliceArgs() *GetSliceArgs {
	return &GetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetSliceArgs) GetKey() []byte {
	return p.Key
}

var GetSliceArgs_ColumnParent_DEFAULT *ColumnParent

func (p *GetSliceArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return GetSliceArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var GetSliceArgs_Predicate_DEFAULT *SlicePredicate

func (p *GetSliceArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return GetSliceArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *GetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetSliceArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *GetSliceArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *GetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetSliceArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetSliceArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetSliceArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *GetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *GetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
	}
	return err
}

func (p *GetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceArgs(%+v)", *p)
}

type GetSliceResult struct {
	Success []*ColumnOrSuperColumn   `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewGetSliceResult() *GetSliceResult {
	return &GetSliceResult{}
}

var GetSliceResult_Success_DEFAULT []*ColumnOrSuperColumn

func (p *GetSliceResult) GetSuccess() []*ColumnOrSuperColumn {
	return p.Success
}

var GetSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *GetSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetSliceResult_Ue_DEFAULT *UnavailableException

func (p *GetSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetSliceResult_Te_DEFAULT *TimedOutException

func (p *GetSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem123 := &ColumnOrSuperColumn{}
		if err := _elem123.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem123, err)
		}
		p.Success = append(p.Success, _elem123)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetSliceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetSliceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetSliceResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceResult(%+v)", *p)
}

type GetCountArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewGetCountArgs() *GetCountArgs {
	return &GetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetCountArgs) GetKey() []byte {
	return p.Key
}

var GetCountArgs_ColumnParent_DEFAULT *ColumnParent

func (p *GetCountArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return GetCountArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var GetCountArgs_Predicate_DEFAULT *SlicePredicate

func (p *GetCountArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return GetCountArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *GetCountArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetCountArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *GetCountArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *GetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetCountArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetCountArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetCountArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *GetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *GetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
	}
	return err
}

func (p *GetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountArgs(%+v)", *p)
}

type GetCountResult struct {
	Success *int32                   `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewGetCountResult() *GetCountResult {
	return &GetCountResult{}
}

var GetCountResult_Success_DEFAULT int32

func (p *GetCountResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return GetCountResult_Success_DEFAULT
	}
	return *p.Success
}

var GetCountResult_Ire_DEFAULT *InvalidRequestException

func (p *GetCountResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetCountResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetCountResult_Ue_DEFAULT *UnavailableException

func (p *GetCountResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetCountResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetCountResult_Te_DEFAULT *TimedOutException

func (p *GetCountResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetCountResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetCountResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetCountResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetCountResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetCountResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetCountResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetCountResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountResult(%+v)", *p)
}

type MultigetSliceArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewMultigetSliceArgs() *MultigetSliceArgs {
	return &MultigetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *MultigetSliceArgs) GetKeys() [][]byte {
	return p.Keys
}

var MultigetSliceArgs_ColumnParent_DEFAULT *ColumnParent

func (p *MultigetSliceArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return MultigetSliceArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var MultigetSliceArgs_Predicate_DEFAULT *SlicePredicate

func (p *MultigetSliceArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return MultigetSliceArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *MultigetSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *MultigetSliceArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *MultigetSliceArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *MultigetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem124 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem124 = v
		}
		p.Keys = append(p.Keys, _elem124)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MultigetSliceArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *MultigetSliceArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *MultigetSliceArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *MultigetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Keys {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
	}
	return err
}

func (p *MultigetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *MultigetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
	}
	return err
}

func (p *MultigetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *MultigetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceArgs(%+v)", *p)
}

type MultigetSliceResult struct {
	Success map[string][]*ColumnOrSuperColumn `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException          `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException             `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException                `thrift:"te,3" json:"te"`
}

func NewMultigetSliceResult() *MultigetSliceResult {
	return &MultigetSliceResult{}
}

var MultigetSliceResult_Success_DEFAULT map[string][]*ColumnOrSuperColumn

func (p *MultigetSliceResult) GetSuccess() map[string][]*ColumnOrSuperColumn {
	return p.Success
}

var MultigetSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *MultigetSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return MultigetSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var MultigetSliceResult_Ue_DEFAULT *UnavailableException

func (p *MultigetSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return MultigetSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var MultigetSliceResult_Te_DEFAULT *TimedOutException

func (p *MultigetSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return MultigetSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *MultigetSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MultigetSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *MultigetSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *MultigetSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *MultigetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][]*ColumnOrSuperColumn, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key125 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key125 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([]*ColumnOrSuperColumn, 0, size)
		_val126 := tSlice
		for i := 0; i < size; i++ {
			_elem127 := &ColumnOrSuperColumn{}
			if err := _elem127.Read(iprot); err != nil {
				return fmt.Errorf("%T error reading struct: %s", _elem127, err)
			}
			_val126 = append(_val126, _elem127)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Success[_key125] = _val126
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MultigetSliceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *MultigetSliceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *MultigetSliceResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *MultigetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceResult(%+v)", *p)
}

type MultigetCountArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewMultigetCountArgs() *MultigetCountArgs {
	return &MultigetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *MultigetCountArgs) GetKeys() [][]byte {
	return p.Keys
}

var MultigetCountArgs_ColumnParent_DEFAULT *ColumnParent

func (p *MultigetCountArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return MultigetCountArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var MultigetCountArgs_Predicate_DEFAULT *SlicePredicate

func (p *MultigetCountArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return MultigetCountArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

func (p *MultigetCountArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *MultigetCountArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *MultigetCountArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *MultigetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Keys = tSlice
	for i := 0; i < size; i++ {
		var _elem128 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem128 = v
		}
		p.Keys = append(p.Keys, _elem128)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MultigetCountArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *MultigetCountArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *MultigetCountArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *MultigetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Keys {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
	}
	return err
}

func (p *MultigetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *MultigetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
	}
	return err
}

func (p *MultigetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *MultigetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountArgs(%+v)", *p)
}

type MultigetCountResult struct {
	Success map[string]int32         `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewMultigetCountResult() *MultigetCountResult {
	return &MultigetCountResult{}
}

var MultigetCountResult_Success_DEFAULT map[string]int32

func (p *MultigetCountResult) GetSuccess() map[string]int32 {
	return p.Success
}

var MultigetCountResult_Ire_DEFAULT *InvalidRequestException

func (p *MultigetCountResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return MultigetCountResult_Ire_DEFAULT
	}
	return p.Ire
}

var MultigetCountResult_Ue_DEFAULT *UnavailableException

func (p *MultigetCountResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return MultigetCountResult_Ue_DEFAULT
	}
	return p.Ue
}

var MultigetCountResult_Te_DEFAULT *TimedOutException

func (p *MultigetCountResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return MultigetCountResult_Te_DEFAULT
	}
	return p.Te
}
func (p *MultigetCountResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *MultigetCountResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *MultigetCountResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *MultigetCountResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *MultigetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]int32, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key129 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key129 = v
		}
		var _val130 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val130 = v
		}
		p.Success[_key129] = _val130
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MultigetCountResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *MultigetCountResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *MultigetCountResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *MultigetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountResult(%+v)", *p)
}

type GetRangeSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"predicate,2,required" json:"predicate"`
	RangeA1          *KeyRange        `thrift:"range,3,required" json:"range"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewGetRangeSlicesArgs() *GetRangeSlicesArgs {
	return &GetRangeSlicesArgs{
		ConsistencyLevel: 1,
	}
}

var GetRangeSlicesArgs_ColumnParent_DEFAULT *ColumnParent

func (p *GetRangeSlicesArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return GetRangeSlicesArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var GetRangeSlicesArgs_Predicate_DEFAULT *SlicePredicate

func (p *GetRangeSlicesArgs) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return GetRangeSlicesArgs_Predicate_DEFAULT
	}
	return p.Predicate
}

var GetRangeSlicesArgs_RangeA1_DEFAULT *KeyRange

func (p *GetRangeSlicesArgs) GetRangeA1() *KeyRange {
	if !p.IsSetRangeA1() {
		return GetRangeSlicesArgs_RangeA1_DEFAULT
	}
	return p.RangeA1
}

func (p *GetRangeSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetRangeSlicesArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *GetRangeSlicesArgs) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *GetRangeSlicesArgs) IsSetRangeA1() bool {
	return p.RangeA1 != nil
}

func (p *GetRangeSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) ReadField1(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) ReadField3(iprot thrift.TProtocol) error {
	p.RangeA1 = &KeyRange{
		Count: 100,
	}
	if err := p.RangeA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RangeA1, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetRangeSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:predicate: %s", p, err)
	}
	if err := p.Predicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:predicate: %s", p, err)
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:range: %s", p, err)
	}
	if err := p.RangeA1.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.RangeA1, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:range: %s", p, err)
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetRangeSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesArgs(%+v)", *p)
}

type GetRangeSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewGetRangeSlicesResult() *GetRangeSlicesResult {
	return &GetRangeSlicesResult{}
}

var GetRangeSlicesResult_Success_DEFAULT []*KeySlice

func (p *GetRangeSlicesResult) GetSuccess() []*KeySlice {
	return p.Success
}

var GetRangeSlicesResult_Ire_DEFAULT *InvalidRequestException

func (p *GetRangeSlicesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetRangeSlicesResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetRangeSlicesResult_Ue_DEFAULT *UnavailableException

func (p *GetRangeSlicesResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetRangeSlicesResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetRangeSlicesResult_Te_DEFAULT *TimedOutException

func (p *GetRangeSlicesResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetRangeSlicesResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetRangeSlicesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRangeSlicesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetRangeSlicesResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetRangeSlicesResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetRangeSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem131 := &KeySlice{}
		if err := _elem131.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem131, err)
		}
		p.Success = append(p.Success, _elem131)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesResult(%+v)", *p)
}

type GetPagedSliceArgs struct {
	ColumnFamily     string           `thrift:"column_family,1,required" json:"column_family"`
	RangeA1          *KeyRange        `thrift:"range,2,required" json:"range"`
	StartColumn      []byte           `thrift:"start_column,3,required" json:"start_column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewGetPagedSliceArgs() *GetPagedSliceArgs {
	return &GetPagedSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetPagedSliceArgs) GetColumnFamily() string {
	return p.ColumnFamily
}

var GetPagedSliceArgs_RangeA1_DEFAULT *KeyRange

func (p *GetPagedSliceArgs) GetRangeA1() *KeyRange {
	if !p.IsSetRangeA1() {
		return GetPagedSliceArgs_RangeA1_DEFAULT
	}
	return p.RangeA1
}

func (p *GetPagedSliceArgs) GetStartColumn() []byte {
	return p.StartColumn
}

func (p *GetPagedSliceArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetPagedSliceArgs) IsSetRangeA1() bool {
	return p.RangeA1 != nil
}

func (p *GetPagedSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPagedSliceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *GetPagedSliceArgs) ReadField2(iprot thrift.TProtocol) error {
	p.RangeA1 = &KeyRange{
		Count: 100,
	}
	if err := p.RangeA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RangeA1, err)
	}
	return nil
}

func (p *GetPagedSliceArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.StartColumn = v
	}
	return nil
}

func (p *GetPagedSliceArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetPagedSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPagedSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_family: %s", p, err)
	}
	return err
}

func (p *GetPagedSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:range: %s", p, err)
	}
	if err := p.RangeA1.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.RangeA1, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:range: %s", p, err)
	}
	return err
}

func (p *GetPagedSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:start_column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartColumn); err != nil {
		return fmt.Errorf("%T.start_column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:start_column: %s", p, err)
	}
	return err
}

func (p *GetPagedSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetPagedSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPagedSliceArgs(%+v)", *p)
}

type GetPagedSliceResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewGetPagedSliceResult() *GetPagedSliceResult {
	return &GetPagedSliceResult{}
}

var GetPagedSliceResult_Success_DEFAULT []*KeySlice

func (p *GetPagedSliceResult) GetSuccess() []*KeySlice {
	return p.Success
}

var GetPagedSliceResult_Ire_DEFAULT *InvalidRequestException

func (p *GetPagedSliceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetPagedSliceResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetPagedSliceResult_Ue_DEFAULT *UnavailableException

func (p *GetPagedSliceResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetPagedSliceResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetPagedSliceResult_Te_DEFAULT *TimedOutException

func (p *GetPagedSliceResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetPagedSliceResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetPagedSliceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetPagedSliceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetPagedSliceResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetPagedSliceResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetPagedSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPagedSliceResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem132 := &KeySlice{}
		if err := _elem132.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem132, err)
		}
		p.Success = append(p.Success, _elem132)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetPagedSliceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetPagedSliceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetPagedSliceResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetPagedSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPagedSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPagedSliceResult(%+v)", *p)
}

type GetIndexedSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required" json:"column_parent"`
	IndexClause      *IndexClause     `thrift:"index_clause,2,required" json:"index_clause"`
	ColumnPredicate  *SlicePredicate  `thrift:"column_predicate,3,required" json:"column_predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewGetIndexedSlicesArgs() *GetIndexedSlicesArgs {
	return &GetIndexedSlicesArgs{
		ConsistencyLevel: 1,
	}
}

var GetIndexedSlicesArgs_ColumnParent_DEFAULT *ColumnParent

func (p *GetIndexedSlicesArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return GetIndexedSlicesArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var GetIndexedSlicesArgs_IndexClause_DEFAULT *IndexClause

func (p *GetIndexedSlicesArgs) GetIndexClause() *IndexClause {
	if !p.IsSetIndexClause() {
		return GetIndexedSlicesArgs_IndexClause_DEFAULT
	}
	return p.IndexClause
}

var GetIndexedSlicesArgs_ColumnPredicate_DEFAULT *SlicePredicate

func (p *GetIndexedSlicesArgs) GetColumnPredicate() *SlicePredicate {
	if !p.IsSetColumnPredicate() {
		return GetIndexedSlicesArgs_ColumnPredicate_DEFAULT
	}
	return p.ColumnPredicate
}

func (p *GetIndexedSlicesArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *GetIndexedSlicesArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *GetIndexedSlicesArgs) IsSetIndexClause() bool {
	return p.IndexClause != nil
}

func (p *GetIndexedSlicesArgs) IsSetColumnPredicate() bool {
	return p.ColumnPredicate != nil
}

func (p *GetIndexedSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) ReadField1(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) ReadField2(iprot thrift.TProtocol) error {
	p.IndexClause = &IndexClause{
		Count: 100,
	}
	if err := p.IndexClause.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.IndexClause, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) ReadField3(iprot thrift.TProtocol) error {
	p.ColumnPredicate = &SlicePredicate{}
	if err := p.ColumnPredicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPredicate, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *GetIndexedSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("index_clause", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:index_clause: %s", p, err)
	}
	if err := p.IndexClause.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.IndexClause, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:index_clause: %s", p, err)
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_predicate", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_predicate: %s", p, err)
	}
	if err := p.ColumnPredicate.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnPredicate, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_predicate: %s", p, err)
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *GetIndexedSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesArgs(%+v)", *p)
}

type GetIndexedSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewGetIndexedSlicesResult() *GetIndexedSlicesResult {
	return &GetIndexedSlicesResult{}
}

var GetIndexedSlicesResult_Success_DEFAULT []*KeySlice

func (p *GetIndexedSlicesResult) GetSuccess() []*KeySlice {
	return p.Success
}

var GetIndexedSlicesResult_Ire_DEFAULT *InvalidRequestException

func (p *GetIndexedSlicesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return GetIndexedSlicesResult_Ire_DEFAULT
	}
	return p.Ire
}

var GetIndexedSlicesResult_Ue_DEFAULT *UnavailableException

func (p *GetIndexedSlicesResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return GetIndexedSlicesResult_Ue_DEFAULT
	}
	return p.Ue
}

var GetIndexedSlicesResult_Te_DEFAULT *TimedOutException

func (p *GetIndexedSlicesResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return GetIndexedSlicesResult_Te_DEFAULT
	}
	return p.Te
}
func (p *GetIndexedSlicesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetIndexedSlicesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *GetIndexedSlicesResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *GetIndexedSlicesResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *GetIndexedSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*KeySlice, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem133 := &KeySlice{}
		if err := _elem133.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem133, err)
		}
		p.Success = append(p.Success, _elem133)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesResult(%+v)", *p)
}

type InsertArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Column           *Column          `thrift:"column,3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewInsertArgs() *InsertArgs {
	return &InsertArgs{
		ConsistencyLevel: 1,
	}
}

func (p *InsertArgs) GetKey() []byte {
	return p.Key
}

var InsertArgs_ColumnParent_DEFAULT *ColumnParent

func (p *InsertArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return InsertArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var InsertArgs_Column_DEFAULT *Column

func (p *InsertArgs) GetColumn() *Column {
	if !p.IsSetColumn() {
		return InsertArgs_Column_DEFAULT
	}
	return p.Column
}

func (p *InsertArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *InsertArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *InsertArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *InsertArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *InsertArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *InsertArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Column = &Column{}
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *InsertArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *InsertArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *InsertArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *InsertArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Column, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *InsertArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *InsertArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertArgs(%+v)", *p)
}

type InsertResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewInsertResult() *InsertResult {
	return &InsertResult{}
}

var InsertResult_Ire_DEFAULT *InvalidRequestException

func (p *InsertResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return InsertResult_Ire_DEFAULT
	}
	return p.Ire
}

var InsertResult_Ue_DEFAULT *UnavailableException

func (p *InsertResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return InsertResult_Ue_DEFAULT
	}
	return p.Ue
}

var InsertResult_Te_DEFAULT *TimedOutException

func (p *InsertResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return InsertResult_Te_DEFAULT
	}
	return p.Te
}
func (p *InsertResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *InsertResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *InsertResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *InsertResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *InsertResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *InsertResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *InsertResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertResult(%+v)", *p)
}

type AddArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required" json:"column_parent"`
	Column           *CounterColumn   `thrift:"column,3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required" json:"consistency_level"`
}

func NewAddArgs() *AddArgs {
	return &AddArgs{
		ConsistencyLevel: 1,
	}
}

func (p *AddArgs) GetKey() []byte {
	return p.Key
}

var AddArgs_ColumnParent_DEFAULT *ColumnParent

func (p *AddArgs) GetColumnParent() *ColumnParent {
	if !p.IsSetColumnParent() {
		return AddArgs_ColumnParent_DEFAULT
	}
	return p.ColumnParent
}

var AddArgs_Column_DEFAULT *CounterColumn

func (p *AddArgs) GetColumn() *CounterColumn {
	if !p.IsSetColumn() {
		return AddArgs_Column_DEFAULT
	}
	return p.Column
}

func (p *AddArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *AddArgs) IsSetColumnParent() bool {
	return p.ColumnParent != nil
}

func (p *AddArgs) IsSetColumn() bool {
	return p.Column != nil
}

func (p *AddArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *AddArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnParent = &ColumnParent{}
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent, err)
	}
	return nil
}

func (p *AddArgs) ReadField3(iprot thrift.TProtocol) error {
	p.Column = &CounterColumn{}
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *AddArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *AddArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *AddArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
	}
	if err := p.ColumnParent.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnParent, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
	}
	return err
}

func (p *AddArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := p.Column.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Column, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *AddArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *AddArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddArgs(%+v)", *p)
}

type AddResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewAddResult() *AddResult {
	return &AddResult{}
}

var AddResult_Ire_DEFAULT *InvalidRequestException

func (p *AddResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return AddResult_Ire_DEFAULT
	}
	return p.Ire
}

var AddResult_Ue_DEFAULT *UnavailableException

func (p *AddResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return AddResult_Ue_DEFAULT
	}
	return p.Ue
}

var AddResult_Te_DEFAULT *TimedOutException

func (p *AddResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return AddResult_Te_DEFAULT
	}
	return p.Te
}
func (p *AddResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *AddResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *AddResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *AddResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *AddResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *AddResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *AddResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AddResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddResult(%+v)", *p)
}

type CasArgs struct {
	Key                    []byte           `thrift:"key,1,required" json:"key"`
	ColumnFamily           string           `thrift:"column_family,2,required" json:"column_family"`
	Expected               []*Column        `thrift:"expected,3" json:"expected"`
	Updates                []*Column        `thrift:"updates,4" json:"updates"`
	SerialConsistencyLevel ConsistencyLevel `thrift:"serial_consistency_level,5,required" json:"serial_consistency_level"`
	CommitConsistencyLevel ConsistencyLevel `thrift:"commit_consistency_level,6,required" json:"commit_consistency_level"`
}

func NewCasArgs() *CasArgs {
	return &CasArgs{
		SerialConsistencyLevel: 9,

		CommitConsistencyLevel: 2,
	}
}

func (p *CasArgs) GetKey() []byte {
	return p.Key
}

func (p *CasArgs) GetColumnFamily() string {
	return p.ColumnFamily
}

func (p *CasArgs) GetExpected() []*Column {
	return p.Expected
}

func (p *CasArgs) GetUpdates() []*Column {
	return p.Updates
}

func (p *CasArgs) GetSerialConsistencyLevel() ConsistencyLevel {
	return p.SerialConsistencyLevel
}

func (p *CasArgs) GetCommitConsistencyLevel() ConsistencyLevel {
	return p.CommitConsistencyLevel
}
func (p *CasArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CasArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CasArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *CasArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Expected = tSlice
	for i := 0; i < size; i++ {
		_elem134 := &Column{}
		if err := _elem134.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem134, err)
		}
		p.Expected = append(p.Expected, _elem134)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CasArgs) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Updates = tSlice
	for i := 0; i < size; i++ {
		_elem135 := &Column{}
		if err := _elem135.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem135, err)
		}
		p.Updates = append(p.Updates, _elem135)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CasArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.SerialConsistencyLevel = temp
	}
	return nil
}

func (p *CasArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.CommitConsistencyLevel = temp
	}
	return nil
}

func (p *CasArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cas_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CasArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *CasArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_family: %s", p, err)
	}
	return err
}

func (p *CasArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("expected", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:expected: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expected)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Expected {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:expected: %s", p, err)
	}
	return err
}

func (p *CasArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("updates", thrift.LIST, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:updates: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Updates)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Updates {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:updates: %s", p, err)
	}
	return err
}

func (p *CasArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("serial_consistency_level", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:serial_consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.SerialConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.serial_consistency_level (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:serial_consistency_level: %s", p, err)
	}
	return err
}

func (p *CasArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("commit_consistency_level", thrift.I32, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:commit_consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.CommitConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.commit_consistency_level (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:commit_consistency_level: %s", p, err)
	}
	return err
}

func (p *CasArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CasArgs(%+v)", *p)
}

type CasResult struct {
	Success *CASResult_              `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewCasResult() *CasResult {
	return &CasResult{}
}

var CasResult_Success_DEFAULT *CASResult_

func (p *CasResult) GetSuccess() *CASResult_ {
	if !p.IsSetSuccess() {
		return CasResult_Success_DEFAULT
	}
	return p.Success
}

var CasResult_Ire_DEFAULT *InvalidRequestException

func (p *CasResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return CasResult_Ire_DEFAULT
	}
	return p.Ire
}

var CasResult_Ue_DEFAULT *UnavailableException

func (p *CasResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return CasResult_Ue_DEFAULT
	}
	return p.Ue
}

var CasResult_Te_DEFAULT *TimedOutException

func (p *CasResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return CasResult_Te_DEFAULT
	}
	return p.Te
}
func (p *CasResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CasResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *CasResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *CasResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *CasResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CasResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CASResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *CasResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *CasResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *CasResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *CasResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("cas_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CasResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CasResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *CasResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *CasResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *CasResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CasResult(%+v)", *p)
}

type RemoveArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required" json:"column_path"`
	Timestamp        int64            `thrift:"timestamp,3,required" json:"timestamp"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4" json:"consistency_level"`
}

func NewRemoveArgs() *RemoveArgs {
	return &RemoveArgs{
		ConsistencyLevel: 1,
	}
}

func (p *RemoveArgs) GetKey() []byte {
	return p.Key
}

var RemoveArgs_ColumnPath_DEFAULT *ColumnPath

func (p *RemoveArgs) GetColumnPath() *ColumnPath {
	if !p.IsSetColumnPath() {
		return RemoveArgs_ColumnPath_DEFAULT
	}
	return p.ColumnPath
}

func (p *RemoveArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *RemoveArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *RemoveArgs) IsSetColumnPath() bool {
	return p.ColumnPath != nil
}

func (p *RemoveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveArgs) ReadField2(iprot thrift.TProtocol) error {
	p.ColumnPath = &ColumnPath{}
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath, err)
	}
	return nil
}

func (p *RemoveArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *RemoveArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *RemoveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
	}
	if err := p.ColumnPath.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.ColumnPath, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveArgs(%+v)", *p)
}

type RemoveResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewRemoveResult() *RemoveResult {
	return &RemoveResult{}
}

var RemoveResult_Ire_DEFAULT *InvalidRequestException

func (p *RemoveResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return RemoveResult_Ire_DEFAULT
	}
	return p.Ire
}

var RemoveResult_Ue_DEFAULT *UnavailableException

func (p *RemoveResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return RemoveResult_Ue_DEFAULT
	}
	return p.Ue
}

var RemoveResult_Te_DEFAULT *TimedOutException

func (p *RemoveResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return RemoveResult_Te_DEFAULT
	}
	return p.Te
}
func (p *RemoveResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *RemoveResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *RemoveResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *RemoveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *RemoveResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *RemoveResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *RemoveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveResult(%+v)", *p)
}

type RemoveCounterArgs struct {
	Key              []byte           `thrift:"key,1,required" json:"key"`
	Path             *ColumnPath      `thrift:"path,2,required" json:"path"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required" json:"consistency_level"`
}

func NewRemoveCounterArgs() *RemoveCounterArgs {
	return &RemoveCounterArgs{
		ConsistencyLevel: 1,
	}
}

func (p *RemoveCounterArgs) GetKey() []byte {
	return p.Key
}

var RemoveCounterArgs_Path_DEFAULT *ColumnPath

func (p *RemoveCounterArgs) GetPath() *ColumnPath {
	if !p.IsSetPath() {
		return RemoveCounterArgs_Path_DEFAULT
	}
	return p.Path
}

func (p *RemoveCounterArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *RemoveCounterArgs) IsSetPath() bool {
	return p.Path != nil
}

func (p *RemoveCounterArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveCounterArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Path = &ColumnPath{}
	if err := p.Path.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Path, err)
	}
	return nil
}

func (p *RemoveCounterArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *RemoveCounterArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return fmt.Errorf("%T.key (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:key: %s", p, err)
	}
	return err
}

func (p *RemoveCounterArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("path", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:path: %s", p, err)
	}
	if err := p.Path.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Path, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:path: %s", p, err)
	}
	return err
}

func (p *RemoveCounterArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
	}
	return err
}

func (p *RemoveCounterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterArgs(%+v)", *p)
}

type RemoveCounterResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewRemoveCounterResult() *RemoveCounterResult {
	return &RemoveCounterResult{}
}

var RemoveCounterResult_Ire_DEFAULT *InvalidRequestException

func (p *RemoveCounterResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return RemoveCounterResult_Ire_DEFAULT
	}
	return p.Ire
}

var RemoveCounterResult_Ue_DEFAULT *UnavailableException

func (p *RemoveCounterResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return RemoveCounterResult_Ue_DEFAULT
	}
	return p.Ue
}

var RemoveCounterResult_Te_DEFAULT *TimedOutException

func (p *RemoveCounterResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return RemoveCounterResult_Te_DEFAULT
	}
	return p.Te
}
func (p *RemoveCounterResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *RemoveCounterResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *RemoveCounterResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *RemoveCounterResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *RemoveCounterResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *RemoveCounterResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *RemoveCounterResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterResult(%+v)", *p)
}

type BatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required" json:"consistency_level"`
}

func NewBatchMutateArgs() *BatchMutateArgs {
	return &BatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *BatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
	return p.MutationMap
}

func (p *BatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *BatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateArgs) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]map[string][]*Mutation, size)
	p.MutationMap = tMap
	for i := 0; i < size; i++ {
		var _key136 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key136 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s", err)
		}
		tMap := make(map[string][]*Mutation, size)
		_val137 := tMap
		for i := 0; i < size; i++ {
			var _key138 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_key138 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return fmt.Errorf("error reading list begin: %s", err)
			}
			tSlice := make([]*Mutation, 0, size)
			_val139 := tSlice
			for i := 0; i < size; i++ {
				_elem140 := &Mutation{}
				if err := _elem140.Read(iprot); err != nil {
					return fmt.Errorf("%T error reading struct: %s", _elem140, err)
				}
				_val139 = append(_val139, _elem140)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return fmt.Errorf("error reading list end: %s", err)
			}
			_val137[_key138] = _val139
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s", err)
		}
		p.MutationMap[_key136] = _val137
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *BatchMutateArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *BatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutation_map: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.MutationMap {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range v {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutation_map: %s", p, err)
	}
	return err
}

func (p *BatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:consistency_level: %s", p, err)
	}
	return err
}

func (p *BatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateArgs(%+v)", *p)
}

type BatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewBatchMutateResult() *BatchMutateResult {
	return &BatchMutateResult{}
}

var BatchMutateResult_Ire_DEFAULT *InvalidRequestException

func (p *BatchMutateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return BatchMutateResult_Ire_DEFAULT
	}
	return p.Ire
}

var BatchMutateResult_Ue_DEFAULT *UnavailableException

func (p *BatchMutateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return BatchMutateResult_Ue_DEFAULT
	}
	return p.Ue
}

var BatchMutateResult_Te_DEFAULT *TimedOutException

func (p *BatchMutateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return BatchMutateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *BatchMutateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *BatchMutateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *BatchMutateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *BatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *BatchMutateResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *BatchMutateResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *BatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateResult(%+v)", *p)
}

type AtomicBatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required" json:"consistency_level"`
}

func NewAtomicBatchMutateArgs() *AtomicBatchMutateArgs {
	return &AtomicBatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *AtomicBatchMutateArgs) GetMutationMap() map[string]map[string][]*Mutation {
	return p.MutationMap
}

func (p *AtomicBatchMutateArgs) GetConsistencyLevel() ConsistencyLevel {
	return p.ConsistencyLevel
}
func (p *AtomicBatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]map[string][]*Mutation, size)
	p.MutationMap = tMap
	for i := 0; i < size; i++ {
		var _key141 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key141 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s", err)
		}
		tMap := make(map[string][]*Mutation, size)
		_val142 := tMap
		for i := 0; i < size; i++ {
			var _key143 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_key143 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return fmt.Errorf("error reading list begin: %s", err)
			}
			tSlice := make([]*Mutation, 0, size)
			_val144 := tSlice
			for i := 0; i < size; i++ {
				_elem145 := &Mutation{}
				if err := _elem145.Read(iprot); err != nil {
					return fmt.Errorf("%T error reading struct: %s", _elem145, err)
				}
				_val144 = append(_val144, _elem145)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return fmt.Errorf("error reading list end: %s", err)
			}
			_val142[_key143] = _val144
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s", err)
		}
		p.MutationMap[_key141] = _val142
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.ConsistencyLevel = temp
	}
	return nil
}

func (p *AtomicBatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:mutation_map: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.MutationMap {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range v {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:mutation_map: %s", p, err)
	}
	return err
}

func (p *AtomicBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:consistency_level: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
		return fmt.Errorf("%T.consistency_level (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:consistency_level: %s", p, err)
	}
	return err
}

func (p *AtomicBatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicBatchMutateArgs(%+v)", *p)
}

type AtomicBatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewAtomicBatchMutateResult() *AtomicBatchMutateResult {
	return &AtomicBatchMutateResult{}
}

var AtomicBatchMutateResult_Ire_DEFAULT *InvalidRequestException

func (p *AtomicBatchMutateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return AtomicBatchMutateResult_Ire_DEFAULT
	}
	return p.Ire
}

var AtomicBatchMutateResult_Ue_DEFAULT *UnavailableException

func (p *AtomicBatchMutateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return AtomicBatchMutateResult_Ue_DEFAULT
	}
	return p.Ue
}

var AtomicBatchMutateResult_Te_DEFAULT *TimedOutException

func (p *AtomicBatchMutateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return AtomicBatchMutateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *AtomicBatchMutateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *AtomicBatchMutateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *AtomicBatchMutateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *AtomicBatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicBatchMutateResult(%+v)", *p)
}

type TruncateArgs struct {
	Cfname string `thrift:"cfname,1,required" json:"cfname"`
}

func NewTruncateArgs() *TruncateArgs {
	return &TruncateArgs{}
}

func (p *TruncateArgs) GetCfname() string {
	return p.Cfname
}
func (p *TruncateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Cfname = v
	}
	return nil
}

func (p *TruncateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfname", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfname: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Cfname)); err != nil {
		return fmt.Errorf("%T.cfname (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfname: %s", p, err)
	}
	return err
}

func (p *TruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateArgs(%+v)", *p)
}

type TruncateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
	Ue  *UnavailableException    `thrift:"ue,2" json:"ue"`
	Te  *TimedOutException       `thrift:"te,3" json:"te"`
}

func NewTruncateResult() *TruncateResult {
	return &TruncateResult{}
}

var TruncateResult_Ire_DEFAULT *InvalidRequestException

func (p *TruncateResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return TruncateResult_Ire_DEFAULT
	}
	return p.Ire
}

var TruncateResult_Ue_DEFAULT *UnavailableException

func (p *TruncateResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return TruncateResult_Ue_DEFAULT
	}
	return p.Ue
}

var TruncateResult_Te_DEFAULT *TimedOutException

func (p *TruncateResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return TruncateResult_Te_DEFAULT
	}
	return p.Te
}
func (p *TruncateResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *TruncateResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *TruncateResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *TruncateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *TruncateResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *TruncateResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *TruncateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateResult(%+v)", *p)
}

type DescribeSchemaVersionsArgs struct {
}

func NewDescribeSchemaVersionsArgs() *DescribeSchemaVersionsArgs {
	return &DescribeSchemaVersionsArgs{}
}

func (p *DescribeSchemaVersionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsArgs(%+v)", *p)
}

type DescribeSchemaVersionsResult struct {
	Success map[string][]string      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeSchemaVersionsResult() *DescribeSchemaVersionsResult {
	return &DescribeSchemaVersionsResult{}
}

var DescribeSchemaVersionsResult_Success_DEFAULT map[string][]string

func (p *DescribeSchemaVersionsResult) GetSuccess() map[string][]string {
	return p.Success
}

var DescribeSchemaVersionsResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeSchemaVersionsResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeSchemaVersionsResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeSchemaVersionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeSchemaVersionsResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeSchemaVersionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key146 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key146 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([]string, 0, size)
		_val147 := tSlice
		for i := 0; i < size; i++ {
			var _elem148 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem148 = v
			}
			_val147 = append(_val147, _elem148)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Success[_key146] = _val147
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsResult(%+v)", *p)
}

type DescribeKeyspacesArgs struct {
}

func NewDescribeKeyspacesArgs() *DescribeKeyspacesArgs {
	return &DescribeKeyspacesArgs{}
}

func (p *DescribeKeyspacesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesArgs(%+v)", *p)
}

type DescribeKeyspacesResult struct {
	Success []*KsDef                 `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeKeyspacesResult() *DescribeKeyspacesResult {
	return &DescribeKeyspacesResult{}
}

var DescribeKeyspacesResult_Success_DEFAULT []*KsDef

func (p *DescribeKeyspacesResult) GetSuccess() []*KsDef {
	return p.Success
}

var DescribeKeyspacesResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeKeyspacesResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeKeyspacesResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeKeyspacesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeKeyspacesResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeKeyspacesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*KsDef, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem149 := &KsDef{
			DurableWrites: true,
		}
		if err := _elem149.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem149, err)
		}
		p.Success = append(p.Success, _elem149)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesResult(%+v)", *p)
}

type DescribeClusterNameArgs struct {
}

func NewDescribeClusterNameArgs() *DescribeClusterNameArgs {
	return &DescribeClusterNameArgs{}
}

func (p *DescribeClusterNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameArgs(%+v)", *p)
}

type DescribeClusterNameResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewDescribeClusterNameResult() *DescribeClusterNameResult {
	return &DescribeClusterNameResult{}
}

var DescribeClusterNameResult_Success_DEFAULT string

func (p *DescribeClusterNameResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return DescribeClusterNameResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *DescribeClusterNameResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeClusterNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *DescribeClusterNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeClusterNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameResult(%+v)", *p)
}

type DescribeVersionArgs struct {
}

func NewDescribeVersionArgs() *DescribeVersionArgs {
	return &DescribeVersionArgs{}
}

func (p *DescribeVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionArgs(%+v)", *p)
}

type DescribeVersionResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewDescribeVersionResult() *DescribeVersionResult {
	return &DescribeVersionResult{}
}

var DescribeVersionResult_Success_DEFAULT string

func (p *DescribeVersionResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return DescribeVersionResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *DescribeVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *DescribeVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionResult(%+v)", *p)
}

type DescribeRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewDescribeRingArgs() *DescribeRingArgs {
	return &DescribeRingArgs{}
}

func (p *DescribeRingArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *DescribeRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingArgs(%+v)", *p)
}

type DescribeRingResult struct {
	Success []*TokenRange            `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeRingResult() *DescribeRingResult {
	return &DescribeRingResult{}
}

var DescribeRingResult_Success_DEFAULT []*TokenRange

func (p *DescribeRingResult) GetSuccess() []*TokenRange {
	return p.Success
}

var DescribeRingResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeRingResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeRingResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeRingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeRingResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TokenRange, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem150 := &TokenRange{}
		if err := _elem150.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem150, err)
		}
		p.Success = append(p.Success, _elem150)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DescribeRingResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingResult(%+v)", *p)
}

type DescribeLocalRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewDescribeLocalRingArgs() *DescribeLocalRingArgs {
	return &DescribeLocalRingArgs{}
}

func (p *DescribeLocalRingArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *DescribeLocalRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeLocalRingArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeLocalRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_local_ring_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeLocalRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeLocalRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeLocalRingArgs(%+v)", *p)
}

type DescribeLocalRingResult struct {
	Success []*TokenRange            `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeLocalRingResult() *DescribeLocalRingResult {
	return &DescribeLocalRingResult{}
}

var DescribeLocalRingResult_Success_DEFAULT []*TokenRange

func (p *DescribeLocalRingResult) GetSuccess() []*TokenRange {
	return p.Success
}

var DescribeLocalRingResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeLocalRingResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeLocalRingResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeLocalRingResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeLocalRingResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeLocalRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeLocalRingResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TokenRange, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem151 := &TokenRange{}
		if err := _elem151.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem151, err)
		}
		p.Success = append(p.Success, _elem151)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DescribeLocalRingResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeLocalRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_local_ring_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeLocalRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeLocalRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeLocalRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeLocalRingResult(%+v)", *p)
}

type DescribeTokenMapArgs struct {
}

func NewDescribeTokenMapArgs() *DescribeTokenMapArgs {
	return &DescribeTokenMapArgs{}
}

func (p *DescribeTokenMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeTokenMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeTokenMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeTokenMapArgs(%+v)", *p)
}

type DescribeTokenMapResult struct {
	Success map[string]string        `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeTokenMapResult() *DescribeTokenMapResult {
	return &DescribeTokenMapResult{}
}

var DescribeTokenMapResult_Success_DEFAULT map[string]string

func (p *DescribeTokenMapResult) GetSuccess() map[string]string {
	return p.Success
}

var DescribeTokenMapResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeTokenMapResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeTokenMapResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeTokenMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeTokenMapResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeTokenMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeTokenMapResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key152 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key152 = v
		}
		var _val153 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val153 = v
		}
		p.Success[_key152] = _val153
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DescribeTokenMapResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeTokenMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeTokenMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeTokenMapResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeTokenMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeTokenMapResult(%+v)", *p)
}

type DescribePartitionerArgs struct {
}

func NewDescribePartitionerArgs() *DescribePartitionerArgs {
	return &DescribePartitionerArgs{}
}

func (p *DescribePartitionerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerArgs(%+v)", *p)
}

type DescribePartitionerResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewDescribePartitionerResult() *DescribePartitionerResult {
	return &DescribePartitionerResult{}
}

var DescribePartitionerResult_Success_DEFAULT string

func (p *DescribePartitionerResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return DescribePartitionerResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *DescribePartitionerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribePartitionerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *DescribePartitionerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribePartitionerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerResult(%+v)", *p)
}

type DescribeSnitchArgs struct {
}

func NewDescribeSnitchArgs() *DescribeSnitchArgs {
	return &DescribeSnitchArgs{}
}

func (p *DescribeSnitchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchArgs(%+v)", *p)
}

type DescribeSnitchResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewDescribeSnitchResult() *DescribeSnitchResult {
	return &DescribeSnitchResult{}
}

var DescribeSnitchResult_Success_DEFAULT string

func (p *DescribeSnitchResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return DescribeSnitchResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *DescribeSnitchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeSnitchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *DescribeSnitchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSnitchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchResult(%+v)", *p)
}

type DescribeKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewDescribeKeyspaceArgs() *DescribeKeyspaceArgs {
	return &DescribeKeyspaceArgs{}
}

func (p *DescribeKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *DescribeKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceArgs(%+v)", *p)
}

type DescribeKeyspaceResult struct {
	Success *KsDef                   `thrift:"success,0" json:"success"`
	Nfe     *NotFoundException       `thrift:"nfe,1" json:"nfe"`
	Ire     *InvalidRequestException `thrift:"ire,2" json:"ire"`
}

func NewDescribeKeyspaceResult() *DescribeKeyspaceResult {
	return &DescribeKeyspaceResult{}
}

var DescribeKeyspaceResult_Success_DEFAULT *KsDef

func (p *DescribeKeyspaceResult) GetSuccess() *KsDef {
	if !p.IsSetSuccess() {
		return DescribeKeyspaceResult_Success_DEFAULT
	}
	return p.Success
}

var DescribeKeyspaceResult_Nfe_DEFAULT *NotFoundException

func (p *DescribeKeyspaceResult) GetNfe() *NotFoundException {
	if !p.IsSetNfe() {
		return DescribeKeyspaceResult_Nfe_DEFAULT
	}
	return p.Nfe
}

var DescribeKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeKeyspaceResult) IsSetNfe() bool {
	return p.Nfe != nil
}

func (p *DescribeKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &KsDef{
		DurableWrites: true,
	}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Nfe = &NotFoundException{}
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetNfe() {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:nfe: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceResult(%+v)", *p)
}

type DescribeSplitsArgs struct {
	CfName       string `thrift:"cfName,1,required" json:"cfName"`
	StartToken   string `thrift:"start_token,2,required" json:"start_token"`
	EndToken     string `thrift:"end_token,3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required" json:"keys_per_split"`
}

func NewDescribeSplitsArgs() *DescribeSplitsArgs {
	return &DescribeSplitsArgs{}
}

func (p *DescribeSplitsArgs) GetCfName() string {
	return p.CfName
}

func (p *DescribeSplitsArgs) GetStartToken() string {
	return p.StartToken
}

func (p *DescribeSplitsArgs) GetEndToken() string {
	return p.EndToken
}

func (p *DescribeSplitsArgs) GetKeysPerSplit() int32 {
	return p.KeysPerSplit
}
func (p *DescribeSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.CfName = v
	}
	return nil
}

func (p *DescribeSplitsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *DescribeSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return fmt.Errorf("%T.cfName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfName: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:keys_per_split: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return fmt.Errorf("%T.keys_per_split (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:keys_per_split: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsArgs(%+v)", *p)
}

type DescribeSplitsResult struct {
	Success []string                 `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeSplitsResult() *DescribeSplitsResult {
	return &DescribeSplitsResult{}
}

var DescribeSplitsResult_Success_DEFAULT []string

func (p *DescribeSplitsResult) GetSuccess() []string {
	return p.Success
}

var DescribeSplitsResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeSplitsResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeSplitsResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeSplitsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeSplitsResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem154 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem154 = v
		}
		p.Success = append(p.Success, _elem154)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DescribeSplitsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsResult(%+v)", *p)
}

type TraceNextQueryArgs struct {
}

func NewTraceNextQueryArgs() *TraceNextQueryArgs {
	return &TraceNextQueryArgs{}
}

func (p *TraceNextQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TraceNextQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TraceNextQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TraceNextQueryArgs(%+v)", *p)
}

type TraceNextQueryResult struct {
	Success []byte `thrift:"success,0" json:"success"`
}

func NewTraceNextQueryResult() *TraceNextQueryResult {
	return &TraceNextQueryResult{}
}

var TraceNextQueryResult_Success_DEFAULT []byte

func (p *TraceNextQueryResult) GetSuccess() []byte {
	return p.Success
}
func (p *TraceNextQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TraceNextQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TraceNextQueryResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *TraceNextQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TraceNextQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TraceNextQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TraceNextQueryResult(%+v)", *p)
}

type DescribeSplitsExArgs struct {
	CfName       string `thrift:"cfName,1,required" json:"cfName"`
	StartToken   string `thrift:"start_token,2,required" json:"start_token"`
	EndToken     string `thrift:"end_token,3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required" json:"keys_per_split"`
}

func NewDescribeSplitsExArgs() *DescribeSplitsExArgs {
	return &DescribeSplitsExArgs{}
}

func (p *DescribeSplitsExArgs) GetCfName() string {
	return p.CfName
}

func (p *DescribeSplitsExArgs) GetStartToken() string {
	return p.StartToken
}

func (p *DescribeSplitsExArgs) GetEndToken() string {
	return p.EndToken
}

func (p *DescribeSplitsExArgs) GetKeysPerSplit() int32 {
	return p.KeysPerSplit
}
func (p *DescribeSplitsExArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsExArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.CfName = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsExArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return fmt.Errorf("%T.cfName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfName: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:keys_per_split: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return fmt.Errorf("%T.keys_per_split (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:keys_per_split: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsExArgs(%+v)", *p)
}

type DescribeSplitsExResult struct {
	Success []*CfSplit               `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewDescribeSplitsExResult() *DescribeSplitsExResult {
	return &DescribeSplitsExResult{}
}

var DescribeSplitsExResult_Success_DEFAULT []*CfSplit

func (p *DescribeSplitsExResult) GetSuccess() []*CfSplit {
	return p.Success
}

var DescribeSplitsExResult_Ire_DEFAULT *InvalidRequestException

func (p *DescribeSplitsExResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return DescribeSplitsExResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *DescribeSplitsExResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DescribeSplitsExResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *DescribeSplitsExResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsExResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*CfSplit, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem155 := &CfSplit{}
		if err := _elem155.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem155, err)
		}
		p.Success = append(p.Success, _elem155)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DescribeSplitsExResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *DescribeSplitsExResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsExResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsExResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsExResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsExResult(%+v)", *p)
}

type SystemAddColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required" json:"cf_def"`
}

func NewSystemAddColumnFamilyArgs() *SystemAddColumnFamilyArgs {
	return &SystemAddColumnFamilyArgs{}
}

var SystemAddColumnFamilyArgs_CfDef_DEFAULT *CfDef

func (p *SystemAddColumnFamilyArgs) GetCfDef() *CfDef {
	if !p.IsSetCfDef() {
		return SystemAddColumnFamilyArgs_CfDef_DEFAULT
	}
	return p.CfDef
}
func (p *SystemAddColumnFamilyArgs) IsSetCfDef() bool {
	return p.CfDef != nil
}

func (p *SystemAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	p.CfDef = &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		SpeculativeRetry: "NONE",
	}
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
	}
	if err := p.CfDef.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.CfDef, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
	}
	return err
}

func (p *SystemAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyArgs(%+v)", *p)
}

type SystemAddColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemAddColumnFamilyResult() *SystemAddColumnFamilyResult {
	return &SystemAddColumnFamilyResult{}
}

var SystemAddColumnFamilyResult_Success_DEFAULT string

func (p *SystemAddColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemAddColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemAddColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemAddColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemAddColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemAddColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemAddColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemAddColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemAddColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemAddColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemAddColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyResult(%+v)", *p)
}

type SystemDropColumnFamilyArgs struct {
	ColumnFamily string `thrift:"column_family,1,required" json:"column_family"`
}

func NewSystemDropColumnFamilyArgs() *SystemDropColumnFamilyArgs {
	return &SystemDropColumnFamilyArgs{}
}

func (p *SystemDropColumnFamilyArgs) GetColumnFamily() string {
	return p.ColumnFamily
}
func (p *SystemDropColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_family: %s", p, err)
	}
	return err
}

func (p *SystemDropColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyArgs(%+v)", *p)
}

type SystemDropColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemDropColumnFamilyResult() *SystemDropColumnFamilyResult {
	return &SystemDropColumnFamilyResult{}
}

var SystemDropColumnFamilyResult_Success_DEFAULT string

func (p *SystemDropColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemDropColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemDropColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemDropColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemDropColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemDropColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemDropColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemDropColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemDropColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemDropColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemDropColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemDropColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyResult(%+v)", *p)
}

type SystemAddKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required" json:"ks_def"`
}

func NewSystemAddKeyspaceArgs() *SystemAddKeyspaceArgs {
	return &SystemAddKeyspaceArgs{}
}

var SystemAddKeyspaceArgs_KsDef_DEFAULT *KsDef

func (p *SystemAddKeyspaceArgs) GetKsDef() *KsDef {
	if !p.IsSetKsDef() {
		return SystemAddKeyspaceArgs_KsDef_DEFAULT
	}
	return p.KsDef
}
func (p *SystemAddKeyspaceArgs) IsSetKsDef() bool {
	return p.KsDef != nil
}

func (p *SystemAddKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) ReadField1(iprot thrift.TProtocol) error {
	p.KsDef = &KsDef{
		DurableWrites: true,
	}
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef, err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
	}
	if err := p.KsDef.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.KsDef, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
	}
	return err
}

func (p *SystemAddKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceArgs(%+v)", *p)
}

type SystemAddKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemAddKeyspaceResult() *SystemAddKeyspaceResult {
	return &SystemAddKeyspaceResult{}
}

var SystemAddKeyspaceResult_Success_DEFAULT string

func (p *SystemAddKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemAddKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemAddKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemAddKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemAddKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemAddKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemAddKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemAddKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemAddKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemAddKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemAddKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemAddKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemAddKeyspaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceResult(%+v)", *p)
}

type SystemDropKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required" json:"keyspace"`
}

func NewSystemDropKeyspaceArgs() *SystemDropKeyspaceArgs {
	return &SystemDropKeyspaceArgs{}
}

func (p *SystemDropKeyspaceArgs) GetKeyspace() string {
	return p.Keyspace
}
func (p *SystemDropKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SystemDropKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceArgs(%+v)", *p)
}

type SystemDropKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemDropKeyspaceResult() *SystemDropKeyspaceResult {
	return &SystemDropKeyspaceResult{}
}

var SystemDropKeyspaceResult_Success_DEFAULT string

func (p *SystemDropKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemDropKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemDropKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemDropKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemDropKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemDropKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemDropKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemDropKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemDropKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemDropKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemDropKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemDropKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemDropKeyspaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceResult(%+v)", *p)
}

type SystemUpdateKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required" json:"ks_def"`
}

func NewSystemUpdateKeyspaceArgs() *SystemUpdateKeyspaceArgs {
	return &SystemUpdateKeyspaceArgs{}
}

var SystemUpdateKeyspaceArgs_KsDef_DEFAULT *KsDef

func (p *SystemUpdateKeyspaceArgs) GetKsDef() *KsDef {
	if !p.IsSetKsDef() {
		return SystemUpdateKeyspaceArgs_KsDef_DEFAULT
	}
	return p.KsDef
}
func (p *SystemUpdateKeyspaceArgs) IsSetKsDef() bool {
	return p.KsDef != nil
}

func (p *SystemUpdateKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) ReadField1(iprot thrift.TProtocol) error {
	p.KsDef = &KsDef{
		DurableWrites: true,
	}
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
	}
	if err := p.KsDef.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.KsDef, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
	}
	return err
}

func (p *SystemUpdateKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceArgs(%+v)", *p)
}

type SystemUpdateKeyspaceResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemUpdateKeyspaceResult() *SystemUpdateKeyspaceResult {
	return &SystemUpdateKeyspaceResult{}
}

var SystemUpdateKeyspaceResult_Success_DEFAULT string

func (p *SystemUpdateKeyspaceResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemUpdateKeyspaceResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemUpdateKeyspaceResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemUpdateKeyspaceResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemUpdateKeyspaceResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemUpdateKeyspaceResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemUpdateKeyspaceResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemUpdateKeyspaceResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemUpdateKeyspaceResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemUpdateKeyspaceResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemUpdateKeyspaceResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemUpdateKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceResult(%+v)", *p)
}

type SystemUpdateColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required" json:"cf_def"`
}

func NewSystemUpdateColumnFamilyArgs() *SystemUpdateColumnFamilyArgs {
	return &SystemUpdateColumnFamilyArgs{}
}

var SystemUpdateColumnFamilyArgs_CfDef_DEFAULT *CfDef

func (p *SystemUpdateColumnFamilyArgs) GetCfDef() *CfDef {
	if !p.IsSetCfDef() {
		return SystemUpdateColumnFamilyArgs_CfDef_DEFAULT
	}
	return p.CfDef
}
func (p *SystemUpdateColumnFamilyArgs) IsSetCfDef() bool {
	return p.CfDef != nil
}

func (p *SystemUpdateColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) ReadField1(iprot thrift.TProtocol) error {
	p.CfDef = &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		SpeculativeRetry: "NONE",
	}
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
	}
	if err := p.CfDef.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.CfDef, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
	}
	return err
}

func (p *SystemUpdateColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyArgs(%+v)", *p)
}

type SystemUpdateColumnFamilyResult struct {
	Success *string                      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Sde     *SchemaDisagreementException `thrift:"sde,2" json:"sde"`
}

func NewSystemUpdateColumnFamilyResult() *SystemUpdateColumnFamilyResult {
	return &SystemUpdateColumnFamilyResult{}
}

var SystemUpdateColumnFamilyResult_Success_DEFAULT string

func (p *SystemUpdateColumnFamilyResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return SystemUpdateColumnFamilyResult_Success_DEFAULT
	}
	return *p.Success
}

var SystemUpdateColumnFamilyResult_Ire_DEFAULT *InvalidRequestException

func (p *SystemUpdateColumnFamilyResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SystemUpdateColumnFamilyResult_Ire_DEFAULT
	}
	return p.Ire
}

var SystemUpdateColumnFamilyResult_Sde_DEFAULT *SchemaDisagreementException

func (p *SystemUpdateColumnFamilyResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return SystemUpdateColumnFamilyResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *SystemUpdateColumnFamilyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *SystemUpdateColumnFamilyResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SystemUpdateColumnFamilyResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *SystemUpdateColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) ReadField2(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyResult(%+v)", *p)
}

type ExecuteCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewExecuteCqlQueryArgs() *ExecuteCqlQueryArgs {
	return &ExecuteCqlQueryArgs{}
}

func (p *ExecuteCqlQueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *ExecuteCqlQueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *ExecuteCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return fmt.Errorf("%T.query (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *ExecuteCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *ExecuteCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryArgs(%+v)", *p)
}

type ExecuteCqlQueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException           `thrift:"te,3" json:"te"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde"`
}

func NewExecuteCqlQueryResult() *ExecuteCqlQueryResult {
	return &ExecuteCqlQueryResult{}
}

var ExecuteCqlQueryResult_Success_DEFAULT *CqlResult_

func (p *ExecuteCqlQueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return ExecuteCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var ExecuteCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *ExecuteCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return ExecuteCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var ExecuteCqlQueryResult_Ue_DEFAULT *UnavailableException

func (p *ExecuteCqlQueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return ExecuteCqlQueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var ExecuteCqlQueryResult_Te_DEFAULT *TimedOutException

func (p *ExecuteCqlQueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return ExecuteCqlQueryResult_Te_DEFAULT
	}
	return p.Te
}

var ExecuteCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *ExecuteCqlQueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return ExecuteCqlQueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *ExecuteCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecuteCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *ExecuteCqlQueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *ExecuteCqlQueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *ExecuteCqlQueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *ExecuteCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) ReadField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryResult(%+v)", *p)
}

type ExecuteCql3QueryArgs struct {
	Query       []byte           `thrift:"query,1,required" json:"query"`
	Compression Compression      `thrift:"compression,2,required" json:"compression"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required" json:"consistency"`
}

func NewExecuteCql3QueryArgs() *ExecuteCql3QueryArgs {
	return &ExecuteCql3QueryArgs{}
}

func (p *ExecuteCql3QueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *ExecuteCql3QueryArgs) GetCompression() Compression {
	return p.Compression
}

func (p *ExecuteCql3QueryArgs) GetConsistency() ConsistencyLevel {
	return p.Consistency
}
func (p *ExecuteCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.Consistency = temp
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return fmt.Errorf("%T.query (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *ExecuteCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *ExecuteCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
		return fmt.Errorf("%T.consistency (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency: %s", p, err)
	}
	return err
}

func (p *ExecuteCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCql3QueryArgs(%+v)", *p)
}

type ExecuteCql3QueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException           `thrift:"te,3" json:"te"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde"`
}

func NewExecuteCql3QueryResult() *ExecuteCql3QueryResult {
	return &ExecuteCql3QueryResult{}
}

var ExecuteCql3QueryResult_Success_DEFAULT *CqlResult_

func (p *ExecuteCql3QueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return ExecuteCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var ExecuteCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *ExecuteCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return ExecuteCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var ExecuteCql3QueryResult_Ue_DEFAULT *UnavailableException

func (p *ExecuteCql3QueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return ExecuteCql3QueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var ExecuteCql3QueryResult_Te_DEFAULT *TimedOutException

func (p *ExecuteCql3QueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return ExecuteCql3QueryResult_Te_DEFAULT
	}
	return p.Te
}

var ExecuteCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *ExecuteCql3QueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return ExecuteCql3QueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *ExecuteCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecuteCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *ExecuteCql3QueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *ExecuteCql3QueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *ExecuteCql3QueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *ExecuteCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) ReadField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCql3QueryResult(%+v)", *p)
}

type PrepareCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewPrepareCqlQueryArgs() *PrepareCqlQueryArgs {
	return &PrepareCqlQueryArgs{}
}

func (p *PrepareCqlQueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *PrepareCqlQueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *PrepareCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *PrepareCqlQueryArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *PrepareCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return fmt.Errorf("%T.query (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *PrepareCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *PrepareCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryArgs(%+v)", *p)
}

type PrepareCqlQueryResult struct {
	Success *CqlPreparedResult_      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewPrepareCqlQueryResult() *PrepareCqlQueryResult {
	return &PrepareCqlQueryResult{}
}

var PrepareCqlQueryResult_Success_DEFAULT *CqlPreparedResult_

func (p *PrepareCqlQueryResult) GetSuccess() *CqlPreparedResult_ {
	if !p.IsSetSuccess() {
		return PrepareCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var PrepareCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *PrepareCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return PrepareCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *PrepareCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PrepareCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *PrepareCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlPreparedResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryResult(%+v)", *p)
}

type PrepareCql3QueryArgs struct {
	Query       []byte      `thrift:"query,1,required" json:"query"`
	Compression Compression `thrift:"compression,2,required" json:"compression"`
}

func NewPrepareCql3QueryArgs() *PrepareCql3QueryArgs {
	return &PrepareCql3QueryArgs{}
}

func (p *PrepareCql3QueryArgs) GetQuery() []byte {
	return p.Query
}

func (p *PrepareCql3QueryArgs) GetCompression() Compression {
	return p.Compression
}
func (p *PrepareCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCql3QueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *PrepareCql3QueryArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Compression(v)
		p.Compression = temp
	}
	return nil
}

func (p *PrepareCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Query); err != nil {
		return fmt.Errorf("%T.query (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *PrepareCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Compression)); err != nil {
		return fmt.Errorf("%T.compression (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
	}
	return err
}

func (p *PrepareCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCql3QueryArgs(%+v)", *p)
}

type PrepareCql3QueryResult struct {
	Success *CqlPreparedResult_      `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewPrepareCql3QueryResult() *PrepareCql3QueryResult {
	return &PrepareCql3QueryResult{}
}

var PrepareCql3QueryResult_Success_DEFAULT *CqlPreparedResult_

func (p *PrepareCql3QueryResult) GetSuccess() *CqlPreparedResult_ {
	if !p.IsSetSuccess() {
		return PrepareCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var PrepareCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *PrepareCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return PrepareCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *PrepareCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *PrepareCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *PrepareCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlPreparedResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCql3QueryResult(%+v)", *p)
}

type ExecutePreparedCqlQueryArgs struct {
	ItemId int32    `thrift:"itemId,1,required" json:"itemId"`
	Values [][]byte `thrift:"values,2,required" json:"values"`
}

func NewExecutePreparedCqlQueryArgs() *ExecutePreparedCqlQueryArgs {
	return &ExecutePreparedCqlQueryArgs{}
}

func (p *ExecutePreparedCqlQueryArgs) GetItemId() int32 {
	return p.ItemId
}

func (p *ExecutePreparedCqlQueryArgs) GetValues() [][]byte {
	return p.Values
}
func (p *ExecutePreparedCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem156 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem156 = v
		}
		p.Values = append(p.Values, _elem156)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:values: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Values {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:values: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryArgs(%+v)", *p)
}

type ExecutePreparedCqlQueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException           `thrift:"te,3" json:"te"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde"`
}

func NewExecutePreparedCqlQueryResult() *ExecutePreparedCqlQueryResult {
	return &ExecutePreparedCqlQueryResult{}
}

var ExecutePreparedCqlQueryResult_Success_DEFAULT *CqlResult_

func (p *ExecutePreparedCqlQueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return ExecutePreparedCqlQueryResult_Success_DEFAULT
	}
	return p.Success
}

var ExecutePreparedCqlQueryResult_Ire_DEFAULT *InvalidRequestException

func (p *ExecutePreparedCqlQueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return ExecutePreparedCqlQueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var ExecutePreparedCqlQueryResult_Ue_DEFAULT *UnavailableException

func (p *ExecutePreparedCqlQueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return ExecutePreparedCqlQueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var ExecutePreparedCqlQueryResult_Te_DEFAULT *TimedOutException

func (p *ExecutePreparedCqlQueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return ExecutePreparedCqlQueryResult_Te_DEFAULT
	}
	return p.Te
}

var ExecutePreparedCqlQueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *ExecutePreparedCqlQueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return ExecutePreparedCqlQueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *ExecutePreparedCqlQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecutePreparedCqlQueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *ExecutePreparedCqlQueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *ExecutePreparedCqlQueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *ExecutePreparedCqlQueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *ExecutePreparedCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) ReadField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryResult(%+v)", *p)
}

type ExecutePreparedCql3QueryArgs struct {
	ItemId      int32            `thrift:"itemId,1,required" json:"itemId"`
	Values      [][]byte         `thrift:"values,2,required" json:"values"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required" json:"consistency"`
}

func NewExecutePreparedCql3QueryArgs() *ExecutePreparedCql3QueryArgs {
	return &ExecutePreparedCql3QueryArgs{}
}

func (p *ExecutePreparedCql3QueryArgs) GetItemId() int32 {
	return p.ItemId
}

func (p *ExecutePreparedCql3QueryArgs) GetValues() [][]byte {
	return p.Values
}

func (p *ExecutePreparedCql3QueryArgs) GetConsistency() ConsistencyLevel {
	return p.Consistency
}
func (p *ExecutePreparedCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem157 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem157 = v
		}
		p.Values = append(p.Values, _elem157)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := ConsistencyLevel(v)
		p.Consistency = temp
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:values: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Values {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:values: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:consistency: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
		return fmt.Errorf("%T.consistency (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:consistency: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCql3QueryArgs(%+v)", *p)
}

type ExecutePreparedCql3QueryResult struct {
	Success *CqlResult_                  `thrift:"success,0" json:"success"`
	Ire     *InvalidRequestException     `thrift:"ire,1" json:"ire"`
	Ue      *UnavailableException        `thrift:"ue,2" json:"ue"`
	Te      *TimedOutException           `thrift:"te,3" json:"te"`
	Sde     *SchemaDisagreementException `thrift:"sde,4" json:"sde"`
}

func NewExecutePreparedCql3QueryResult() *ExecutePreparedCql3QueryResult {
	return &ExecutePreparedCql3QueryResult{}
}

var ExecutePreparedCql3QueryResult_Success_DEFAULT *CqlResult_

func (p *ExecutePreparedCql3QueryResult) GetSuccess() *CqlResult_ {
	if !p.IsSetSuccess() {
		return ExecutePreparedCql3QueryResult_Success_DEFAULT
	}
	return p.Success
}

var ExecutePreparedCql3QueryResult_Ire_DEFAULT *InvalidRequestException

func (p *ExecutePreparedCql3QueryResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return ExecutePreparedCql3QueryResult_Ire_DEFAULT
	}
	return p.Ire
}

var ExecutePreparedCql3QueryResult_Ue_DEFAULT *UnavailableException

func (p *ExecutePreparedCql3QueryResult) GetUe() *UnavailableException {
	if !p.IsSetUe() {
		return ExecutePreparedCql3QueryResult_Ue_DEFAULT
	}
	return p.Ue
}

var ExecutePreparedCql3QueryResult_Te_DEFAULT *TimedOutException

func (p *ExecutePreparedCql3QueryResult) GetTe() *TimedOutException {
	if !p.IsSetTe() {
		return ExecutePreparedCql3QueryResult_Te_DEFAULT
	}
	return p.Te
}

var ExecutePreparedCql3QueryResult_Sde_DEFAULT *SchemaDisagreementException

func (p *ExecutePreparedCql3QueryResult) GetSde() *SchemaDisagreementException {
	if !p.IsSetSde() {
		return ExecutePreparedCql3QueryResult_Sde_DEFAULT
	}
	return p.Sde
}
func (p *ExecutePreparedCql3QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecutePreparedCql3QueryResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *ExecutePreparedCql3QueryResult) IsSetUe() bool {
	return p.Ue != nil
}

func (p *ExecutePreparedCql3QueryResult) IsSetTe() bool {
	return p.Te != nil
}

func (p *ExecutePreparedCql3QueryResult) IsSetSde() bool {
	return p.Sde != nil
}

func (p *ExecutePreparedCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &CqlResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ue = &UnavailableException{}
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) ReadField3(iprot thrift.TProtocol) error {
	p.Te = &TimedOutException{}
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) ReadField4(iprot thrift.TProtocol) error {
	p.Sde = &SchemaDisagreementException{}
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUe() {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTe() {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSde() {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCql3QueryResult(%+v)", *p)
}

type SetCqlVersionArgs struct {
	Version string `thrift:"version,1,required" json:"version"`
}

func NewSetCqlVersionArgs() *SetCqlVersionArgs {
	return &SetCqlVersionArgs{}
}

func (p *SetCqlVersionArgs) GetVersion() string {
	return p.Version
}
func (p *SetCqlVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCqlVersionArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Version = v
	}
	return nil
}

func (p *SetCqlVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCqlVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("version", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:version: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Version)); err != nil {
		return fmt.Errorf("%T.version (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:version: %s", p, err)
	}
	return err
}

func (p *SetCqlVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCqlVersionArgs(%+v)", *p)
}

type SetCqlVersionResult struct {
	Ire *InvalidRequestException `thrift:"ire,1" json:"ire"`
}

func NewSetCqlVersionResult() *SetCqlVersionResult {
	return &SetCqlVersionResult{}
}

var SetCqlVersionResult_Ire_DEFAULT *InvalidRequestException

func (p *SetCqlVersionResult) GetIre() *InvalidRequestException {
	if !p.IsSetIre() {
		return SetCqlVersionResult_Ire_DEFAULT
	}
	return p.Ire
}
func (p *SetCqlVersionResult) IsSetIre() bool {
	return p.Ire != nil
}

func (p *SetCqlVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCqlVersionResult) ReadField1(iprot thrift.TProtocol) error {
	p.Ire = &InvalidRequestException{}
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire, err)
	}
	return nil
}

func (p *SetCqlVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCqlVersionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIre() {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SetCqlVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCqlVersionResult(%+v)", *p)
}
