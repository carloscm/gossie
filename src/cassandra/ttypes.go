// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"bytes"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var GoUnusedProtection__ int

//The ConsistencyLevel is an enum that controls both read and write
//behavior based on the ReplicationFactor of the keyspace.  The
//different consistency levels have different meanings, depending on
//if you're doing a write or read operation.
//
//If W + R > ReplicationFactor, where W is the number of nodes to
//block for on write, and R the number to block for on reads, you
//will have strongly consistent behavior; that is, readers will
//always see the most recent write. Of these, the most interesting is
//to do QUORUM reads and writes, which gives you consistency while
//still allowing availability in the face of node failures up to half
//of <ReplicationFactor>. Of course if latency is more important than
//consistency then you can use lower values for either or both.
//
//Some ConsistencyLevels (ONE, TWO, THREE) refer to a specific number
//of replicas rather than a logical concept that adjusts
//automatically with the replication factor.  Of these, only ONE is
//commonly used; TWO and (even more rarely) THREE are only useful
//when you care more about guaranteeing a certain level of
//durability, than consistency.
//
//Write consistency levels make the following guarantees before reporting success to the client:
//  ANY          Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
//  ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
//  TWO          Ensure that the write has been written to at least 2 node's commit log and memory table
//  THREE        Ensure that the write has been written to at least 3 node's commit log and memory table
//  QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
//  LOCAL_ONE    Ensure that the write has been written to 1 node within the local datacenter (requires NetworkTopologyStrategy)
//  LOCAL_QUORUM Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires NetworkTopologyStrategy)
//  EACH_QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires NetworkTopologyStrategy)
//  ALL          Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
//
//Read consistency levels make the following guarantees before returning successful results to the client:
//  ANY          Not supported. You probably want ONE instead.
//  ONE          Returns the record obtained from a single replica.
//  TWO          Returns the record with the most recent timestamp once two replicas have replied.
//  THREE        Returns the record with the most recent timestamp once three replicas have replied.
//  QUORUM       Returns the record with the most recent timestamp once a majority of replicas have replied.
//  LOCAL_ONE    Returns the record with the most recent timestamp once a single replica within the local datacenter have replied.
//  LOCAL_QUORUM Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
//  EACH_QUORUM  Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
//  ALL          Returns the record with the most recent timestamp once all replicas have replied (implies no replica may be down)..
type ConsistencyLevel int64

const (
	ConsistencyLevel_ONE          ConsistencyLevel = 1
	ConsistencyLevel_QUORUM       ConsistencyLevel = 2
	ConsistencyLevel_LOCAL_QUORUM ConsistencyLevel = 3
	ConsistencyLevel_EACH_QUORUM  ConsistencyLevel = 4
	ConsistencyLevel_ALL          ConsistencyLevel = 5
	ConsistencyLevel_ANY          ConsistencyLevel = 6
	ConsistencyLevel_TWO          ConsistencyLevel = 7
	ConsistencyLevel_THREE        ConsistencyLevel = 8
	ConsistencyLevel_SERIAL       ConsistencyLevel = 9
	ConsistencyLevel_LOCAL_SERIAL ConsistencyLevel = 10
	ConsistencyLevel_LOCAL_ONE    ConsistencyLevel = 11
)

func (p ConsistencyLevel) String() string {
	switch p {
	case ConsistencyLevel_ONE:
		return "ONE"
	case ConsistencyLevel_QUORUM:
		return "QUORUM"
	case ConsistencyLevel_LOCAL_QUORUM:
		return "LOCAL_QUORUM"
	case ConsistencyLevel_EACH_QUORUM:
		return "EACH_QUORUM"
	case ConsistencyLevel_ALL:
		return "ALL"
	case ConsistencyLevel_ANY:
		return "ANY"
	case ConsistencyLevel_TWO:
		return "TWO"
	case ConsistencyLevel_THREE:
		return "THREE"
	case ConsistencyLevel_SERIAL:
		return "SERIAL"
	case ConsistencyLevel_LOCAL_SERIAL:
		return "LOCAL_SERIAL"
	case ConsistencyLevel_LOCAL_ONE:
		return "LOCAL_ONE"
	}
	return "<UNSET>"
}

func ConsistencyLevelFromString(s string) (ConsistencyLevel, error) {
	switch s {
	case "ONE":
		return ConsistencyLevel_ONE, nil
	case "QUORUM":
		return ConsistencyLevel_QUORUM, nil
	case "LOCAL_QUORUM":
		return ConsistencyLevel_LOCAL_QUORUM, nil
	case "EACH_QUORUM":
		return ConsistencyLevel_EACH_QUORUM, nil
	case "ALL":
		return ConsistencyLevel_ALL, nil
	case "ANY":
		return ConsistencyLevel_ANY, nil
	case "TWO":
		return ConsistencyLevel_TWO, nil
	case "THREE":
		return ConsistencyLevel_THREE, nil
	case "SERIAL":
		return ConsistencyLevel_SERIAL, nil
	case "LOCAL_SERIAL":
		return ConsistencyLevel_LOCAL_SERIAL, nil
	case "LOCAL_ONE":
		return ConsistencyLevel_LOCAL_ONE, nil
	}
	return ConsistencyLevel(0), fmt.Errorf("not a valid ConsistencyLevel string")
}

func ConsistencyLevelPtr(v ConsistencyLevel) *ConsistencyLevel { return &v }

func (p ConsistencyLevel) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ConsistencyLevel) UnmarshalText(text []byte) error {
	q, err := ConsistencyLevelFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

type IndexOperator int64

const (
	IndexOperator_EQ  IndexOperator = 0
	IndexOperator_GTE IndexOperator = 1
	IndexOperator_GT  IndexOperator = 2
	IndexOperator_LTE IndexOperator = 3
	IndexOperator_LT  IndexOperator = 4
)

func (p IndexOperator) String() string {
	switch p {
	case IndexOperator_EQ:
		return "EQ"
	case IndexOperator_GTE:
		return "GTE"
	case IndexOperator_GT:
		return "GT"
	case IndexOperator_LTE:
		return "LTE"
	case IndexOperator_LT:
		return "LT"
	}
	return "<UNSET>"
}

func IndexOperatorFromString(s string) (IndexOperator, error) {
	switch s {
	case "EQ":
		return IndexOperator_EQ, nil
	case "GTE":
		return IndexOperator_GTE, nil
	case "GT":
		return IndexOperator_GT, nil
	case "LTE":
		return IndexOperator_LTE, nil
	case "LT":
		return IndexOperator_LT, nil
	}
	return IndexOperator(0), fmt.Errorf("not a valid IndexOperator string")
}

func IndexOperatorPtr(v IndexOperator) *IndexOperator { return &v }

func (p IndexOperator) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *IndexOperator) UnmarshalText(text []byte) error {
	q, err := IndexOperatorFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

type IndexType int64

const (
	IndexType_KEYS       IndexType = 0
	IndexType_CUSTOM     IndexType = 1
	IndexType_COMPOSITES IndexType = 2
)

func (p IndexType) String() string {
	switch p {
	case IndexType_KEYS:
		return "KEYS"
	case IndexType_CUSTOM:
		return "CUSTOM"
	case IndexType_COMPOSITES:
		return "COMPOSITES"
	}
	return "<UNSET>"
}

func IndexTypeFromString(s string) (IndexType, error) {
	switch s {
	case "KEYS":
		return IndexType_KEYS, nil
	case "CUSTOM":
		return IndexType_CUSTOM, nil
	case "COMPOSITES":
		return IndexType_COMPOSITES, nil
	}
	return IndexType(0), fmt.Errorf("not a valid IndexType string")
}

func IndexTypePtr(v IndexType) *IndexType { return &v }

func (p IndexType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *IndexType) UnmarshalText(text []byte) error {
	q, err := IndexTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

//CQL query compression
type Compression int64

const (
	Compression_GZIP Compression = 1
	Compression_NONE Compression = 2
)

func (p Compression) String() string {
	switch p {
	case Compression_GZIP:
		return "GZIP"
	case Compression_NONE:
		return "NONE"
	}
	return "<UNSET>"
}

func CompressionFromString(s string) (Compression, error) {
	switch s {
	case "GZIP":
		return Compression_GZIP, nil
	case "NONE":
		return Compression_NONE, nil
	}
	return Compression(0), fmt.Errorf("not a valid Compression string")
}

func CompressionPtr(v Compression) *Compression { return &v }

func (p Compression) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *Compression) UnmarshalText(text []byte) error {
	q, err := CompressionFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

type CqlResultType int64

const (
	CqlResultType_ROWS CqlResultType = 1
	CqlResultType_VOID CqlResultType = 2
	CqlResultType_INT  CqlResultType = 3
)

func (p CqlResultType) String() string {
	switch p {
	case CqlResultType_ROWS:
		return "ROWS"
	case CqlResultType_VOID:
		return "VOID"
	case CqlResultType_INT:
		return "INT"
	}
	return "<UNSET>"
}

func CqlResultTypeFromString(s string) (CqlResultType, error) {
	switch s {
	case "ROWS":
		return CqlResultType_ROWS, nil
	case "VOID":
		return CqlResultType_VOID, nil
	case "INT":
		return CqlResultType_INT, nil
	}
	return CqlResultType(0), fmt.Errorf("not a valid CqlResultType string")
}

func CqlResultTypePtr(v CqlResultType) *CqlResultType { return &v }

func (p CqlResultType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *CqlResultType) UnmarshalText(text []byte) error {
	q, err := CqlResultTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

// Basic unit of data within a ColumnFamily.
// @param name, the name by which this column is set and retrieved.  Maximum 64KB long.
// @param value. The data associated with the name.  Maximum 2GB long, but in practice you should limit it to small numbers of MB (since Thrift must read the full value into memory to operate on it).
// @param timestamp. The timestamp is used for conflict detection/resolution when two columns with same name need to be compared.
// @param ttl. An optional, positive delay (in seconds) after which the column will be automatically deleted.
//
// Attributes:
//  - Name
//  - Value
//  - Timestamp
//  - TTL
type Column struct {
	Name      []byte `thrift:"name,1,required" json:"name"`
	Value     []byte `thrift:"value,2" json:"value,omitempty"`
	Timestamp *int64 `thrift:"timestamp,3" json:"timestamp,omitempty"`
	TTL       *int32 `thrift:"ttl,4" json:"ttl,omitempty"`
}

func NewColumn() *Column {
	return &Column{}
}

func (p *Column) GetName() []byte {
	return p.Name
}

var Column_Value_DEFAULT []byte

func (p *Column) GetValue() []byte {
	return p.Value
}

var Column_Timestamp_DEFAULT int64

func (p *Column) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return Column_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var Column_TTL_DEFAULT int32

func (p *Column) GetTTL() int32 {
	if !p.IsSetTTL() {
		return Column_TTL_DEFAULT
	}
	return *p.TTL
}
func (p *Column) IsSetValue() bool {
	return p.Value != nil
}

func (p *Column) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Column) IsSetTTL() bool {
	return p.TTL != nil
}

func (p *Column) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *Column) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *Column) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *Column) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Column) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.TTL = &v
	}
	return nil
}

func (p *Column) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Column"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Column) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *Column) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetValue() {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
		}
	}
	return err
}

func (p *Column) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:timestamp: ", p), err)
		}
	}
	return err
}

func (p *Column) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTTL() {
		if err := oprot.WriteFieldBegin("ttl", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ttl: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.TTL)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ttl (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ttl: ", p), err)
		}
	}
	return err
}

func (p *Column) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Column(%+v)", *p)
}

// A named list of columns.
// @param name. see Column.name.
// @param columns. A collection of standard Columns.  The columns within a super column are defined in an adhoc manner.
//                 Columns within a super column do not have to have matching structures (similarly named child columns).
//
// Attributes:
//  - Name
//  - Columns
type SuperColumn struct {
	Name    []byte    `thrift:"name,1,required" json:"name"`
	Columns []*Column `thrift:"columns,2,required" json:"columns"`
}

func NewSuperColumn() *SuperColumn {
	return &SuperColumn{}
}

func (p *SuperColumn) GetName() []byte {
	return p.Name
}

func (p *SuperColumn) GetColumns() []*Column {
	return p.Columns
}
func (p *SuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumns = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *SuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *SuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &Column{}
		if err := _elem0.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.Columns = append(p.Columns, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SuperColumn"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *SuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *SuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SuperColumn(%+v)", *p)
}

// Attributes:
//  - Name
//  - Value
type CounterColumn struct {
	Name  []byte `thrift:"name,1,required" json:"name"`
	Value int64  `thrift:"value,2,required" json:"value"`
}

func NewCounterColumn() *CounterColumn {
	return &CounterColumn{}
}

func (p *CounterColumn) GetName() []byte {
	return p.Name
}

func (p *CounterColumn) GetValue() int64 {
	return p.Value
}
func (p *CounterColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetValue bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetValue = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetValue {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"))
	}
	return nil
}

func (p *CounterColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterColumn) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CounterColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterColumn"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CounterColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *CounterColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
	}
	return err
}

func (p *CounterColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterColumn(%+v)", *p)
}

// Attributes:
//  - Name
//  - Columns
type CounterSuperColumn struct {
	Name    []byte           `thrift:"name,1,required" json:"name"`
	Columns []*CounterColumn `thrift:"columns,2,required" json:"columns"`
}

func NewCounterSuperColumn() *CounterSuperColumn {
	return &CounterSuperColumn{}
}

func (p *CounterSuperColumn) GetName() []byte {
	return p.Name
}

func (p *CounterSuperColumn) GetColumns() []*CounterColumn {
	return p.Columns
}
func (p *CounterSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumns = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *CounterSuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterSuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CounterColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem1 := &CounterColumn{}
		if err := _elem1.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
		}
		p.Columns = append(p.Columns, _elem1)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CounterSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterSuperColumn"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CounterSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *CounterSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *CounterSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterSuperColumn(%+v)", *p)
}

// Methods for fetching rows/records from Cassandra will return either a single instance of ColumnOrSuperColumn or a list
// of ColumnOrSuperColumns (get_slice()). If you're looking up a SuperColumn (or list of SuperColumns) then the resulting
// instances of ColumnOrSuperColumn will have the requested SuperColumn in the attribute super_column. For queries resulting
// in Columns, those values will be in the attribute column. This change was made between 0.3 and 0.4 to standardize on
// single query methods that may return either a SuperColumn or Column.
//
// If the query was on a counter column family, you will either get a counter_column (instead of a column) or a
// counter_super_column (instead of a super_column)
//
// @param column. The Column returned by get() or get_slice().
// @param super_column. The SuperColumn returned by get() or get_slice().
// @param counter_column. The Counterolumn returned by get() or get_slice().
// @param counter_super_column. The CounterSuperColumn returned by get() or get_slice().
//
// Attributes:
//  - Column
//  - SuperColumn
//  - CounterColumn
//  - CounterSuperColumn
type ColumnOrSuperColumn struct {
	Column             *Column             `thrift:"column,1" json:"column,omitempty"`
	SuperColumn        *SuperColumn        `thrift:"super_column,2" json:"super_column,omitempty"`
	CounterColumn      *CounterColumn      `thrift:"counter_column,3" json:"counter_column,omitempty"`
	CounterSuperColumn *CounterSuperColumn `thrift:"counter_super_column,4" json:"counter_super_column,omitempty"`
}

func NewColumnOrSuperColumn() *ColumnOrSuperColumn {
	return &ColumnOrSuperColumn{}
}

var ColumnOrSuperColumn_Column_DEFAULT *Column

func (p *ColumnOrSuperColumn) GetColumn() *Column {
	if !p.IsSetColumn() {
		return ColumnOrSuperColumn_Column_DEFAULT
	}
	return p.Column
}

var ColumnOrSuperColumn_SuperColumn_DEFAULT *SuperColumn

func (p *ColumnOrSuperColumn) GetSuperColumn() *SuperColumn {
	if !p.IsSetSuperColumn() {
		return ColumnOrSuperColumn_SuperColumn_DEFAULT
	}
	return p.SuperColumn
}

var ColumnOrSuperColumn_CounterColumn_DEFAULT *CounterColumn

func (p *ColumnOrSuperColumn) GetCounterColumn() *CounterColumn {
	if !p.IsSetCounterColumn() {
		return ColumnOrSuperColumn_CounterColumn_DEFAULT
	}
	return p.CounterColumn
}

var ColumnOrSuperColumn_CounterSuperColumn_DEFAULT *CounterSuperColumn

func (p *ColumnOrSuperColumn) GetCounterSuperColumn() *CounterSuperColumn {
	if !p.IsSetCounterSuperColumn() {
		return ColumnOrSuperColumn_CounterSuperColumn_DEFAULT
	}
	return p.CounterSuperColumn
}
func (p *ColumnOrSuperColumn) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnOrSuperColumn) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterColumn() bool {
	return p.CounterColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterSuperColumn() bool {
	return p.CounterSuperColumn != nil
}

func (p *ColumnOrSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField1(iprot thrift.TProtocol) error {
	p.Column = &Column{}
	if err := p.Column.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Column), err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField2(iprot thrift.TProtocol) error {
	p.SuperColumn = &SuperColumn{}
	if err := p.SuperColumn.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SuperColumn), err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField3(iprot thrift.TProtocol) error {
	p.CounterColumn = &CounterColumn{}
	if err := p.CounterColumn.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CounterColumn), err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField4(iprot thrift.TProtocol) error {
	p.CounterSuperColumn = &CounterSuperColumn{}
	if err := p.CounterSuperColumn.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.CounterSuperColumn), err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnOrSuperColumn"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumn() {
		if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column: ", p), err)
		}
		if err := p.Column.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Column), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column: ", p), err)
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuperColumn() {
		if err := oprot.WriteFieldBegin("super_column", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:super_column: ", p), err)
		}
		if err := p.SuperColumn.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SuperColumn), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:super_column: ", p), err)
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetCounterColumn() {
		if err := oprot.WriteFieldBegin("counter_column", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_column: ", p), err)
		}
		if err := p.CounterColumn.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CounterColumn), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_column: ", p), err)
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetCounterSuperColumn() {
		if err := oprot.WriteFieldBegin("counter_super_column", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:counter_super_column: ", p), err)
		}
		if err := p.CounterSuperColumn.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.CounterSuperColumn), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:counter_super_column: ", p), err)
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnOrSuperColumn(%+v)", *p)
}

// A specific column was requested that does not exist.
type NotFoundException struct {
}

func NewNotFoundException() *NotFoundException {
	return &NotFoundException{}
}

func (p *NotFoundException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NotFoundException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("NotFoundException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NotFoundException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NotFoundException(%+v)", *p)
}

func (p *NotFoundException) Error() string {
	return p.String()
}

// Invalid request could mean keyspace or column family does not exist, required parameters are missing, or a parameter is malformed.
// why contains an associated error message.
//
// Attributes:
//  - Why
type InvalidRequestException struct {
	Why string `thrift:"why,1,required" json:"why"`
}

func NewInvalidRequestException() *InvalidRequestException {
	return &InvalidRequestException{}
}

func (p *InvalidRequestException) GetWhy() string {
	return p.Why
}
func (p *InvalidRequestException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWhy bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetWhy = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWhy {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"))
	}
	return nil
}

func (p *InvalidRequestException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *InvalidRequestException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InvalidRequestException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *InvalidRequestException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err)
	}
	return err
}

func (p *InvalidRequestException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InvalidRequestException(%+v)", *p)
}

func (p *InvalidRequestException) Error() string {
	return p.String()
}

// Not all the replicas required could be created and/or read.
type UnavailableException struct {
}

func NewUnavailableException() *UnavailableException {
	return &UnavailableException{}
}

func (p *UnavailableException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UnavailableException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UnavailableException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UnavailableException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnavailableException(%+v)", *p)
}

func (p *UnavailableException) Error() string {
	return p.String()
}

// RPC timeout was exceeded.  either a node failed mid-operation, or load was too high, or the requested op was too large.
//
// Attributes:
//  - AcknowledgedBy: if a write operation was acknowledged by some replicas but not by enough to
// satisfy the required ConsistencyLevel, the number of successful
// replies will be given here. In case of atomic_batch_mutate method this field
// will be set to -1 if the batch was written to the batchlog and to 0 if it wasn't.
//  - AcknowledgedByBatchlog: in case of atomic_batch_mutate method this field tells if the batch
// was written to the batchlog.
//  - PaxosInProgress: for the CAS method, this field tells if we timed out during the paxos
// protocol, as opposed to during the commit of our update
type TimedOutException struct {
	AcknowledgedBy         *int32 `thrift:"acknowledged_by,1" json:"acknowledged_by,omitempty"`
	AcknowledgedByBatchlog *bool  `thrift:"acknowledged_by_batchlog,2" json:"acknowledged_by_batchlog,omitempty"`
	PaxosInProgress        *bool  `thrift:"paxos_in_progress,3" json:"paxos_in_progress,omitempty"`
}

func NewTimedOutException() *TimedOutException {
	return &TimedOutException{}
}

var TimedOutException_AcknowledgedBy_DEFAULT int32

func (p *TimedOutException) GetAcknowledgedBy() int32 {
	if !p.IsSetAcknowledgedBy() {
		return TimedOutException_AcknowledgedBy_DEFAULT
	}
	return *p.AcknowledgedBy
}

var TimedOutException_AcknowledgedByBatchlog_DEFAULT bool

func (p *TimedOutException) GetAcknowledgedByBatchlog() bool {
	if !p.IsSetAcknowledgedByBatchlog() {
		return TimedOutException_AcknowledgedByBatchlog_DEFAULT
	}
	return *p.AcknowledgedByBatchlog
}

var TimedOutException_PaxosInProgress_DEFAULT bool

func (p *TimedOutException) GetPaxosInProgress() bool {
	if !p.IsSetPaxosInProgress() {
		return TimedOutException_PaxosInProgress_DEFAULT
	}
	return *p.PaxosInProgress
}
func (p *TimedOutException) IsSetAcknowledgedBy() bool {
	return p.AcknowledgedBy != nil
}

func (p *TimedOutException) IsSetAcknowledgedByBatchlog() bool {
	return p.AcknowledgedByBatchlog != nil
}

func (p *TimedOutException) IsSetPaxosInProgress() bool {
	return p.PaxosInProgress != nil
}

func (p *TimedOutException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *TimedOutException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AcknowledgedBy = &v
	}
	return nil
}

func (p *TimedOutException) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.AcknowledgedByBatchlog = &v
	}
	return nil
}

func (p *TimedOutException) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.PaxosInProgress = &v
	}
	return nil
}

func (p *TimedOutException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TimedOutException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TimedOutException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedBy() {
		if err := oprot.WriteFieldBegin("acknowledged_by", thrift.I32, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:acknowledged_by: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.AcknowledgedBy)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.acknowledged_by (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:acknowledged_by: ", p), err)
		}
	}
	return err
}

func (p *TimedOutException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedByBatchlog() {
		if err := oprot.WriteFieldBegin("acknowledged_by_batchlog", thrift.BOOL, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:acknowledged_by_batchlog: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.AcknowledgedByBatchlog)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.acknowledged_by_batchlog (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:acknowledged_by_batchlog: ", p), err)
		}
	}
	return err
}

func (p *TimedOutException) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetPaxosInProgress() {
		if err := oprot.WriteFieldBegin("paxos_in_progress", thrift.BOOL, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:paxos_in_progress: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.PaxosInProgress)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.paxos_in_progress (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:paxos_in_progress: ", p), err)
		}
	}
	return err
}

func (p *TimedOutException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TimedOutException(%+v)", *p)
}

func (p *TimedOutException) Error() string {
	return p.String()
}

// invalid authentication request (invalid keyspace, user does not exist, or credentials invalid)
//
// Attributes:
//  - Why
type AuthenticationException struct {
	Why string `thrift:"why,1,required" json:"why"`
}

func NewAuthenticationException() *AuthenticationException {
	return &AuthenticationException{}
}

func (p *AuthenticationException) GetWhy() string {
	return p.Why
}
func (p *AuthenticationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWhy bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetWhy = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWhy {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"))
	}
	return nil
}

func (p *AuthenticationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthenticationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuthenticationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err)
	}
	return err
}

func (p *AuthenticationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationException(%+v)", *p)
}

func (p *AuthenticationException) Error() string {
	return p.String()
}

// invalid authorization request (user does not have access to keyspace)
//
// Attributes:
//  - Why
type AuthorizationException struct {
	Why string `thrift:"why,1,required" json:"why"`
}

func NewAuthorizationException() *AuthorizationException {
	return &AuthorizationException{}
}

func (p *AuthorizationException) GetWhy() string {
	return p.Why
}
func (p *AuthorizationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWhy bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetWhy = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWhy {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Why is not set"))
	}
	return nil
}

func (p *AuthorizationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthorizationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthorizationException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuthorizationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:why: ", p), err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.why (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:why: ", p), err)
	}
	return err
}

func (p *AuthorizationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthorizationException(%+v)", *p)
}

func (p *AuthorizationException) Error() string {
	return p.String()
}

// NOTE: This up outdated exception left for backward compatibility reasons,
// no actual schema agreement validation is done starting from Cassandra 1.2
//
// schemas are not in agreement across all nodes
type SchemaDisagreementException struct {
}

func NewSchemaDisagreementException() *SchemaDisagreementException {
	return &SchemaDisagreementException{}
}

func (p *SchemaDisagreementException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SchemaDisagreementException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SchemaDisagreementException"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SchemaDisagreementException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaDisagreementException(%+v)", *p)
}

func (p *SchemaDisagreementException) Error() string {
	return p.String()
}

// ColumnParent is used when selecting groups of columns from the same ColumnFamily. In directory structure terms, imagine
// ColumnParent as ColumnPath + '/../'.
//
// See also <a href="cassandra.html#Struct_ColumnPath">ColumnPath</a>
//
// Attributes:
//  - ColumnFamily
//  - SuperColumn
type ColumnParent struct {
	// unused fields # 1 to 2
	ColumnFamily string `thrift:"column_family,3,required" json:"column_family"`
	SuperColumn  []byte `thrift:"super_column,4" json:"super_column,omitempty"`
}

func NewColumnParent() *ColumnParent {
	return &ColumnParent{}
}

func (p *ColumnParent) GetColumnFamily() string {
	return p.ColumnFamily
}

var ColumnParent_SuperColumn_DEFAULT []byte

func (p *ColumnParent) GetSuperColumn() []byte {
	return p.SuperColumn
}
func (p *ColumnParent) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnParent) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnFamily bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetColumnFamily = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"))
	}
	return nil
}

func (p *ColumnParent) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnParent) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnParent) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnParent"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ColumnParent) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_family: ", p), err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_family: ", p), err)
	}
	return err
}

func (p *ColumnParent) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuperColumn() {
		if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:super_column: ", p), err)
		}
		if err := oprot.WriteBinary(p.SuperColumn); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.super_column (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:super_column: ", p), err)
		}
	}
	return err
}

func (p *ColumnParent) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnParent(%+v)", *p)
}

// The ColumnPath is the path to a single column in Cassandra. It might make sense to think of ColumnPath and
// ColumnParent in terms of a directory structure.
//
// ColumnPath is used to looking up a single column.
//
// @param column_family. The name of the CF of the column being looked up.
// @param super_column. The super column name.
// @param column. The column name.
//
// Attributes:
//  - ColumnFamily
//  - SuperColumn
//  - Column
type ColumnPath struct {
	// unused fields # 1 to 2
	ColumnFamily string `thrift:"column_family,3,required" json:"column_family"`
	SuperColumn  []byte `thrift:"super_column,4" json:"super_column,omitempty"`
	Column       []byte `thrift:"column,5" json:"column,omitempty"`
}

func NewColumnPath() *ColumnPath {
	return &ColumnPath{}
}

func (p *ColumnPath) GetColumnFamily() string {
	return p.ColumnFamily
}

var ColumnPath_SuperColumn_DEFAULT []byte

func (p *ColumnPath) GetSuperColumn() []byte {
	return p.SuperColumn
}

var ColumnPath_Column_DEFAULT []byte

func (p *ColumnPath) GetColumn() []byte {
	return p.Column
}
func (p *ColumnPath) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnPath) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnPath) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnFamily bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetColumnFamily = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnFamily {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnFamily is not set"))
	}
	return nil
}

func (p *ColumnPath) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnPath) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnPath) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Column = v
	}
	return nil
}

func (p *ColumnPath) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnPath"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ColumnPath) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_family: ", p), err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_family (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_family: ", p), err)
	}
	return err
}

func (p *ColumnPath) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuperColumn() {
		if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:super_column: ", p), err)
		}
		if err := oprot.WriteBinary(p.SuperColumn); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.super_column (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:super_column: ", p), err)
		}
	}
	return err
}

func (p *ColumnPath) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumn() {
		if err := oprot.WriteFieldBegin("column", thrift.STRING, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:column: ", p), err)
		}
		if err := oprot.WriteBinary(p.Column); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.column (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:column: ", p), err)
		}
	}
	return err
}

func (p *ColumnPath) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnPath(%+v)", *p)
}

// A slice range is a structure that stores basic range, ordering and limit information for a query that will return
// multiple columns. It could be thought of as Cassandra's version of LIMIT and ORDER BY
//
// @param start. The column name to start the slice with. This attribute is not required, though there is no default value,
//               and can be safely set to '', i.e., an empty byte array, to start with the first column name. Otherwise, it
//               must a valid value under the rules of the Comparator defined for the given ColumnFamily.
// @param finish. The column name to stop the slice at. This attribute is not required, though there is no default value,
//                and can be safely set to an empty byte array to not stop until 'count' results are seen. Otherwise, it
//                must also be a valid value to the ColumnFamily Comparator.
// @param reversed. Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
// @param count. How many columns to return. Similar to LIMIT in SQL. May be arbitrarily large, but Thrift will
//               materialize the whole result into memory before returning it to the client, so be aware that you may
//               be better served by iterating through slices by passing the last value of one call in as the 'start'
//               of the next instead of increasing 'count' arbitrarily large.
//
// Attributes:
//  - Start
//  - Finish
//  - Reversed
//  - Count
type SliceRange struct {
	Start    []byte `thrift:"start,1,required" json:"start"`
	Finish   []byte `thrift:"finish,2,required" json:"finish"`
	Reversed bool   `thrift:"reversed,3,required" json:"reversed"`
	Count    int32  `thrift:"count,4,required" json:"count"`
}

func NewSliceRange() *SliceRange {
	return &SliceRange{
		Count: 100,
	}
}

func (p *SliceRange) GetStart() []byte {
	return p.Start
}

func (p *SliceRange) GetFinish() []byte {
	return p.Finish
}

func (p *SliceRange) GetReversed() bool {
	return p.Reversed
}

func (p *SliceRange) GetCount() int32 {
	return p.Count
}
func (p *SliceRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetStart bool = false
	var issetFinish bool = false
	var issetReversed bool = false
	var issetCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetStart = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetFinish = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetReversed = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetCount = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetStart {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Start is not set"))
	}
	if !issetFinish {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Finish is not set"))
	}
	if !issetReversed {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Reversed is not set"))
	}
	if !issetCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"))
	}
	return nil
}

func (p *SliceRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *SliceRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Finish = v
	}
	return nil
}

func (p *SliceRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Reversed = v
	}
	return nil
}

func (p *SliceRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *SliceRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SliceRange"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SliceRange) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err)
	}
	if err := oprot.WriteBinary(p.Start); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err)
	}
	return err
}

func (p *SliceRange) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finish: ", p), err)
	}
	if err := oprot.WriteBinary(p.Finish); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.finish (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finish: ", p), err)
	}
	return err
}

func (p *SliceRange) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:reversed: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.reversed (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:reversed: ", p), err)
	}
	return err
}

func (p *SliceRange) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:count: ", p), err)
	}
	return err
}

func (p *SliceRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SliceRange(%+v)", *p)
}

// A SlicePredicate is similar to a mathematic predicate (see http://en.wikipedia.org/wiki/Predicate_(mathematical_logic)),
// which is described as "a property that the elements of a set have in common."
//
// SlicePredicate's in Cassandra are described with either a list of column_names or a SliceRange.  If column_names is
// specified, slice_range is ignored.
//
// @param column_name. A list of column names to retrieve. This can be used similar to Memcached's "multi-get" feature
//                     to fetch N known column names. For instance, if you know you wish to fetch columns 'Joe', 'Jack',
//                     and 'Jim' you can pass those column names as a list to fetch all three at once.
// @param slice_range. A SliceRange describing how to range, order, and/or limit the slice.
//
// Attributes:
//  - ColumnNames
//  - SliceRange
type SlicePredicate struct {
	ColumnNames [][]byte    `thrift:"column_names,1" json:"column_names,omitempty"`
	SliceRange  *SliceRange `thrift:"slice_range,2" json:"slice_range,omitempty"`
}

func NewSlicePredicate() *SlicePredicate {
	return &SlicePredicate{}
}

var SlicePredicate_ColumnNames_DEFAULT [][]byte

func (p *SlicePredicate) GetColumnNames() [][]byte {
	return p.ColumnNames
}

var SlicePredicate_SliceRange_DEFAULT *SliceRange

func (p *SlicePredicate) GetSliceRange() *SliceRange {
	if !p.IsSetSliceRange() {
		return SlicePredicate_SliceRange_DEFAULT
	}
	return p.SliceRange
}
func (p *SlicePredicate) IsSetColumnNames() bool {
	return p.ColumnNames != nil
}

func (p *SlicePredicate) IsSetSliceRange() bool {
	return p.SliceRange != nil
}

func (p *SlicePredicate) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SlicePredicate) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.ColumnNames = tSlice
	for i := 0; i < size; i++ {
		var _elem2 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem2 = v
		}
		p.ColumnNames = append(p.ColumnNames, _elem2)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SlicePredicate) readField2(iprot thrift.TProtocol) error {
	p.SliceRange = &SliceRange{
		Count: 100,
	}
	if err := p.SliceRange.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SliceRange), err)
	}
	return nil
}

func (p *SlicePredicate) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SlicePredicate"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SlicePredicate) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnNames() {
		if err := oprot.WriteFieldBegin("column_names", thrift.LIST, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_names: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.ColumnNames)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.ColumnNames {
			if err := oprot.WriteBinary(v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_names: ", p), err)
		}
	}
	return err
}

func (p *SlicePredicate) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSliceRange() {
		if err := oprot.WriteFieldBegin("slice_range", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:slice_range: ", p), err)
		}
		if err := p.SliceRange.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SliceRange), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:slice_range: ", p), err)
		}
	}
	return err
}

func (p *SlicePredicate) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SlicePredicate(%+v)", *p)
}

// Attributes:
//  - ColumnName
//  - Op
//  - Value
type IndexExpression struct {
	ColumnName []byte        `thrift:"column_name,1,required" json:"column_name"`
	Op         IndexOperator `thrift:"op,2,required" json:"op"`
	Value      []byte        `thrift:"value,3,required" json:"value"`
}

func NewIndexExpression() *IndexExpression {
	return &IndexExpression{}
}

func (p *IndexExpression) GetColumnName() []byte {
	return p.ColumnName
}

func (p *IndexExpression) GetOp() IndexOperator {
	return p.Op
}

func (p *IndexExpression) GetValue() []byte {
	return p.Value
}
func (p *IndexExpression) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetColumnName bool = false
	var issetOp bool = false
	var issetValue bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetColumnName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetOp = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetValue = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetColumnName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ColumnName is not set"))
	}
	if !issetOp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Op is not set"))
	}
	if !issetValue {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"))
	}
	return nil
}

func (p *IndexExpression) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ColumnName = v
	}
	return nil
}

func (p *IndexExpression) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := IndexOperator(v)
		p.Op = temp
	}
	return nil
}

func (p *IndexExpression) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *IndexExpression) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexExpression"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *IndexExpression) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_name: ", p), err)
	}
	if err := oprot.WriteBinary(p.ColumnName); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.column_name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_name: ", p), err)
	}
	return err
}

func (p *IndexExpression) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *IndexExpression) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:value: ", p), err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:value: ", p), err)
	}
	return err
}

func (p *IndexExpression) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexExpression(%+v)", *p)
}

// @deprecated use a KeyRange with row_filter in get_range_slices instead
//
// Attributes:
//  - Expressions
//  - StartKey
//  - Count
type IndexClause struct {
	Expressions []*IndexExpression `thrift:"expressions,1,required" json:"expressions"`
	StartKey    []byte             `thrift:"start_key,2,required" json:"start_key"`
	Count       int32              `thrift:"count,3,required" json:"count"`
}

func NewIndexClause() *IndexClause {
	return &IndexClause{
		Count: 100,
	}
}

func (p *IndexClause) GetExpressions() []*IndexExpression {
	return p.Expressions
}

func (p *IndexClause) GetStartKey() []byte {
	return p.StartKey
}

func (p *IndexClause) GetCount() int32 {
	return p.Count
}
func (p *IndexClause) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetExpressions bool = false
	var issetStartKey bool = false
	var issetCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetExpressions = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetStartKey = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetCount = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetExpressions {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Expressions is not set"))
	}
	if !issetStartKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartKey is not set"))
	}
	if !issetCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"))
	}
	return nil
}

func (p *IndexClause) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*IndexExpression, 0, size)
	p.Expressions = tSlice
	for i := 0; i < size; i++ {
		_elem3 := &IndexExpression{}
		if err := _elem3.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem3), err)
		}
		p.Expressions = append(p.Expressions, _elem3)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *IndexClause) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *IndexClause) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *IndexClause) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexClause"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *IndexClause) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("expressions", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:expressions: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expressions)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Expressions {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:expressions: ", p), err)
	}
	return err
}

func (p *IndexClause) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start_key: ", p), err)
	}
	if err := oprot.WriteBinary(p.StartKey); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_key (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start_key: ", p), err)
	}
	return err
}

func (p *IndexClause) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:count: ", p), err)
	}
	return err
}

func (p *IndexClause) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexClause(%+v)", *p)
}

// The semantics of start keys and tokens are slightly different.
// Keys are start-inclusive; tokens are start-exclusive.  Token
// ranges may also wrap -- that is, the end token may be less
// than the start one.  Thus, a range from keyX to keyX is a
// one-element range, but a range from tokenY to tokenY is the
// full ring.
//
// Attributes:
//  - StartKey
//  - EndKey
//  - StartToken
//  - EndToken
//  - RowFilter
//  - Count
type KeyRange struct {
	StartKey   []byte             `thrift:"start_key,1" json:"start_key,omitempty"`
	EndKey     []byte             `thrift:"end_key,2" json:"end_key,omitempty"`
	StartToken *string            `thrift:"start_token,3" json:"start_token,omitempty"`
	EndToken   *string            `thrift:"end_token,4" json:"end_token,omitempty"`
	Count      int32              `thrift:"count,5,required" json:"count"`
	RowFilter  []*IndexExpression `thrift:"row_filter,6" json:"row_filter,omitempty"`
}

func NewKeyRange() *KeyRange {
	return &KeyRange{
		Count: 100,
	}
}

var KeyRange_StartKey_DEFAULT []byte

func (p *KeyRange) GetStartKey() []byte {
	return p.StartKey
}

var KeyRange_EndKey_DEFAULT []byte

func (p *KeyRange) GetEndKey() []byte {
	return p.EndKey
}

var KeyRange_StartToken_DEFAULT string

func (p *KeyRange) GetStartToken() string {
	if !p.IsSetStartToken() {
		return KeyRange_StartToken_DEFAULT
	}
	return *p.StartToken
}

var KeyRange_EndToken_DEFAULT string

func (p *KeyRange) GetEndToken() string {
	if !p.IsSetEndToken() {
		return KeyRange_EndToken_DEFAULT
	}
	return *p.EndToken
}

var KeyRange_RowFilter_DEFAULT []*IndexExpression

func (p *KeyRange) GetRowFilter() []*IndexExpression {
	return p.RowFilter
}

func (p *KeyRange) GetCount() int32 {
	return p.Count
}
func (p *KeyRange) IsSetStartKey() bool {
	return p.StartKey != nil
}

func (p *KeyRange) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *KeyRange) IsSetStartToken() bool {
	return p.StartToken != nil
}

func (p *KeyRange) IsSetEndToken() bool {
	return p.EndToken != nil
}

func (p *KeyRange) IsSetRowFilter() bool {
	return p.RowFilter != nil
}

func (p *KeyRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
			issetCount = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"))
	}
	return nil
}

func (p *KeyRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *KeyRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EndKey = v
	}
	return nil
}

func (p *KeyRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.StartToken = &v
	}
	return nil
}

func (p *KeyRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.EndToken = &v
	}
	return nil
}

func (p *KeyRange) readField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*IndexExpression, 0, size)
	p.RowFilter = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &IndexExpression{}
		if err := _elem4.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.RowFilter = append(p.RowFilter, _elem4)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *KeyRange) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyRange"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KeyRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetStartKey() {
		if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_key: ", p), err)
		}
		if err := oprot.WriteBinary(p.StartKey); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.start_key (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_key: ", p), err)
		}
	}
	return err
}

func (p *KeyRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndKey() {
		if err := oprot.WriteFieldBegin("end_key", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_key: ", p), err)
		}
		if err := oprot.WriteBinary(p.EndKey); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.end_key (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_key: ", p), err)
		}
	}
	return err
}

func (p *KeyRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetStartToken() {
		if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:start_token: ", p), err)
		}
		if err := oprot.WriteString(string(*p.StartToken)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.start_token (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:start_token: ", p), err)
		}
	}
	return err
}

func (p *KeyRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndToken() {
		if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:end_token: ", p), err)
		}
		if err := oprot.WriteString(string(*p.EndToken)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.end_token (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:end_token: ", p), err)
		}
	}
	return err
}

func (p *KeyRange) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:count: ", p), err)
	}
	return err
}

func (p *KeyRange) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowFilter() {
		if err := oprot.WriteFieldBegin("row_filter", thrift.LIST, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:row_filter: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowFilter)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.RowFilter {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:row_filter: ", p), err)
		}
	}
	return err
}

func (p *KeyRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyRange(%+v)", *p)
}

// A KeySlice is key followed by the data it maps to. A collection of KeySlice is returned by the get_range_slice operation.
//
// @param key. a row key
// @param columns. List of data represented by the key. Typically, the list is pared down to only the columns specified by
//                 a SlicePredicate.
//
// Attributes:
//  - Key
//  - Columns
type KeySlice struct {
	Key     []byte                 `thrift:"key,1,required" json:"key"`
	Columns []*ColumnOrSuperColumn `thrift:"columns,2,required" json:"columns"`
}

func NewKeySlice() *KeySlice {
	return &KeySlice{}
}

func (p *KeySlice) GetKey() []byte {
	return p.Key
}

func (p *KeySlice) GetColumns() []*ColumnOrSuperColumn {
	return p.Columns
}
func (p *KeySlice) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumns = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *KeySlice) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeySlice) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem5 := &ColumnOrSuperColumn{}
		if err := _elem5.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem5), err)
		}
		p.Columns = append(p.Columns, _elem5)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *KeySlice) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeySlice"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KeySlice) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *KeySlice) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *KeySlice) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeySlice(%+v)", *p)
}

// Attributes:
//  - Key
//  - Count
type KeyCount struct {
	Key   []byte `thrift:"key,1,required" json:"key"`
	Count int32  `thrift:"count,2,required" json:"count"`
}

func NewKeyCount() *KeyCount {
	return &KeyCount{}
}

func (p *KeyCount) GetKey() []byte {
	return p.Key
}

func (p *KeyCount) GetCount() int32 {
	return p.Count
}
func (p *KeyCount) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCount = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"))
	}
	return nil
}

func (p *KeyCount) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeyCount) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyCount) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyCount"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KeyCount) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *KeyCount) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:count: ", p), err)
	}
	return err
}

func (p *KeyCount) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyCount(%+v)", *p)
}

// Note that the timestamp is only optional in case of counter deletion.
//
// Attributes:
//  - Timestamp
//  - SuperColumn
//  - Predicate
type Deletion struct {
	Timestamp   *int64          `thrift:"timestamp,1" json:"timestamp,omitempty"`
	SuperColumn []byte          `thrift:"super_column,2" json:"super_column,omitempty"`
	Predicate   *SlicePredicate `thrift:"predicate,3" json:"predicate,omitempty"`
}

func NewDeletion() *Deletion {
	return &Deletion{}
}

var Deletion_Timestamp_DEFAULT int64

func (p *Deletion) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return Deletion_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var Deletion_SuperColumn_DEFAULT []byte

func (p *Deletion) GetSuperColumn() []byte {
	return p.SuperColumn
}

var Deletion_Predicate_DEFAULT *SlicePredicate

func (p *Deletion) GetPredicate() *SlicePredicate {
	if !p.IsSetPredicate() {
		return Deletion_Predicate_DEFAULT
	}
	return p.Predicate
}
func (p *Deletion) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Deletion) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *Deletion) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *Deletion) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Deletion) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Deletion) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *Deletion) readField3(iprot thrift.TProtocol) error {
	p.Predicate = &SlicePredicate{}
	if err := p.Predicate.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Predicate), err)
	}
	return nil
}

func (p *Deletion) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Deletion"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Deletion) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timestamp: ", p), err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestamp (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timestamp: ", p), err)
		}
	}
	return err
}

func (p *Deletion) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuperColumn() {
		if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:super_column: ", p), err)
		}
		if err := oprot.WriteBinary(p.SuperColumn); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.super_column (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:super_column: ", p), err)
		}
	}
	return err
}

func (p *Deletion) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetPredicate() {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:predicate: ", p), err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Predicate), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:predicate: ", p), err)
		}
	}
	return err
}

func (p *Deletion) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Deletion(%+v)", *p)
}

// A Mutation is either an insert (represented by filling column_or_supercolumn) or a deletion (represented by filling the deletion attribute).
// @param column_or_supercolumn. An insert to a column or supercolumn (possibly counter column or supercolumn)
// @param deletion. A deletion of a column or supercolumn
//
// Attributes:
//  - ColumnOrSupercolumn
//  - Deletion
type Mutation struct {
	ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"column_or_supercolumn,1" json:"column_or_supercolumn,omitempty"`
	Deletion            *Deletion            `thrift:"deletion,2" json:"deletion,omitempty"`
}

func NewMutation() *Mutation {
	return &Mutation{}
}

var Mutation_ColumnOrSupercolumn_DEFAULT *ColumnOrSuperColumn

func (p *Mutation) GetColumnOrSupercolumn() *ColumnOrSuperColumn {
	if !p.IsSetColumnOrSupercolumn() {
		return Mutation_ColumnOrSupercolumn_DEFAULT
	}
	return p.ColumnOrSupercolumn
}

var Mutation_Deletion_DEFAULT *Deletion

func (p *Mutation) GetDeletion() *Deletion {
	if !p.IsSetDeletion() {
		return Mutation_Deletion_DEFAULT
	}
	return p.Deletion
}
func (p *Mutation) IsSetColumnOrSupercolumn() bool {
	return p.ColumnOrSupercolumn != nil
}

func (p *Mutation) IsSetDeletion() bool {
	return p.Deletion != nil
}

func (p *Mutation) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Mutation) readField1(iprot thrift.TProtocol) error {
	p.ColumnOrSupercolumn = &ColumnOrSuperColumn{}
	if err := p.ColumnOrSupercolumn.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ColumnOrSupercolumn), err)
	}
	return nil
}

func (p *Mutation) readField2(iprot thrift.TProtocol) error {
	p.Deletion = &Deletion{}
	if err := p.Deletion.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Deletion), err)
	}
	return nil
}

func (p *Mutation) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Mutation"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Mutation) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnOrSupercolumn() {
		if err := oprot.WriteFieldBegin("column_or_supercolumn", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:column_or_supercolumn: ", p), err)
		}
		if err := p.ColumnOrSupercolumn.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ColumnOrSupercolumn), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:column_or_supercolumn: ", p), err)
		}
	}
	return err
}

func (p *Mutation) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetDeletion() {
		if err := oprot.WriteFieldBegin("deletion", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:deletion: ", p), err)
		}
		if err := p.Deletion.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Deletion), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:deletion: ", p), err)
		}
	}
	return err
}

func (p *Mutation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Mutation(%+v)", *p)
}

// Attributes:
//  - Host
//  - Datacenter
//  - Rack
type EndpointDetails struct {
	Host       string  `thrift:"host,1" json:"host"`
	Datacenter string  `thrift:"datacenter,2" json:"datacenter"`
	Rack       *string `thrift:"rack,3" json:"rack,omitempty"`
}

func NewEndpointDetails() *EndpointDetails {
	return &EndpointDetails{}
}

func (p *EndpointDetails) GetHost() string {
	return p.Host
}

func (p *EndpointDetails) GetDatacenter() string {
	return p.Datacenter
}

var EndpointDetails_Rack_DEFAULT string

func (p *EndpointDetails) GetRack() string {
	if !p.IsSetRack() {
		return EndpointDetails_Rack_DEFAULT
	}
	return *p.Rack
}
func (p *EndpointDetails) IsSetRack() bool {
	return p.Rack != nil
}

func (p *EndpointDetails) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *EndpointDetails) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Host = v
	}
	return nil
}

func (p *EndpointDetails) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Datacenter = v
	}
	return nil
}

func (p *EndpointDetails) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Rack = &v
	}
	return nil
}

func (p *EndpointDetails) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EndpointDetails"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *EndpointDetails) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:host: ", p), err)
	}
	if err := oprot.WriteString(string(p.Host)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.host (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:host: ", p), err)
	}
	return err
}

func (p *EndpointDetails) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datacenter", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:datacenter: ", p), err)
	}
	if err := oprot.WriteString(string(p.Datacenter)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.datacenter (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:datacenter: ", p), err)
	}
	return err
}

func (p *EndpointDetails) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRack() {
		if err := oprot.WriteFieldBegin("rack", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rack: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Rack)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rack (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rack: ", p), err)
		}
	}
	return err
}

func (p *EndpointDetails) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EndpointDetails(%+v)", *p)
}

// Attributes:
//  - Success
//  - CurrentValues
type CASResult_ struct {
	Success       bool      `thrift:"success,1,required" json:"success"`
	CurrentValues []*Column `thrift:"current_values,2" json:"current_values,omitempty"`
}

func NewCASResult_() *CASResult_ {
	return &CASResult_{}
}

func (p *CASResult_) GetSuccess() bool {
	return p.Success
}

var CASResult__CurrentValues_DEFAULT []*Column

func (p *CASResult_) GetCurrentValues() []*Column {
	return p.CurrentValues
}
func (p *CASResult_) IsSetCurrentValues() bool {
	return p.CurrentValues != nil
}

func (p *CASResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetSuccess bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetSuccess = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetSuccess {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Success is not set"))
	}
	return nil
}

func (p *CASResult_) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Success = v
	}
	return nil
}

func (p *CASResult_) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Column, 0, size)
	p.CurrentValues = tSlice
	for i := 0; i < size; i++ {
		_elem6 := &Column{}
		if err := _elem6.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem6), err)
		}
		p.CurrentValues = append(p.CurrentValues, _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CASResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CASResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CASResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:success: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.Success)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.success (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:success: ", p), err)
	}
	return err
}

func (p *CASResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetCurrentValues() {
		if err := oprot.WriteFieldBegin("current_values", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:current_values: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CurrentValues)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.CurrentValues {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:current_values: ", p), err)
		}
	}
	return err
}

func (p *CASResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CASResult_(%+v)", *p)
}

// A TokenRange describes part of the Cassandra ring, it is a mapping from a range to
// endpoints responsible for that range.
// @param start_token The first token in the range
// @param end_token The last token in the range
// @param endpoints The endpoints responsible for the range (listed by their configured listen_address)
// @param rpc_endpoints The endpoints responsible for the range (listed by their configured rpc_address)
//
// Attributes:
//  - StartToken
//  - EndToken
//  - Endpoints
//  - RPCEndpoints
//  - EndpointDetails
type TokenRange struct {
	StartToken      string             `thrift:"start_token,1,required" json:"start_token"`
	EndToken        string             `thrift:"end_token,2,required" json:"end_token"`
	Endpoints       []string           `thrift:"endpoints,3,required" json:"endpoints"`
	RPCEndpoints    []string           `thrift:"rpc_endpoints,4" json:"rpc_endpoints,omitempty"`
	EndpointDetails []*EndpointDetails `thrift:"endpoint_details,5" json:"endpoint_details,omitempty"`
}

func NewTokenRange() *TokenRange {
	return &TokenRange{}
}

func (p *TokenRange) GetStartToken() string {
	return p.StartToken
}

func (p *TokenRange) GetEndToken() string {
	return p.EndToken
}

func (p *TokenRange) GetEndpoints() []string {
	return p.Endpoints
}

var TokenRange_RPCEndpoints_DEFAULT []string

func (p *TokenRange) GetRPCEndpoints() []string {
	return p.RPCEndpoints
}

var TokenRange_EndpointDetails_DEFAULT []*EndpointDetails

func (p *TokenRange) GetEndpointDetails() []*EndpointDetails {
	return p.EndpointDetails
}
func (p *TokenRange) IsSetRPCEndpoints() bool {
	return p.RPCEndpoints != nil
}

func (p *TokenRange) IsSetEndpointDetails() bool {
	return p.EndpointDetails != nil
}

func (p *TokenRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetStartToken bool = false
	var issetEndToken bool = false
	var issetEndpoints bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetStartToken = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetEndToken = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetEndpoints = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetStartToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"))
	}
	if !issetEndToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"))
	}
	if !issetEndpoints {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Endpoints is not set"))
	}
	return nil
}

func (p *TokenRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *TokenRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *TokenRange) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.Endpoints = tSlice
	for i := 0; i < size; i++ {
		var _elem7 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem7 = v
		}
		p.Endpoints = append(p.Endpoints, _elem7)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TokenRange) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.RPCEndpoints = tSlice
	for i := 0; i < size; i++ {
		var _elem8 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem8 = v
		}
		p.RPCEndpoints = append(p.RPCEndpoints, _elem8)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TokenRange) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*EndpointDetails, 0, size)
	p.EndpointDetails = tSlice
	for i := 0; i < size; i++ {
		_elem9 := &EndpointDetails{}
		if err := _elem9.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
		}
		p.EndpointDetails = append(p.EndpointDetails, _elem9)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *TokenRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TokenRange"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TokenRange) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_token (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_token: ", p), err)
	}
	return err
}

func (p *TokenRange) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.end_token (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_token: ", p), err)
	}
	return err
}

func (p *TokenRange) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("endpoints", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:endpoints: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Endpoints)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Endpoints {
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:endpoints: ", p), err)
	}
	return err
}

func (p *TokenRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetRPCEndpoints() {
		if err := oprot.WriteFieldBegin("rpc_endpoints", thrift.LIST, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rpc_endpoints: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.RPCEndpoints)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.RPCEndpoints {
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rpc_endpoints: ", p), err)
		}
	}
	return err
}

func (p *TokenRange) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndpointDetails() {
		if err := oprot.WriteFieldBegin("endpoint_details", thrift.LIST, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:endpoint_details: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.EndpointDetails)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.EndpointDetails {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:endpoint_details: ", p), err)
		}
	}
	return err
}

func (p *TokenRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TokenRange(%+v)", *p)
}

// Authentication requests can contain any data, dependent on the IAuthenticator used
//
// Attributes:
//  - Credentials
type AuthenticationRequest struct {
	Credentials map[string]string `thrift:"credentials,1,required" json:"credentials"`
}

func NewAuthenticationRequest() *AuthenticationRequest {
	return &AuthenticationRequest{}
}

func (p *AuthenticationRequest) GetCredentials() map[string]string {
	return p.Credentials
}
func (p *AuthenticationRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetCredentials bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetCredentials = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetCredentials {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Credentials is not set"))
	}
	return nil
}

func (p *AuthenticationRequest) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Credentials = tMap
	for i := 0; i < size; i++ {
		var _key10 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key10 = v
		}
		var _val11 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val11 = v
		}
		p.Credentials[_key10] = _val11
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *AuthenticationRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AuthenticationRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("credentials", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:credentials: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Credentials)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.Credentials {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:credentials: ", p), err)
	}
	return err
}

func (p *AuthenticationRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationRequest(%+v)", *p)
}

// Attributes:
//  - Name
//  - ValidationClass
//  - IndexType
//  - IndexName
//  - IndexOptions
type ColumnDef struct {
	Name            []byte            `thrift:"name,1,required" json:"name"`
	ValidationClass string            `thrift:"validation_class,2,required" json:"validation_class"`
	IndexType       *IndexType        `thrift:"index_type,3" json:"index_type,omitempty"`
	IndexName       *string           `thrift:"index_name,4" json:"index_name,omitempty"`
	IndexOptions    map[string]string `thrift:"index_options,5" json:"index_options,omitempty"`
}

func NewColumnDef() *ColumnDef {
	return &ColumnDef{}
}

func (p *ColumnDef) GetName() []byte {
	return p.Name
}

func (p *ColumnDef) GetValidationClass() string {
	return p.ValidationClass
}

var ColumnDef_IndexType_DEFAULT IndexType

func (p *ColumnDef) GetIndexType() IndexType {
	if !p.IsSetIndexType() {
		return ColumnDef_IndexType_DEFAULT
	}
	return *p.IndexType
}

var ColumnDef_IndexName_DEFAULT string

func (p *ColumnDef) GetIndexName() string {
	if !p.IsSetIndexName() {
		return ColumnDef_IndexName_DEFAULT
	}
	return *p.IndexName
}

var ColumnDef_IndexOptions_DEFAULT map[string]string

func (p *ColumnDef) GetIndexOptions() map[string]string {
	return p.IndexOptions
}
func (p *ColumnDef) IsSetIndexType() bool {
	return p.IndexType != nil
}

func (p *ColumnDef) IsSetIndexName() bool {
	return p.IndexName != nil
}

func (p *ColumnDef) IsSetIndexOptions() bool {
	return p.IndexOptions != nil
}

func (p *ColumnDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetValidationClass bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetValidationClass = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetValidationClass {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ValidationClass is not set"))
	}
	return nil
}

func (p *ColumnDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *ColumnDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ValidationClass = v
	}
	return nil
}

func (p *ColumnDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := IndexType(v)
		p.IndexType = &temp
	}
	return nil
}

func (p *ColumnDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.IndexName = &v
	}
	return nil
}

func (p *ColumnDef) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.IndexOptions = tMap
	for i := 0; i < size; i++ {
		var _key12 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key12 = v
		}
		var _val13 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val13 = v
		}
		p.IndexOptions[_key12] = _val13
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *ColumnDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnDef"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ColumnDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteBinary(p.Name); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *ColumnDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("validation_class", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:validation_class: ", p), err)
	}
	if err := oprot.WriteString(string(p.ValidationClass)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.validation_class (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:validation_class: ", p), err)
	}
	return err
}

func (p *ColumnDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexType() {
		if err := oprot.WriteFieldBegin("index_type", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:index_type: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.IndexType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.index_type (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:index_type: ", p), err)
		}
	}
	return err
}

func (p *ColumnDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexName() {
		if err := oprot.WriteFieldBegin("index_name", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:index_name: ", p), err)
		}
		if err := oprot.WriteString(string(*p.IndexName)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.index_name (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:index_name: ", p), err)
		}
	}
	return err
}

func (p *ColumnDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexOptions() {
		if err := oprot.WriteFieldBegin("index_options", thrift.MAP, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:index_options: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.IndexOptions)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.IndexOptions {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:index_options: ", p), err)
		}
	}
	return err
}

func (p *ColumnDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnDef(%+v)", *p)
}

// Describes a trigger.
// `options` should include at least 'class' param.
// Other options are not supported yet.
//
// Attributes:
//  - Name
//  - Options
type TriggerDef struct {
	Name    string            `thrift:"name,1,required" json:"name"`
	Options map[string]string `thrift:"options,2,required" json:"options"`
}

func NewTriggerDef() *TriggerDef {
	return &TriggerDef{}
}

func (p *TriggerDef) GetName() string {
	return p.Name
}

func (p *TriggerDef) GetOptions() map[string]string {
	return p.Options
}
func (p *TriggerDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetOptions bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetOptions = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetOptions {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Options is not set"))
	}
	return nil
}

func (p *TriggerDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *TriggerDef) readField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Options = tMap
	for i := 0; i < size; i++ {
		var _key14 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key14 = v
		}
		var _val15 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val15 = v
		}
		p.Options[_key14] = _val15
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *TriggerDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TriggerDef"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TriggerDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *TriggerDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("options", thrift.MAP, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:options: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Options)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.Options {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:options: ", p), err)
	}
	return err
}

func (p *TriggerDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TriggerDef(%+v)", *p)
}

// Attributes:
//  - Keyspace
//  - Name
//  - ColumnType
//  - ComparatorType
//  - SubcomparatorType
//  - Comment
//  - ReadRepairChance
//  - ColumnMetadata
//  - GcGraceSeconds
//  - DefaultValidationClass
//  - ID
//  - MinCompactionThreshold
//  - MaxCompactionThreshold
//  - ReplicateOnWrite
//  - KeyValidationClass
//  - KeyAlias
//  - CompactionStrategy
//  - CompactionStrategyOptions
//  - CompressionOptions
//  - BloomFilterFpChance
//  - Caching
//  - DclocalReadRepairChance
//  - PopulateIoCacheOnFlush
//  - MemtableFlushPeriodInMs
//  - DefaultTimeToLive
//  - IndexInterval
//  - SpeculativeRetry
//  - Triggers
//  - RowCacheSize: @deprecated
//  - KeyCacheSize: @deprecated
//  - RowCacheSavePeriodInSeconds: @deprecated
//  - KeyCacheSavePeriodInSeconds: @deprecated
//  - MemtableFlushAfterMins: @deprecated
//  - MemtableThroughputInMb: @deprecated
//  - MemtableOperationsInMillions: @deprecated
//  - MergeShardsChance: @deprecated
//  - RowCacheProvider: @deprecated
//  - RowCacheKeysToSave: @deprecated
type CfDef struct {
	Keyspace   string `thrift:"keyspace,1,required" json:"keyspace"`
	Name       string `thrift:"name,2,required" json:"name"`
	ColumnType string `thrift:"column_type,3" json:"column_type,omitempty"`
	// unused field # 4
	ComparatorType    string  `thrift:"comparator_type,5" json:"comparator_type,omitempty"`
	SubcomparatorType *string `thrift:"subcomparator_type,6" json:"subcomparator_type,omitempty"`
	// unused field # 7
	Comment      *string  `thrift:"comment,8" json:"comment,omitempty"`
	RowCacheSize *float64 `thrift:"row_cache_size,9" json:"row_cache_size,omitempty"`
	// unused field # 10
	KeyCacheSize                 *float64          `thrift:"key_cache_size,11" json:"key_cache_size,omitempty"`
	ReadRepairChance             *float64          `thrift:"read_repair_chance,12" json:"read_repair_chance,omitempty"`
	ColumnMetadata               []*ColumnDef      `thrift:"column_metadata,13" json:"column_metadata,omitempty"`
	GcGraceSeconds               *int32            `thrift:"gc_grace_seconds,14" json:"gc_grace_seconds,omitempty"`
	DefaultValidationClass       *string           `thrift:"default_validation_class,15" json:"default_validation_class,omitempty"`
	ID                           *int32            `thrift:"id,16" json:"id,omitempty"`
	MinCompactionThreshold       *int32            `thrift:"min_compaction_threshold,17" json:"min_compaction_threshold,omitempty"`
	MaxCompactionThreshold       *int32            `thrift:"max_compaction_threshold,18" json:"max_compaction_threshold,omitempty"`
	RowCacheSavePeriodInSeconds  *int32            `thrift:"row_cache_save_period_in_seconds,19" json:"row_cache_save_period_in_seconds,omitempty"`
	KeyCacheSavePeriodInSeconds  *int32            `thrift:"key_cache_save_period_in_seconds,20" json:"key_cache_save_period_in_seconds,omitempty"`
	MemtableFlushAfterMins       *int32            `thrift:"memtable_flush_after_mins,21" json:"memtable_flush_after_mins,omitempty"`
	MemtableThroughputInMb       *int32            `thrift:"memtable_throughput_in_mb,22" json:"memtable_throughput_in_mb,omitempty"`
	MemtableOperationsInMillions *float64          `thrift:"memtable_operations_in_millions,23" json:"memtable_operations_in_millions,omitempty"`
	ReplicateOnWrite             *bool             `thrift:"replicate_on_write,24" json:"replicate_on_write,omitempty"`
	MergeShardsChance            *float64          `thrift:"merge_shards_chance,25" json:"merge_shards_chance,omitempty"`
	KeyValidationClass           *string           `thrift:"key_validation_class,26" json:"key_validation_class,omitempty"`
	RowCacheProvider             *string           `thrift:"row_cache_provider,27" json:"row_cache_provider,omitempty"`
	KeyAlias                     []byte            `thrift:"key_alias,28" json:"key_alias,omitempty"`
	CompactionStrategy           *string           `thrift:"compaction_strategy,29" json:"compaction_strategy,omitempty"`
	CompactionStrategyOptions    map[string]string `thrift:"compaction_strategy_options,30" json:"compaction_strategy_options,omitempty"`
	RowCacheKeysToSave           *int32            `thrift:"row_cache_keys_to_save,31" json:"row_cache_keys_to_save,omitempty"`
	CompressionOptions           map[string]string `thrift:"compression_options,32" json:"compression_options,omitempty"`
	BloomFilterFpChance          *float64          `thrift:"bloom_filter_fp_chance,33" json:"bloom_filter_fp_chance,omitempty"`
	Caching                      string            `thrift:"caching,34" json:"caching,omitempty"`
	// unused fields # 35 to 36
	DclocalReadRepairChance float64       `thrift:"dclocal_read_repair_chance,37" json:"dclocal_read_repair_chance,omitempty"`
	PopulateIoCacheOnFlush  *bool         `thrift:"populate_io_cache_on_flush,38" json:"populate_io_cache_on_flush,omitempty"`
	MemtableFlushPeriodInMs *int32        `thrift:"memtable_flush_period_in_ms,39" json:"memtable_flush_period_in_ms,omitempty"`
	DefaultTimeToLive       *int32        `thrift:"default_time_to_live,40" json:"default_time_to_live,omitempty"`
	IndexInterval           *int32        `thrift:"index_interval,41" json:"index_interval,omitempty"`
	SpeculativeRetry        string        `thrift:"speculative_retry,42" json:"speculative_retry,omitempty"`
	Triggers                []*TriggerDef `thrift:"triggers,43" json:"triggers,omitempty"`
}

func NewCfDef() *CfDef {
	return &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		SpeculativeRetry: "NONE",
	}
}

func (p *CfDef) GetKeyspace() string {
	return p.Keyspace
}

func (p *CfDef) GetName() string {
	return p.Name
}

var CfDef_ColumnType_DEFAULT string = "Standard"

func (p *CfDef) GetColumnType() string {
	return p.ColumnType
}

var CfDef_ComparatorType_DEFAULT string = "BytesType"

func (p *CfDef) GetComparatorType() string {
	return p.ComparatorType
}

var CfDef_SubcomparatorType_DEFAULT string

func (p *CfDef) GetSubcomparatorType() string {
	if !p.IsSetSubcomparatorType() {
		return CfDef_SubcomparatorType_DEFAULT
	}
	return *p.SubcomparatorType
}

var CfDef_Comment_DEFAULT string

func (p *CfDef) GetComment() string {
	if !p.IsSetComment() {
		return CfDef_Comment_DEFAULT
	}
	return *p.Comment
}

var CfDef_ReadRepairChance_DEFAULT float64

func (p *CfDef) GetReadRepairChance() float64 {
	if !p.IsSetReadRepairChance() {
		return CfDef_ReadRepairChance_DEFAULT
	}
	return *p.ReadRepairChance
}

var CfDef_ColumnMetadata_DEFAULT []*ColumnDef

func (p *CfDef) GetColumnMetadata() []*ColumnDef {
	return p.ColumnMetadata
}

var CfDef_GcGraceSeconds_DEFAULT int32

func (p *CfDef) GetGcGraceSeconds() int32 {
	if !p.IsSetGcGraceSeconds() {
		return CfDef_GcGraceSeconds_DEFAULT
	}
	return *p.GcGraceSeconds
}

var CfDef_DefaultValidationClass_DEFAULT string

func (p *CfDef) GetDefaultValidationClass() string {
	if !p.IsSetDefaultValidationClass() {
		return CfDef_DefaultValidationClass_DEFAULT
	}
	return *p.DefaultValidationClass
}

var CfDef_ID_DEFAULT int32

func (p *CfDef) GetID() int32 {
	if !p.IsSetID() {
		return CfDef_ID_DEFAULT
	}
	return *p.ID
}

var CfDef_MinCompactionThreshold_DEFAULT int32

func (p *CfDef) GetMinCompactionThreshold() int32 {
	if !p.IsSetMinCompactionThreshold() {
		return CfDef_MinCompactionThreshold_DEFAULT
	}
	return *p.MinCompactionThreshold
}

var CfDef_MaxCompactionThreshold_DEFAULT int32

func (p *CfDef) GetMaxCompactionThreshold() int32 {
	if !p.IsSetMaxCompactionThreshold() {
		return CfDef_MaxCompactionThreshold_DEFAULT
	}
	return *p.MaxCompactionThreshold
}

var CfDef_ReplicateOnWrite_DEFAULT bool

func (p *CfDef) GetReplicateOnWrite() bool {
	if !p.IsSetReplicateOnWrite() {
		return CfDef_ReplicateOnWrite_DEFAULT
	}
	return *p.ReplicateOnWrite
}

var CfDef_KeyValidationClass_DEFAULT string

func (p *CfDef) GetKeyValidationClass() string {
	if !p.IsSetKeyValidationClass() {
		return CfDef_KeyValidationClass_DEFAULT
	}
	return *p.KeyValidationClass
}

var CfDef_KeyAlias_DEFAULT []byte

func (p *CfDef) GetKeyAlias() []byte {
	return p.KeyAlias
}

var CfDef_CompactionStrategy_DEFAULT string

func (p *CfDef) GetCompactionStrategy() string {
	if !p.IsSetCompactionStrategy() {
		return CfDef_CompactionStrategy_DEFAULT
	}
	return *p.CompactionStrategy
}

var CfDef_CompactionStrategyOptions_DEFAULT map[string]string

func (p *CfDef) GetCompactionStrategyOptions() map[string]string {
	return p.CompactionStrategyOptions
}

var CfDef_CompressionOptions_DEFAULT map[string]string

func (p *CfDef) GetCompressionOptions() map[string]string {
	return p.CompressionOptions
}

var CfDef_BloomFilterFpChance_DEFAULT float64

func (p *CfDef) GetBloomFilterFpChance() float64 {
	if !p.IsSetBloomFilterFpChance() {
		return CfDef_BloomFilterFpChance_DEFAULT
	}
	return *p.BloomFilterFpChance
}

var CfDef_Caching_DEFAULT string = "keys_only"

func (p *CfDef) GetCaching() string {
	return p.Caching
}

var CfDef_DclocalReadRepairChance_DEFAULT float64 = 0

func (p *CfDef) GetDclocalReadRepairChance() float64 {
	return p.DclocalReadRepairChance
}

var CfDef_PopulateIoCacheOnFlush_DEFAULT bool

func (p *CfDef) GetPopulateIoCacheOnFlush() bool {
	if !p.IsSetPopulateIoCacheOnFlush() {
		return CfDef_PopulateIoCacheOnFlush_DEFAULT
	}
	return *p.PopulateIoCacheOnFlush
}

var CfDef_MemtableFlushPeriodInMs_DEFAULT int32

func (p *CfDef) GetMemtableFlushPeriodInMs() int32 {
	if !p.IsSetMemtableFlushPeriodInMs() {
		return CfDef_MemtableFlushPeriodInMs_DEFAULT
	}
	return *p.MemtableFlushPeriodInMs
}

var CfDef_DefaultTimeToLive_DEFAULT int32

func (p *CfDef) GetDefaultTimeToLive() int32 {
	if !p.IsSetDefaultTimeToLive() {
		return CfDef_DefaultTimeToLive_DEFAULT
	}
	return *p.DefaultTimeToLive
}

var CfDef_IndexInterval_DEFAULT int32

func (p *CfDef) GetIndexInterval() int32 {
	if !p.IsSetIndexInterval() {
		return CfDef_IndexInterval_DEFAULT
	}
	return *p.IndexInterval
}

var CfDef_SpeculativeRetry_DEFAULT string = "NONE"

func (p *CfDef) GetSpeculativeRetry() string {
	return p.SpeculativeRetry
}

var CfDef_Triggers_DEFAULT []*TriggerDef

func (p *CfDef) GetTriggers() []*TriggerDef {
	return p.Triggers
}

var CfDef_RowCacheSize_DEFAULT float64

func (p *CfDef) GetRowCacheSize() float64 {
	if !p.IsSetRowCacheSize() {
		return CfDef_RowCacheSize_DEFAULT
	}
	return *p.RowCacheSize
}

var CfDef_KeyCacheSize_DEFAULT float64

func (p *CfDef) GetKeyCacheSize() float64 {
	if !p.IsSetKeyCacheSize() {
		return CfDef_KeyCacheSize_DEFAULT
	}
	return *p.KeyCacheSize
}

var CfDef_RowCacheSavePeriodInSeconds_DEFAULT int32

func (p *CfDef) GetRowCacheSavePeriodInSeconds() int32 {
	if !p.IsSetRowCacheSavePeriodInSeconds() {
		return CfDef_RowCacheSavePeriodInSeconds_DEFAULT
	}
	return *p.RowCacheSavePeriodInSeconds
}

var CfDef_KeyCacheSavePeriodInSeconds_DEFAULT int32

func (p *CfDef) GetKeyCacheSavePeriodInSeconds() int32 {
	if !p.IsSetKeyCacheSavePeriodInSeconds() {
		return CfDef_KeyCacheSavePeriodInSeconds_DEFAULT
	}
	return *p.KeyCacheSavePeriodInSeconds
}

var CfDef_MemtableFlushAfterMins_DEFAULT int32

func (p *CfDef) GetMemtableFlushAfterMins() int32 {
	if !p.IsSetMemtableFlushAfterMins() {
		return CfDef_MemtableFlushAfterMins_DEFAULT
	}
	return *p.MemtableFlushAfterMins
}

var CfDef_MemtableThroughputInMb_DEFAULT int32

func (p *CfDef) GetMemtableThroughputInMb() int32 {
	if !p.IsSetMemtableThroughputInMb() {
		return CfDef_MemtableThroughputInMb_DEFAULT
	}
	return *p.MemtableThroughputInMb
}

var CfDef_MemtableOperationsInMillions_DEFAULT float64

func (p *CfDef) GetMemtableOperationsInMillions() float64 {
	if !p.IsSetMemtableOperationsInMillions() {
		return CfDef_MemtableOperationsInMillions_DEFAULT
	}
	return *p.MemtableOperationsInMillions
}

var CfDef_MergeShardsChance_DEFAULT float64

func (p *CfDef) GetMergeShardsChance() float64 {
	if !p.IsSetMergeShardsChance() {
		return CfDef_MergeShardsChance_DEFAULT
	}
	return *p.MergeShardsChance
}

var CfDef_RowCacheProvider_DEFAULT string

func (p *CfDef) GetRowCacheProvider() string {
	if !p.IsSetRowCacheProvider() {
		return CfDef_RowCacheProvider_DEFAULT
	}
	return *p.RowCacheProvider
}

var CfDef_RowCacheKeysToSave_DEFAULT int32

func (p *CfDef) GetRowCacheKeysToSave() int32 {
	if !p.IsSetRowCacheKeysToSave() {
		return CfDef_RowCacheKeysToSave_DEFAULT
	}
	return *p.RowCacheKeysToSave
}
func (p *CfDef) IsSetColumnType() bool {
	return p.ColumnType != CfDef_ColumnType_DEFAULT
}

func (p *CfDef) IsSetComparatorType() bool {
	return p.ComparatorType != CfDef_ComparatorType_DEFAULT
}

func (p *CfDef) IsSetSubcomparatorType() bool {
	return p.SubcomparatorType != nil
}

func (p *CfDef) IsSetComment() bool {
	return p.Comment != nil
}

func (p *CfDef) IsSetReadRepairChance() bool {
	return p.ReadRepairChance != nil
}

func (p *CfDef) IsSetColumnMetadata() bool {
	return p.ColumnMetadata != nil
}

func (p *CfDef) IsSetGcGraceSeconds() bool {
	return p.GcGraceSeconds != nil
}

func (p *CfDef) IsSetDefaultValidationClass() bool {
	return p.DefaultValidationClass != nil
}

func (p *CfDef) IsSetID() bool {
	return p.ID != nil
}

func (p *CfDef) IsSetMinCompactionThreshold() bool {
	return p.MinCompactionThreshold != nil
}

func (p *CfDef) IsSetMaxCompactionThreshold() bool {
	return p.MaxCompactionThreshold != nil
}

func (p *CfDef) IsSetReplicateOnWrite() bool {
	return p.ReplicateOnWrite != nil
}

func (p *CfDef) IsSetKeyValidationClass() bool {
	return p.KeyValidationClass != nil
}

func (p *CfDef) IsSetKeyAlias() bool {
	return p.KeyAlias != nil
}

func (p *CfDef) IsSetCompactionStrategy() bool {
	return p.CompactionStrategy != nil
}

func (p *CfDef) IsSetCompactionStrategyOptions() bool {
	return p.CompactionStrategyOptions != nil
}

func (p *CfDef) IsSetCompressionOptions() bool {
	return p.CompressionOptions != nil
}

func (p *CfDef) IsSetBloomFilterFpChance() bool {
	return p.BloomFilterFpChance != nil
}

func (p *CfDef) IsSetCaching() bool {
	return p.Caching != CfDef_Caching_DEFAULT
}

func (p *CfDef) IsSetDclocalReadRepairChance() bool {
	return p.DclocalReadRepairChance != CfDef_DclocalReadRepairChance_DEFAULT
}

func (p *CfDef) IsSetPopulateIoCacheOnFlush() bool {
	return p.PopulateIoCacheOnFlush != nil
}

func (p *CfDef) IsSetMemtableFlushPeriodInMs() bool {
	return p.MemtableFlushPeriodInMs != nil
}

func (p *CfDef) IsSetDefaultTimeToLive() bool {
	return p.DefaultTimeToLive != nil
}

func (p *CfDef) IsSetIndexInterval() bool {
	return p.IndexInterval != nil
}

func (p *CfDef) IsSetSpeculativeRetry() bool {
	return p.SpeculativeRetry != CfDef_SpeculativeRetry_DEFAULT
}

func (p *CfDef) IsSetTriggers() bool {
	return p.Triggers != nil
}

func (p *CfDef) IsSetRowCacheSize() bool {
	return p.RowCacheSize != nil
}

func (p *CfDef) IsSetKeyCacheSize() bool {
	return p.KeyCacheSize != nil
}

func (p *CfDef) IsSetRowCacheSavePeriodInSeconds() bool {
	return p.RowCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetKeyCacheSavePeriodInSeconds() bool {
	return p.KeyCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetMemtableFlushAfterMins() bool {
	return p.MemtableFlushAfterMins != nil
}

func (p *CfDef) IsSetMemtableThroughputInMb() bool {
	return p.MemtableThroughputInMb != nil
}

func (p *CfDef) IsSetMemtableOperationsInMillions() bool {
	return p.MemtableOperationsInMillions != nil
}

func (p *CfDef) IsSetMergeShardsChance() bool {
	return p.MergeShardsChance != nil
}

func (p *CfDef) IsSetRowCacheProvider() bool {
	return p.RowCacheProvider != nil
}

func (p *CfDef) IsSetRowCacheKeysToSave() bool {
	return p.RowCacheKeysToSave != nil
}

func (p *CfDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKeyspace bool = false
	var issetName bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKeyspace = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetName = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 8:
			if err := p.readField8(iprot); err != nil {
				return err
			}
		case 12:
			if err := p.readField12(iprot); err != nil {
				return err
			}
		case 13:
			if err := p.readField13(iprot); err != nil {
				return err
			}
		case 14:
			if err := p.readField14(iprot); err != nil {
				return err
			}
		case 15:
			if err := p.readField15(iprot); err != nil {
				return err
			}
		case 16:
			if err := p.readField16(iprot); err != nil {
				return err
			}
		case 17:
			if err := p.readField17(iprot); err != nil {
				return err
			}
		case 18:
			if err := p.readField18(iprot); err != nil {
				return err
			}
		case 24:
			if err := p.readField24(iprot); err != nil {
				return err
			}
		case 26:
			if err := p.readField26(iprot); err != nil {
				return err
			}
		case 28:
			if err := p.readField28(iprot); err != nil {
				return err
			}
		case 29:
			if err := p.readField29(iprot); err != nil {
				return err
			}
		case 30:
			if err := p.readField30(iprot); err != nil {
				return err
			}
		case 32:
			if err := p.readField32(iprot); err != nil {
				return err
			}
		case 33:
			if err := p.readField33(iprot); err != nil {
				return err
			}
		case 34:
			if err := p.readField34(iprot); err != nil {
				return err
			}
		case 37:
			if err := p.readField37(iprot); err != nil {
				return err
			}
		case 38:
			if err := p.readField38(iprot); err != nil {
				return err
			}
		case 39:
			if err := p.readField39(iprot); err != nil {
				return err
			}
		case 40:
			if err := p.readField40(iprot); err != nil {
				return err
			}
		case 41:
			if err := p.readField41(iprot); err != nil {
				return err
			}
		case 42:
			if err := p.readField42(iprot); err != nil {
				return err
			}
		case 43:
			if err := p.readField43(iprot); err != nil {
				return err
			}
		case 9:
			if err := p.readField9(iprot); err != nil {
				return err
			}
		case 11:
			if err := p.readField11(iprot); err != nil {
				return err
			}
		case 19:
			if err := p.readField19(iprot); err != nil {
				return err
			}
		case 20:
			if err := p.readField20(iprot); err != nil {
				return err
			}
		case 21:
			if err := p.readField21(iprot); err != nil {
				return err
			}
		case 22:
			if err := p.readField22(iprot); err != nil {
				return err
			}
		case 23:
			if err := p.readField23(iprot); err != nil {
				return err
			}
		case 25:
			if err := p.readField25(iprot); err != nil {
				return err
			}
		case 27:
			if err := p.readField27(iprot); err != nil {
				return err
			}
		case 31:
			if err := p.readField31(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKeyspace {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Keyspace is not set"))
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	return nil
}

func (p *CfDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CfDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CfDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ColumnType = v
	}
	return nil
}

func (p *CfDef) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.ComparatorType = v
	}
	return nil
}

func (p *CfDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.SubcomparatorType = &v
	}
	return nil
}

func (p *CfDef) readField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.Comment = &v
	}
	return nil
}

func (p *CfDef) readField12(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.ReadRepairChance = &v
	}
	return nil
}

func (p *CfDef) readField13(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*ColumnDef, 0, size)
	p.ColumnMetadata = tSlice
	for i := 0; i < size; i++ {
		_elem16 := &ColumnDef{}
		if err := _elem16.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
		}
		p.ColumnMetadata = append(p.ColumnMetadata, _elem16)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CfDef) readField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 14: ", err)
	} else {
		p.GcGraceSeconds = &v
	}
	return nil
}

func (p *CfDef) readField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 15: ", err)
	} else {
		p.DefaultValidationClass = &v
	}
	return nil
}

func (p *CfDef) readField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 16: ", err)
	} else {
		p.ID = &v
	}
	return nil
}

func (p *CfDef) readField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 17: ", err)
	} else {
		p.MinCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) readField18(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 18: ", err)
	} else {
		p.MaxCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) readField24(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 24: ", err)
	} else {
		p.ReplicateOnWrite = &v
	}
	return nil
}

func (p *CfDef) readField26(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 26: ", err)
	} else {
		p.KeyValidationClass = &v
	}
	return nil
}

func (p *CfDef) readField28(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 28: ", err)
	} else {
		p.KeyAlias = v
	}
	return nil
}

func (p *CfDef) readField29(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 29: ", err)
	} else {
		p.CompactionStrategy = &v
	}
	return nil
}

func (p *CfDef) readField30(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.CompactionStrategyOptions = tMap
	for i := 0; i < size; i++ {
		var _key17 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key17 = v
		}
		var _val18 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val18 = v
		}
		p.CompactionStrategyOptions[_key17] = _val18
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CfDef) readField32(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.CompressionOptions = tMap
	for i := 0; i < size; i++ {
		var _key19 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key19 = v
		}
		var _val20 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val20 = v
		}
		p.CompressionOptions[_key19] = _val20
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CfDef) readField33(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 33: ", err)
	} else {
		p.BloomFilterFpChance = &v
	}
	return nil
}

func (p *CfDef) readField34(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 34: ", err)
	} else {
		p.Caching = v
	}
	return nil
}

func (p *CfDef) readField37(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 37: ", err)
	} else {
		p.DclocalReadRepairChance = v
	}
	return nil
}

func (p *CfDef) readField38(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 38: ", err)
	} else {
		p.PopulateIoCacheOnFlush = &v
	}
	return nil
}

func (p *CfDef) readField39(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 39: ", err)
	} else {
		p.MemtableFlushPeriodInMs = &v
	}
	return nil
}

func (p *CfDef) readField40(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 40: ", err)
	} else {
		p.DefaultTimeToLive = &v
	}
	return nil
}

func (p *CfDef) readField41(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 41: ", err)
	} else {
		p.IndexInterval = &v
	}
	return nil
}

func (p *CfDef) readField42(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 42: ", err)
	} else {
		p.SpeculativeRetry = v
	}
	return nil
}

func (p *CfDef) readField43(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*TriggerDef, 0, size)
	p.Triggers = tSlice
	for i := 0; i < size; i++ {
		_elem21 := &TriggerDef{}
		if err := _elem21.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem21), err)
		}
		p.Triggers = append(p.Triggers, _elem21)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CfDef) readField9(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.RowCacheSize = &v
	}
	return nil
}

func (p *CfDef) readField11(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.KeyCacheSize = &v
	}
	return nil
}

func (p *CfDef) readField19(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 19: ", err)
	} else {
		p.RowCacheSavePeriodInSeconds = &v
	}
	return nil
}

func (p *CfDef) readField20(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 20: ", err)
	} else {
		p.KeyCacheSavePeriodInSeconds = &v
	}
	return nil
}

func (p *CfDef) readField21(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 21: ", err)
	} else {
		p.MemtableFlushAfterMins = &v
	}
	return nil
}

func (p *CfDef) readField22(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 22: ", err)
	} else {
		p.MemtableThroughputInMb = &v
	}
	return nil
}

func (p *CfDef) readField23(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 23: ", err)
	} else {
		p.MemtableOperationsInMillions = &v
	}
	return nil
}

func (p *CfDef) readField25(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 25: ", err)
	} else {
		p.MergeShardsChance = &v
	}
	return nil
}

func (p *CfDef) readField27(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 27: ", err)
	} else {
		p.RowCacheProvider = &v
	}
	return nil
}

func (p *CfDef) readField31(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 31: ", err)
	} else {
		p.RowCacheKeysToSave = &v
	}
	return nil
}

func (p *CfDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfDef"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField8(oprot); err != nil {
		return err
	}
	if err := p.writeField9(oprot); err != nil {
		return err
	}
	if err := p.writeField11(oprot); err != nil {
		return err
	}
	if err := p.writeField12(oprot); err != nil {
		return err
	}
	if err := p.writeField13(oprot); err != nil {
		return err
	}
	if err := p.writeField14(oprot); err != nil {
		return err
	}
	if err := p.writeField15(oprot); err != nil {
		return err
	}
	if err := p.writeField16(oprot); err != nil {
		return err
	}
	if err := p.writeField17(oprot); err != nil {
		return err
	}
	if err := p.writeField18(oprot); err != nil {
		return err
	}
	if err := p.writeField19(oprot); err != nil {
		return err
	}
	if err := p.writeField20(oprot); err != nil {
		return err
	}
	if err := p.writeField21(oprot); err != nil {
		return err
	}
	if err := p.writeField22(oprot); err != nil {
		return err
	}
	if err := p.writeField23(oprot); err != nil {
		return err
	}
	if err := p.writeField24(oprot); err != nil {
		return err
	}
	if err := p.writeField25(oprot); err != nil {
		return err
	}
	if err := p.writeField26(oprot); err != nil {
		return err
	}
	if err := p.writeField27(oprot); err != nil {
		return err
	}
	if err := p.writeField28(oprot); err != nil {
		return err
	}
	if err := p.writeField29(oprot); err != nil {
		return err
	}
	if err := p.writeField30(oprot); err != nil {
		return err
	}
	if err := p.writeField31(oprot); err != nil {
		return err
	}
	if err := p.writeField32(oprot); err != nil {
		return err
	}
	if err := p.writeField33(oprot); err != nil {
		return err
	}
	if err := p.writeField34(oprot); err != nil {
		return err
	}
	if err := p.writeField37(oprot); err != nil {
		return err
	}
	if err := p.writeField38(oprot); err != nil {
		return err
	}
	if err := p.writeField39(oprot); err != nil {
		return err
	}
	if err := p.writeField40(oprot); err != nil {
		return err
	}
	if err := p.writeField41(oprot); err != nil {
		return err
	}
	if err := p.writeField42(oprot); err != nil {
		return err
	}
	if err := p.writeField43(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CfDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:keyspace: ", p), err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.keyspace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:keyspace: ", p), err)
	}
	return err
}

func (p *CfDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:name: ", p), err)
	}
	return err
}

func (p *CfDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnType() {
		if err := oprot.WriteFieldBegin("column_type", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:column_type: ", p), err)
		}
		if err := oprot.WriteString(string(p.ColumnType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.column_type (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:column_type: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetComparatorType() {
		if err := oprot.WriteFieldBegin("comparator_type", thrift.STRING, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:comparator_type: ", p), err)
		}
		if err := oprot.WriteString(string(p.ComparatorType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comparator_type (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:comparator_type: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetSubcomparatorType() {
		if err := oprot.WriteFieldBegin("subcomparator_type", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:subcomparator_type: ", p), err)
		}
		if err := oprot.WriteString(string(*p.SubcomparatorType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.subcomparator_type (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:subcomparator_type: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin("comment", thrift.STRING, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:comment: ", p), err)
		}
		if err := oprot.WriteString(string(*p.Comment)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comment (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:comment: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSize() {
		if err := oprot.WriteFieldBegin("row_cache_size", thrift.DOUBLE, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:row_cache_size: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.RowCacheSize)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.row_cache_size (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:row_cache_size: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField11(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSize() {
		if err := oprot.WriteFieldBegin("key_cache_size", thrift.DOUBLE, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:key_cache_size: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.KeyCacheSize)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.key_cache_size (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:key_cache_size: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetReadRepairChance() {
		if err := oprot.WriteFieldBegin("read_repair_chance", thrift.DOUBLE, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:read_repair_chance: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.ReadRepairChance)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.read_repair_chance (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:read_repair_chance: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField13(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnMetadata() {
		if err := oprot.WriteFieldBegin("column_metadata", thrift.LIST, 13); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:column_metadata: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnMetadata)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.ColumnMetadata {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 13:column_metadata: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetGcGraceSeconds() {
		if err := oprot.WriteFieldBegin("gc_grace_seconds", thrift.I32, 14); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:gc_grace_seconds: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.GcGraceSeconds)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.gc_grace_seconds (14) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 14:gc_grace_seconds: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetDefaultValidationClass() {
		if err := oprot.WriteFieldBegin("default_validation_class", thrift.STRING, 15); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:default_validation_class: ", p), err)
		}
		if err := oprot.WriteString(string(*p.DefaultValidationClass)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.default_validation_class (15) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 15:default_validation_class: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetID() {
		if err := oprot.WriteFieldBegin("id", thrift.I32, 16); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:id: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.ID)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.id (16) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 16:id: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetMinCompactionThreshold() {
		if err := oprot.WriteFieldBegin("min_compaction_threshold", thrift.I32, 17); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:min_compaction_threshold: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.MinCompactionThreshold)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.min_compaction_threshold (17) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 17:min_compaction_threshold: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField18(oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxCompactionThreshold() {
		if err := oprot.WriteFieldBegin("max_compaction_threshold", thrift.I32, 18); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:max_compaction_threshold: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.MaxCompactionThreshold)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.max_compaction_threshold (18) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 18:max_compaction_threshold: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField19(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("row_cache_save_period_in_seconds", thrift.I32, 19); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 19:row_cache_save_period_in_seconds: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.RowCacheSavePeriodInSeconds)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.row_cache_save_period_in_seconds (19) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 19:row_cache_save_period_in_seconds: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField20(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("key_cache_save_period_in_seconds", thrift.I32, 20); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 20:key_cache_save_period_in_seconds: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.KeyCacheSavePeriodInSeconds)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.key_cache_save_period_in_seconds (20) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 20:key_cache_save_period_in_seconds: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField21(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableFlushAfterMins() {
		if err := oprot.WriteFieldBegin("memtable_flush_after_mins", thrift.I32, 21); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 21:memtable_flush_after_mins: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.MemtableFlushAfterMins)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.memtable_flush_after_mins (21) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 21:memtable_flush_after_mins: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField22(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableThroughputInMb() {
		if err := oprot.WriteFieldBegin("memtable_throughput_in_mb", thrift.I32, 22); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 22:memtable_throughput_in_mb: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.MemtableThroughputInMb)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.memtable_throughput_in_mb (22) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 22:memtable_throughput_in_mb: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField23(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableOperationsInMillions() {
		if err := oprot.WriteFieldBegin("memtable_operations_in_millions", thrift.DOUBLE, 23); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 23:memtable_operations_in_millions: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.MemtableOperationsInMillions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.memtable_operations_in_millions (23) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 23:memtable_operations_in_millions: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField24(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicateOnWrite() {
		if err := oprot.WriteFieldBegin("replicate_on_write", thrift.BOOL, 24); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 24:replicate_on_write: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.ReplicateOnWrite)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.replicate_on_write (24) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 24:replicate_on_write: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField25(oprot thrift.TProtocol) (err error) {
	if p.IsSetMergeShardsChance() {
		if err := oprot.WriteFieldBegin("merge_shards_chance", thrift.DOUBLE, 25); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 25:merge_shards_chance: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.MergeShardsChance)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.merge_shards_chance (25) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 25:merge_shards_chance: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField26(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyValidationClass() {
		if err := oprot.WriteFieldBegin("key_validation_class", thrift.STRING, 26); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 26:key_validation_class: ", p), err)
		}
		if err := oprot.WriteString(string(*p.KeyValidationClass)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.key_validation_class (26) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 26:key_validation_class: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField27(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheProvider() {
		if err := oprot.WriteFieldBegin("row_cache_provider", thrift.STRING, 27); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 27:row_cache_provider: ", p), err)
		}
		if err := oprot.WriteString(string(*p.RowCacheProvider)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.row_cache_provider (27) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 27:row_cache_provider: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField28(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyAlias() {
		if err := oprot.WriteFieldBegin("key_alias", thrift.STRING, 28); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 28:key_alias: ", p), err)
		}
		if err := oprot.WriteBinary(p.KeyAlias); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.key_alias (28) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 28:key_alias: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField29(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompactionStrategy() {
		if err := oprot.WriteFieldBegin("compaction_strategy", thrift.STRING, 29); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 29:compaction_strategy: ", p), err)
		}
		if err := oprot.WriteString(string(*p.CompactionStrategy)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.compaction_strategy (29) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 29:compaction_strategy: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField30(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompactionStrategyOptions() {
		if err := oprot.WriteFieldBegin("compaction_strategy_options", thrift.MAP, 30); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 30:compaction_strategy_options: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompactionStrategyOptions)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.CompactionStrategyOptions {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 30:compaction_strategy_options: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField31(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheKeysToSave() {
		if err := oprot.WriteFieldBegin("row_cache_keys_to_save", thrift.I32, 31); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 31:row_cache_keys_to_save: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.RowCacheKeysToSave)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.row_cache_keys_to_save (31) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 31:row_cache_keys_to_save: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField32(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompressionOptions() {
		if err := oprot.WriteFieldBegin("compression_options", thrift.MAP, 32); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 32:compression_options: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompressionOptions)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.CompressionOptions {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 32:compression_options: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField33(oprot thrift.TProtocol) (err error) {
	if p.IsSetBloomFilterFpChance() {
		if err := oprot.WriteFieldBegin("bloom_filter_fp_chance", thrift.DOUBLE, 33); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 33:bloom_filter_fp_chance: ", p), err)
		}
		if err := oprot.WriteDouble(float64(*p.BloomFilterFpChance)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.bloom_filter_fp_chance (33) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 33:bloom_filter_fp_chance: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField34(oprot thrift.TProtocol) (err error) {
	if p.IsSetCaching() {
		if err := oprot.WriteFieldBegin("caching", thrift.STRING, 34); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 34:caching: ", p), err)
		}
		if err := oprot.WriteString(string(p.Caching)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.caching (34) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 34:caching: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField37(oprot thrift.TProtocol) (err error) {
	if p.IsSetDclocalReadRepairChance() {
		if err := oprot.WriteFieldBegin("dclocal_read_repair_chance", thrift.DOUBLE, 37); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 37:dclocal_read_repair_chance: ", p), err)
		}
		if err := oprot.WriteDouble(float64(p.DclocalReadRepairChance)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.dclocal_read_repair_chance (37) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 37:dclocal_read_repair_chance: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField38(oprot thrift.TProtocol) (err error) {
	if p.IsSetPopulateIoCacheOnFlush() {
		if err := oprot.WriteFieldBegin("populate_io_cache_on_flush", thrift.BOOL, 38); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 38:populate_io_cache_on_flush: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.PopulateIoCacheOnFlush)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.populate_io_cache_on_flush (38) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 38:populate_io_cache_on_flush: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField39(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableFlushPeriodInMs() {
		if err := oprot.WriteFieldBegin("memtable_flush_period_in_ms", thrift.I32, 39); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 39:memtable_flush_period_in_ms: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.MemtableFlushPeriodInMs)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.memtable_flush_period_in_ms (39) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 39:memtable_flush_period_in_ms: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField40(oprot thrift.TProtocol) (err error) {
	if p.IsSetDefaultTimeToLive() {
		if err := oprot.WriteFieldBegin("default_time_to_live", thrift.I32, 40); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 40:default_time_to_live: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.DefaultTimeToLive)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.default_time_to_live (40) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 40:default_time_to_live: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField41(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexInterval() {
		if err := oprot.WriteFieldBegin("index_interval", thrift.I32, 41); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 41:index_interval: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.IndexInterval)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.index_interval (41) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 41:index_interval: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField42(oprot thrift.TProtocol) (err error) {
	if p.IsSetSpeculativeRetry() {
		if err := oprot.WriteFieldBegin("speculative_retry", thrift.STRING, 42); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 42:speculative_retry: ", p), err)
		}
		if err := oprot.WriteString(string(p.SpeculativeRetry)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.speculative_retry (42) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 42:speculative_retry: ", p), err)
		}
	}
	return err
}

func (p *CfDef) writeField43(oprot thrift.TProtocol) (err error) {
	if p.IsSetTriggers() {
		if err := oprot.WriteFieldBegin("triggers", thrift.LIST, 43); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 43:triggers: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Triggers)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Triggers {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 43:triggers: ", p), err)
		}
	}
	return err
}

func (p *CfDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfDef(%+v)", *p)
}

// Attributes:
//  - Name
//  - StrategyClass
//  - StrategyOptions
//  - ReplicationFactor: @deprecated ignored
//  - CfDefs
//  - DurableWrites
type KsDef struct {
	Name              string            `thrift:"name,1,required" json:"name"`
	StrategyClass     string            `thrift:"strategy_class,2,required" json:"strategy_class"`
	StrategyOptions   map[string]string `thrift:"strategy_options,3" json:"strategy_options,omitempty"`
	ReplicationFactor *int32            `thrift:"replication_factor,4" json:"replication_factor,omitempty"`
	CfDefs            []*CfDef          `thrift:"cf_defs,5,required" json:"cf_defs"`
	DurableWrites     bool              `thrift:"durable_writes,6" json:"durable_writes,omitempty"`
}

func NewKsDef() *KsDef {
	return &KsDef{
		DurableWrites: true,
	}
}

func (p *KsDef) GetName() string {
	return p.Name
}

func (p *KsDef) GetStrategyClass() string {
	return p.StrategyClass
}

var KsDef_StrategyOptions_DEFAULT map[string]string

func (p *KsDef) GetStrategyOptions() map[string]string {
	return p.StrategyOptions
}

var KsDef_ReplicationFactor_DEFAULT int32

func (p *KsDef) GetReplicationFactor() int32 {
	if !p.IsSetReplicationFactor() {
		return KsDef_ReplicationFactor_DEFAULT
	}
	return *p.ReplicationFactor
}

func (p *KsDef) GetCfDefs() []*CfDef {
	return p.CfDefs
}

var KsDef_DurableWrites_DEFAULT bool = true

func (p *KsDef) GetDurableWrites() bool {
	return p.DurableWrites
}
func (p *KsDef) IsSetStrategyOptions() bool {
	return p.StrategyOptions != nil
}

func (p *KsDef) IsSetReplicationFactor() bool {
	return p.ReplicationFactor != nil
}

func (p *KsDef) IsSetDurableWrites() bool {
	return p.DurableWrites != KsDef_DurableWrites_DEFAULT
}

func (p *KsDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false
	var issetStrategyClass bool = false
	var issetCfDefs bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetName = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetStrategyClass = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
			issetCfDefs = true
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"))
	}
	if !issetStrategyClass {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StrategyClass is not set"))
	}
	if !issetCfDefs {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field CfDefs is not set"))
	}
	return nil
}

func (p *KsDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *KsDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.StrategyClass = v
	}
	return nil
}

func (p *KsDef) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.StrategyOptions = tMap
	for i := 0; i < size; i++ {
		var _key22 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key22 = v
		}
		var _val23 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val23 = v
		}
		p.StrategyOptions[_key22] = _val23
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *KsDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ReplicationFactor = &v
	}
	return nil
}

func (p *KsDef) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CfDef, 0, size)
	p.CfDefs = tSlice
	for i := 0; i < size; i++ {
		_elem24 := &CfDef{
			ColumnType: "Standard",

			ComparatorType: "BytesType",

			Caching: "keys_only",

			SpeculativeRetry: "NONE",
		}
		if err := _elem24.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem24), err)
		}
		p.CfDefs = append(p.CfDefs, _elem24)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *KsDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.DurableWrites = v
	}
	return nil
}

func (p *KsDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KsDef"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KsDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *KsDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("strategy_class", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:strategy_class: ", p), err)
	}
	if err := oprot.WriteString(string(p.StrategyClass)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.strategy_class (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:strategy_class: ", p), err)
	}
	return err
}

func (p *KsDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetStrategyOptions() {
		if err := oprot.WriteFieldBegin("strategy_options", thrift.MAP, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:strategy_options: ", p), err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.StrategyOptions)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.StrategyOptions {
			if err := oprot.WriteString(string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:strategy_options: ", p), err)
		}
	}
	return err
}

func (p *KsDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicationFactor() {
		if err := oprot.WriteFieldBegin("replication_factor", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:replication_factor: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.ReplicationFactor)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.replication_factor (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:replication_factor: ", p), err)
		}
	}
	return err
}

func (p *KsDef) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cf_defs", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:cf_defs: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CfDefs)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.CfDefs {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:cf_defs: ", p), err)
	}
	return err
}

func (p *KsDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetDurableWrites() {
		if err := oprot.WriteFieldBegin("durable_writes", thrift.BOOL, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:durable_writes: ", p), err)
		}
		if err := oprot.WriteBool(bool(p.DurableWrites)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durable_writes (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:durable_writes: ", p), err)
		}
	}
	return err
}

func (p *KsDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KsDef(%+v)", *p)
}

// Row returned from a CQL query
//
// Attributes:
//  - Key
//  - Columns
type CqlRow struct {
	Key     []byte    `thrift:"key,1,required" json:"key"`
	Columns []*Column `thrift:"columns,2,required" json:"columns"`
}

func NewCqlRow() *CqlRow {
	return &CqlRow{}
}

func (p *CqlRow) GetKey() []byte {
	return p.Key
}

func (p *CqlRow) GetColumns() []*Column {
	return p.Columns
}
func (p *CqlRow) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetKey bool = false
	var issetColumns bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetKey = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetColumns = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetKey {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Key is not set"))
	}
	if !issetColumns {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Columns is not set"))
	}
	return nil
}

func (p *CqlRow) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CqlRow) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem25 := &Column{}
		if err := _elem25.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem25), err)
		}
		p.Columns = append(p.Columns, _elem25)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CqlRow) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlRow"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CqlRow) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:key: ", p), err)
	}
	if err := oprot.WriteBinary(p.Key); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.key (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:key: ", p), err)
	}
	return err
}

func (p *CqlRow) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Columns {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns: ", p), err)
	}
	return err
}

func (p *CqlRow) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlRow(%+v)", *p)
}

// Attributes:
//  - NameTypes
//  - ValueTypes
//  - DefaultNameType
//  - DefaultValueType
type CqlMetadata struct {
	NameTypes        map[string]string `thrift:"name_types,1,required" json:"name_types"`
	ValueTypes       map[string]string `thrift:"value_types,2,required" json:"value_types"`
	DefaultNameType  string            `thrift:"default_name_type,3,required" json:"default_name_type"`
	DefaultValueType string            `thrift:"default_value_type,4,required" json:"default_value_type"`
}

func NewCqlMetadata() *CqlMetadata {
	return &CqlMetadata{}
}

func (p *CqlMetadata) GetNameTypes() map[string]string {
	return p.NameTypes
}

func (p *CqlMetadata) GetValueTypes() map[string]string {
	return p.ValueTypes
}

func (p *CqlMetadata) GetDefaultNameType() string {
	return p.DefaultNameType
}

func (p *CqlMetadata) GetDefaultValueType() string {
	return p.DefaultValueType
}
func (p *CqlMetadata) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameTypes bool = false
	var issetValueTypes bool = false
	var issetDefaultNameType bool = false
	var issetDefaultValueType bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetNameTypes = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetValueTypes = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetDefaultNameType = true
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
			issetDefaultValueType = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameTypes {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameTypes is not set"))
	}
	if !issetValueTypes {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ValueTypes is not set"))
	}
	if !issetDefaultNameType {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DefaultNameType is not set"))
	}
	if !issetDefaultValueType {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DefaultValueType is not set"))
	}
	return nil
}

func (p *CqlMetadata) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.NameTypes = tMap
	for i := 0; i < size; i++ {
		var _key26 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key26 = v
		}
		var _val27 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val27 = v
		}
		p.NameTypes[_key26] = _val27
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CqlMetadata) readField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.ValueTypes = tMap
	for i := 0; i < size; i++ {
		var _key28 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key28 = v
		}
		var _val29 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val29 = v
		}
		p.ValueTypes[_key28] = _val29
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CqlMetadata) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.DefaultNameType = v
	}
	return nil
}

func (p *CqlMetadata) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.DefaultValueType = v
	}
	return nil
}

func (p *CqlMetadata) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlMetadata"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CqlMetadata) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name_types", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name_types: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.NameTypes)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.NameTypes {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name_types: ", p), err)
	}
	return err
}

func (p *CqlMetadata) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value_types", thrift.MAP, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value_types: ", p), err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.ValueTypes)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ValueTypes {
		if err := oprot.WriteString(string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value_types: ", p), err)
	}
	return err
}

func (p *CqlMetadata) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_name_type", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:default_name_type: ", p), err)
	}
	if err := oprot.WriteString(string(p.DefaultNameType)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.default_name_type (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:default_name_type: ", p), err)
	}
	return err
}

func (p *CqlMetadata) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_value_type", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:default_value_type: ", p), err)
	}
	if err := oprot.WriteString(string(p.DefaultValueType)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.default_value_type (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:default_value_type: ", p), err)
	}
	return err
}

func (p *CqlMetadata) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlMetadata(%+v)", *p)
}

// Attributes:
//  - Type
//  - Rows
//  - Num
//  - Schema
type CqlResult_ struct {
	Type   CqlResultType `thrift:"type,1,required" json:"type"`
	Rows   []*CqlRow     `thrift:"rows,2" json:"rows,omitempty"`
	Num    *int32        `thrift:"num,3" json:"num,omitempty"`
	Schema *CqlMetadata  `thrift:"schema,4" json:"schema,omitempty"`
}

func NewCqlResult_() *CqlResult_ {
	return &CqlResult_{}
}

func (p *CqlResult_) GetType() CqlResultType {
	return p.Type
}

var CqlResult__Rows_DEFAULT []*CqlRow

func (p *CqlResult_) GetRows() []*CqlRow {
	return p.Rows
}

var CqlResult__Num_DEFAULT int32

func (p *CqlResult_) GetNum() int32 {
	if !p.IsSetNum() {
		return CqlResult__Num_DEFAULT
	}
	return *p.Num
}

var CqlResult__Schema_DEFAULT *CqlMetadata

func (p *CqlResult_) GetSchema() *CqlMetadata {
	if !p.IsSetSchema() {
		return CqlResult__Schema_DEFAULT
	}
	return p.Schema
}
func (p *CqlResult_) IsSetRows() bool {
	return p.Rows != nil
}

func (p *CqlResult_) IsSetNum() bool {
	return p.Num != nil
}

func (p *CqlResult_) IsSetSchema() bool {
	return p.Schema != nil
}

func (p *CqlResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetType bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetType = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetType {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"))
	}
	return nil
}

func (p *CqlResult_) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := CqlResultType(v)
		p.Type = temp
	}
	return nil
}

func (p *CqlResult_) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CqlRow, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		_elem30 := &CqlRow{}
		if err := _elem30.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
		}
		p.Rows = append(p.Rows, _elem30)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CqlResult_) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Num = &v
	}
	return nil
}

func (p *CqlResult_) readField4(iprot thrift.TProtocol) error {
	p.Schema = &CqlMetadata{}
	if err := p.Schema.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Schema), err)
	}
	return nil
}

func (p *CqlResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CqlResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Type)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err)
	}
	return err
}

func (p *CqlResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetRows() {
		if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rows: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Rows)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Rows {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rows: ", p), err)
		}
	}
	return err
}

func (p *CqlResult_) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNum() {
		if err := oprot.WriteFieldBegin("num", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:num: ", p), err)
		}
		if err := oprot.WriteI32(int32(*p.Num)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.num (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:num: ", p), err)
		}
	}
	return err
}

func (p *CqlResult_) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSchema() {
		if err := oprot.WriteFieldBegin("schema", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:schema: ", p), err)
		}
		if err := p.Schema.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Schema), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:schema: ", p), err)
		}
	}
	return err
}

func (p *CqlResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlResult_(%+v)", *p)
}

// Attributes:
//  - ItemId
//  - Count
//  - VariableTypes
//  - VariableNames
type CqlPreparedResult_ struct {
	ItemId        int32    `thrift:"itemId,1,required" json:"itemId"`
	Count         int32    `thrift:"count,2,required" json:"count"`
	VariableTypes []string `thrift:"variable_types,3" json:"variable_types,omitempty"`
	VariableNames []string `thrift:"variable_names,4" json:"variable_names,omitempty"`
}

func NewCqlPreparedResult_() *CqlPreparedResult_ {
	return &CqlPreparedResult_{}
}

func (p *CqlPreparedResult_) GetItemId() int32 {
	return p.ItemId
}

func (p *CqlPreparedResult_) GetCount() int32 {
	return p.Count
}

var CqlPreparedResult__VariableTypes_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableTypes() []string {
	return p.VariableTypes
}

var CqlPreparedResult__VariableNames_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableNames() []string {
	return p.VariableNames
}
func (p *CqlPreparedResult_) IsSetVariableTypes() bool {
	return p.VariableTypes != nil
}

func (p *CqlPreparedResult_) IsSetVariableNames() bool {
	return p.VariableNames != nil
}

func (p *CqlPreparedResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetItemId bool = false
	var issetCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetItemId = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetCount = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetItemId {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ItemId is not set"))
	}
	if !issetCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Count is not set"))
	}
	return nil
}

func (p *CqlPreparedResult_) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CqlPreparedResult_) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *CqlPreparedResult_) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.VariableTypes = tSlice
	for i := 0; i < size; i++ {
		var _elem31 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem31 = v
		}
		p.VariableTypes = append(p.VariableTypes, _elem31)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CqlPreparedResult_) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.VariableNames = tSlice
	for i := 0; i < size; i++ {
		var _elem32 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem32 = v
		}
		p.VariableNames = append(p.VariableNames, _elem32)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CqlPreparedResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlPreparedResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CqlPreparedResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:itemId: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.itemId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:itemId: ", p), err)
	}
	return err
}

func (p *CqlPreparedResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:count: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.count (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:count: ", p), err)
	}
	return err
}

func (p *CqlPreparedResult_) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetVariableTypes() {
		if err := oprot.WriteFieldBegin("variable_types", thrift.LIST, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:variable_types: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableTypes)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.VariableTypes {
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:variable_types: ", p), err)
		}
	}
	return err
}

func (p *CqlPreparedResult_) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetVariableNames() {
		if err := oprot.WriteFieldBegin("variable_names", thrift.LIST, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:variable_names: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableNames)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.VariableNames {
			if err := oprot.WriteString(string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:variable_names: ", p), err)
		}
	}
	return err
}

func (p *CqlPreparedResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlPreparedResult_(%+v)", *p)
}

// Represents input splits used by hadoop ColumnFamilyRecordReaders
//
// Attributes:
//  - StartToken
//  - EndToken
//  - RowCount
type CfSplit struct {
	StartToken string `thrift:"start_token,1,required" json:"start_token"`
	EndToken   string `thrift:"end_token,2,required" json:"end_token"`
	RowCount   int64  `thrift:"row_count,3,required" json:"row_count"`
}

func NewCfSplit() *CfSplit {
	return &CfSplit{}
}

func (p *CfSplit) GetStartToken() string {
	return p.StartToken
}

func (p *CfSplit) GetEndToken() string {
	return p.EndToken
}

func (p *CfSplit) GetRowCount() int64 {
	return p.RowCount
}
func (p *CfSplit) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetStartToken bool = false
	var issetEndToken bool = false
	var issetRowCount bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
			issetStartToken = true
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
			issetEndToken = true
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
			issetRowCount = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetStartToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field StartToken is not set"))
	}
	if !issetEndToken {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EndToken is not set"))
	}
	if !issetRowCount {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RowCount is not set"))
	}
	return nil
}

func (p *CfSplit) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *CfSplit) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *CfSplit) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RowCount = v
	}
	return nil
}

func (p *CfSplit) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfSplit"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CfSplit) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start_token (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start_token: ", p), err)
	}
	return err
}

func (p *CfSplit) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:end_token: ", p), err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.end_token (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:end_token: ", p), err)
	}
	return err
}

func (p *CfSplit) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row_count", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:row_count: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.RowCount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.row_count (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:row_count: ", p), err)
	}
	return err
}

func (p *CfSplit) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfSplit(%+v)", *p)
}
