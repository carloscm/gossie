// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"bytes"
	"fmt"

	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var GoUnusedProtection__ int

//The ConsistencyLevel is an enum that controls both read and write
//behavior based on the ReplicationFactor of the keyspace.  The
//different consistency levels have different meanings, depending on
//if you're doing a write or read operation.
//
//If W + R > ReplicationFactor, where W is the number of nodes to
//block for on write, and R the number to block for on reads, you
//will have strongly consistent behavior; that is, readers will
//always see the most recent write. Of these, the most interesting is
//to do QUORUM reads and writes, which gives you consistency while
//still allowing availability in the face of node failures up to half
//of <ReplicationFactor>. Of course if latency is more important than
//consistency then you can use lower values for either or both.
//
//Some ConsistencyLevels (ONE, TWO, THREE) refer to a specific number
//of replicas rather than a logical concept that adjusts
//automatically with the replication factor.  Of these, only ONE is
//commonly used; TWO and (even more rarely) THREE are only useful
//when you care more about guaranteeing a certain level of
//durability, than consistency.
//
//Write consistency levels make the following guarantees before reporting success to the client:
//  ANY          Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
//  ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
//  TWO          Ensure that the write has been written to at least 2 node's commit log and memory table
//  THREE        Ensure that the write has been written to at least 3 node's commit log and memory table
//  QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
//  LOCAL_QUORUM Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires NetworkTopologyStrategy)
//  EACH_QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires NetworkTopologyStrategy)
//  ALL          Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
//
//Read consistency levels make the following guarantees before returning successful results to the client:
//  ANY          Not supported. You probably want ONE instead.
//  ONE          Returns the record obtained from a single replica.
//  TWO          Returns the record with the most recent timestamp once two replicas have replied.
//  THREE        Returns the record with the most recent timestamp once three replicas have replied.
//  QUORUM       Returns the record with the most recent timestamp once a majority of replicas have replied.
//  LOCAL_QUORUM Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
//  EACH_QUORUM  Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
//  ALL          Returns the record with the most recent timestamp once all replicas have replied (implies no replica may be down)..
type ConsistencyLevel int64

const (
	ConsistencyLevel_ONE          ConsistencyLevel = 1
	ConsistencyLevel_QUORUM       ConsistencyLevel = 2
	ConsistencyLevel_LOCAL_QUORUM ConsistencyLevel = 3
	ConsistencyLevel_EACH_QUORUM  ConsistencyLevel = 4
	ConsistencyLevel_ALL          ConsistencyLevel = 5
	ConsistencyLevel_ANY          ConsistencyLevel = 6
	ConsistencyLevel_TWO          ConsistencyLevel = 7
	ConsistencyLevel_THREE        ConsistencyLevel = 8
)

func (p ConsistencyLevel) String() string {
	switch p {
	case ConsistencyLevel_ONE:
		return "ConsistencyLevel_ONE"
	case ConsistencyLevel_QUORUM:
		return "ConsistencyLevel_QUORUM"
	case ConsistencyLevel_LOCAL_QUORUM:
		return "ConsistencyLevel_LOCAL_QUORUM"
	case ConsistencyLevel_EACH_QUORUM:
		return "ConsistencyLevel_EACH_QUORUM"
	case ConsistencyLevel_ALL:
		return "ConsistencyLevel_ALL"
	case ConsistencyLevel_ANY:
		return "ConsistencyLevel_ANY"
	case ConsistencyLevel_TWO:
		return "ConsistencyLevel_TWO"
	case ConsistencyLevel_THREE:
		return "ConsistencyLevel_THREE"
	}
	return "<UNSET>"
}

func ConsistencyLevelFromString(s string) (ConsistencyLevel, error) {
	switch s {
	case "ConsistencyLevel_ONE":
		return ConsistencyLevel_ONE, nil
	case "ConsistencyLevel_QUORUM":
		return ConsistencyLevel_QUORUM, nil
	case "ConsistencyLevel_LOCAL_QUORUM":
		return ConsistencyLevel_LOCAL_QUORUM, nil
	case "ConsistencyLevel_EACH_QUORUM":
		return ConsistencyLevel_EACH_QUORUM, nil
	case "ConsistencyLevel_ALL":
		return ConsistencyLevel_ALL, nil
	case "ConsistencyLevel_ANY":
		return ConsistencyLevel_ANY, nil
	case "ConsistencyLevel_TWO":
		return ConsistencyLevel_TWO, nil
	case "ConsistencyLevel_THREE":
		return ConsistencyLevel_THREE, nil
	}
	return ConsistencyLevel(0), fmt.Errorf("not a valid ConsistencyLevel string")
}

func ConsistencyLevelPtr(v ConsistencyLevel) *ConsistencyLevel { return &v }

type IndexOperator int64

const (
	IndexOperator_EQ  IndexOperator = 0
	IndexOperator_GTE IndexOperator = 1
	IndexOperator_GT  IndexOperator = 2
	IndexOperator_LTE IndexOperator = 3
	IndexOperator_LT  IndexOperator = 4
)

func (p IndexOperator) String() string {
	switch p {
	case IndexOperator_EQ:
		return "IndexOperator_EQ"
	case IndexOperator_GTE:
		return "IndexOperator_GTE"
	case IndexOperator_GT:
		return "IndexOperator_GT"
	case IndexOperator_LTE:
		return "IndexOperator_LTE"
	case IndexOperator_LT:
		return "IndexOperator_LT"
	}
	return "<UNSET>"
}

func IndexOperatorFromString(s string) (IndexOperator, error) {
	switch s {
	case "IndexOperator_EQ":
		return IndexOperator_EQ, nil
	case "IndexOperator_GTE":
		return IndexOperator_GTE, nil
	case "IndexOperator_GT":
		return IndexOperator_GT, nil
	case "IndexOperator_LTE":
		return IndexOperator_LTE, nil
	case "IndexOperator_LT":
		return IndexOperator_LT, nil
	}
	return IndexOperator(0), fmt.Errorf("not a valid IndexOperator string")
}

func IndexOperatorPtr(v IndexOperator) *IndexOperator { return &v }

type IndexType int64

const (
	IndexType_KEYS       IndexType = 0
	IndexType_CUSTOM     IndexType = 1
	IndexType_COMPOSITES IndexType = 2
)

func (p IndexType) String() string {
	switch p {
	case IndexType_KEYS:
		return "IndexType_KEYS"
	case IndexType_CUSTOM:
		return "IndexType_CUSTOM"
	case IndexType_COMPOSITES:
		return "IndexType_COMPOSITES"
	}
	return "<UNSET>"
}

func IndexTypeFromString(s string) (IndexType, error) {
	switch s {
	case "IndexType_KEYS":
		return IndexType_KEYS, nil
	case "IndexType_CUSTOM":
		return IndexType_CUSTOM, nil
	case "IndexType_COMPOSITES":
		return IndexType_COMPOSITES, nil
	}
	return IndexType(0), fmt.Errorf("not a valid IndexType string")
}

func IndexTypePtr(v IndexType) *IndexType { return &v }

//CQL query compression
type Compression int64

const (
	Compression_GZIP Compression = 1
	Compression_NONE Compression = 2
)

func (p Compression) String() string {
	switch p {
	case Compression_GZIP:
		return "Compression_GZIP"
	case Compression_NONE:
		return "Compression_NONE"
	}
	return "<UNSET>"
}

func CompressionFromString(s string) (Compression, error) {
	switch s {
	case "Compression_GZIP":
		return Compression_GZIP, nil
	case "Compression_NONE":
		return Compression_NONE, nil
	}
	return Compression(0), fmt.Errorf("not a valid Compression string")
}

func CompressionPtr(v Compression) *Compression { return &v }

type CqlResultType int64

const (
	CqlResultType_ROWS CqlResultType = 1
	CqlResultType_VOID CqlResultType = 2
	CqlResultType_INT  CqlResultType = 3
)

func (p CqlResultType) String() string {
	switch p {
	case CqlResultType_ROWS:
		return "CqlResultType_ROWS"
	case CqlResultType_VOID:
		return "CqlResultType_VOID"
	case CqlResultType_INT:
		return "CqlResultType_INT"
	}
	return "<UNSET>"
}

func CqlResultTypeFromString(s string) (CqlResultType, error) {
	switch s {
	case "CqlResultType_ROWS":
		return CqlResultType_ROWS, nil
	case "CqlResultType_VOID":
		return CqlResultType_VOID, nil
	case "CqlResultType_INT":
		return CqlResultType_INT, nil
	}
	return CqlResultType(0), fmt.Errorf("not a valid CqlResultType string")
}

func CqlResultTypePtr(v CqlResultType) *CqlResultType { return &v }

type Column struct {
	Name      []byte `thrift:"name,1,required"`
	Value     []byte `thrift:"value,2"`
	Timestamp *int64 `thrift:"timestamp,3"`
	Ttl       *int32 `thrift:"ttl,4"`
}

func NewColumn() *Column {
	return &Column{}
}

func (p *Column) GetName() []byte {
	return p.Name
}

var Column_Value_DEFAULT []byte

func (p *Column) GetValue() []byte {
	return p.Value
}

var Column_Timestamp_DEFAULT int64

func (p *Column) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return Column_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var Column_Ttl_DEFAULT int32

func (p *Column) GetTtl() int32 {
	if !p.IsSetTtl() {
		return Column_Ttl_DEFAULT
	}
	return *p.Ttl
}
func (p *Column) IsSetName() bool {
	return true
}

func (p *Column) IsSetValue() bool {
	return p.Value != nil
}

func (p *Column) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Column) IsSetTtl() bool {
	return p.Ttl != nil
}

func (p *Column) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Column) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *Column) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *Column) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Column) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Ttl = &v
	}
	return nil
}

func (p *Column) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Column"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Column) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if p.IsSetValue() {
			if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
			}
			if err := oprot.WriteBinary(p.Value); err != nil {
				return fmt.Errorf("%T.value (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:value: %s", p, err)
			}
		}
	}
	return err
}

func (p *Column) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTtl() {
		if err := oprot.WriteFieldBegin("ttl", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:ttl: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Ttl)); err != nil {
			return fmt.Errorf("%T.ttl (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:ttl: %s", p, err)
		}
	}
	return err
}

func (p *Column) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Column(%+v)", *p)
}

type SuperColumn struct {
	Name    []byte    `thrift:"name,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewSuperColumn() *SuperColumn {
	return &SuperColumn{}
}

func (p *SuperColumn) GetName() []byte {
	return p.Name
}

func (p *SuperColumn) GetColumns() []*Column {
	return p.Columns
}
func (p *SuperColumn) IsSetName() bool {
	return true
}

func (p *SuperColumn) IsSetColumns() bool {
	return true
}

func (p *SuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SuperColumn) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *SuperColumn) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem0 := NewColumn()
		if err := _elem0.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem0, err)
		}
		p.Columns = append(p.Columns, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *SuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SuperColumn(%+v)", *p)
}

type CounterColumn struct {
	Name  []byte `thrift:"name,1,required"`
	Value int64  `thrift:"value,2,required"`
}

func NewCounterColumn() *CounterColumn {
	return &CounterColumn{}
}

func (p *CounterColumn) GetName() []byte {
	return p.Name
}

func (p *CounterColumn) GetValue() int64 {
	return p.Value
}
func (p *CounterColumn) IsSetName() bool {
	return true
}

func (p *CounterColumn) IsSetValue() bool {
	return true
}

func (p *CounterColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterColumn) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterColumn) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CounterColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:value: %s", p, err)
	}
	return err
}

func (p *CounterColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterColumn(%+v)", *p)
}

type CounterSuperColumn struct {
	Name    []byte           `thrift:"name,1,required"`
	Columns []*CounterColumn `thrift:"columns,2,required"`
}

func NewCounterSuperColumn() *CounterSuperColumn {
	return &CounterSuperColumn{}
}

func (p *CounterSuperColumn) GetName() []byte {
	return p.Name
}

func (p *CounterSuperColumn) GetColumns() []*CounterColumn {
	return p.Columns
}
func (p *CounterSuperColumn) IsSetName() bool {
	return true
}

func (p *CounterSuperColumn) IsSetColumns() bool {
	return true
}

func (p *CounterSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterSuperColumn) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterSuperColumn) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*CounterColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem1 := NewCounterColumn()
		if err := _elem1.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem1, err)
		}
		p.Columns = append(p.Columns, _elem1)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CounterSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterSuperColumn(%+v)", *p)
}

type ColumnOrSuperColumn struct {
	Column             *Column             `thrift:"column,1"`
	SuperColumn        *SuperColumn        `thrift:"super_column,2"`
	CounterColumn      *CounterColumn      `thrift:"counter_column,3"`
	CounterSuperColumn *CounterSuperColumn `thrift:"counter_super_column,4"`
}

func NewColumnOrSuperColumn() *ColumnOrSuperColumn {
	return &ColumnOrSuperColumn{}
}

var ColumnOrSuperColumn_Column_DEFAULT *Column

func (p *ColumnOrSuperColumn) GetColumn() *Column {
	return p.Column
}

var ColumnOrSuperColumn_SuperColumn_DEFAULT *SuperColumn

func (p *ColumnOrSuperColumn) GetSuperColumn() *SuperColumn {
	return p.SuperColumn
}

var ColumnOrSuperColumn_CounterColumn_DEFAULT *CounterColumn

func (p *ColumnOrSuperColumn) GetCounterColumn() *CounterColumn {
	return p.CounterColumn
}

var ColumnOrSuperColumn_CounterSuperColumn_DEFAULT *CounterSuperColumn

func (p *ColumnOrSuperColumn) GetCounterSuperColumn() *CounterSuperColumn {
	return p.CounterSuperColumn
}
func (p *ColumnOrSuperColumn) IsSetColumn() bool {
	return p.Column != ColumnOrSuperColumn_Column_DEFAULT
}

func (p *ColumnOrSuperColumn) IsSetSuperColumn() bool {
	return p.SuperColumn != ColumnOrSuperColumn_SuperColumn_DEFAULT
}

func (p *ColumnOrSuperColumn) IsSetCounterColumn() bool {
	return p.CounterColumn != ColumnOrSuperColumn_CounterColumn_DEFAULT
}

func (p *ColumnOrSuperColumn) IsSetCounterSuperColumn() bool {
	return p.CounterSuperColumn != ColumnOrSuperColumn_CounterSuperColumn_DEFAULT
}

func (p *ColumnOrSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) ReadField1(iprot thrift.TProtocol) error {
	p.Column = NewColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) ReadField2(iprot thrift.TProtocol) error {
	p.SuperColumn = NewSuperColumn()
	if err := p.SuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SuperColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) ReadField3(iprot thrift.TProtocol) error {
	p.CounterColumn = NewCounterColumn()
	if err := p.CounterColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) ReadField4(iprot thrift.TProtocol) error {
	p.CounterSuperColumn = NewCounterSuperColumn()
	if err := p.CounterSuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterSuperColumn, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnOrSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column: %s", p, err)
			}
			if err := p.Column.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Column, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := p.SuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SuperColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField3(oprot thrift.TProtocol) (err error) {
	if p.CounterColumn != nil {
		if p.IsSetCounterColumn() {
			if err := oprot.WriteFieldBegin("counter_column", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:counter_column: %s", p, err)
			}
			if err := p.CounterColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:counter_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField4(oprot thrift.TProtocol) (err error) {
	if p.CounterSuperColumn != nil {
		if p.IsSetCounterSuperColumn() {
			if err := oprot.WriteFieldBegin("counter_super_column", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:counter_super_column: %s", p, err)
			}
			if err := p.CounterSuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterSuperColumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:counter_super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnOrSuperColumn(%+v)", *p)
}

type NotFoundException struct {
}

func NewNotFoundException() *NotFoundException {
	return &NotFoundException{}
}

func (p *NotFoundException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NotFoundException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("NotFoundException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *NotFoundException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NotFoundException(%+v)", *p)
}

func (p *NotFoundException) Error() string {
	return p.String()
}

type InvalidRequestException struct {
	Why string `thrift:"why,1,required"`
}

func NewInvalidRequestException() *InvalidRequestException {
	return &InvalidRequestException{}
}

func (p *InvalidRequestException) GetWhy() string {
	return p.Why
}
func (p *InvalidRequestException) IsSetWhy() bool {
	return true
}

func (p *InvalidRequestException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InvalidRequestException) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *InvalidRequestException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InvalidRequestException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InvalidRequestException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *InvalidRequestException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InvalidRequestException(%+v)", *p)
}

func (p *InvalidRequestException) Error() string {
	return p.String()
}

type UnavailableException struct {
}

func NewUnavailableException() *UnavailableException {
	return &UnavailableException{}
}

func (p *UnavailableException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnavailableException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UnavailableException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *UnavailableException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnavailableException(%+v)", *p)
}

func (p *UnavailableException) Error() string {
	return p.String()
}

type TimedOutException struct {
	AcknowledgedBy         *int32 `thrift:"acknowledged_by,1"`
	AcknowledgedByBatchlog *bool  `thrift:"acknowledged_by_batchlog,2"`
}

func NewTimedOutException() *TimedOutException {
	return &TimedOutException{}
}

var TimedOutException_AcknowledgedBy_DEFAULT int32

func (p *TimedOutException) GetAcknowledgedBy() int32 {
	if !p.IsSetAcknowledgedBy() {
		return TimedOutException_AcknowledgedBy_DEFAULT
	}
	return *p.AcknowledgedBy
}

var TimedOutException_AcknowledgedByBatchlog_DEFAULT bool

func (p *TimedOutException) GetAcknowledgedByBatchlog() bool {
	if !p.IsSetAcknowledgedByBatchlog() {
		return TimedOutException_AcknowledgedByBatchlog_DEFAULT
	}
	return *p.AcknowledgedByBatchlog
}
func (p *TimedOutException) IsSetAcknowledgedBy() bool {
	return p.AcknowledgedBy != nil
}

func (p *TimedOutException) IsSetAcknowledgedByBatchlog() bool {
	return p.AcknowledgedByBatchlog != nil
}

func (p *TimedOutException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TimedOutException) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.AcknowledgedBy = &v
	}
	return nil
}

func (p *TimedOutException) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.AcknowledgedByBatchlog = &v
	}
	return nil
}

func (p *TimedOutException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TimedOutException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TimedOutException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedBy() {
		if err := oprot.WriteFieldBegin("acknowledged_by", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:acknowledged_by: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.AcknowledgedBy)); err != nil {
			return fmt.Errorf("%T.acknowledged_by (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:acknowledged_by: %s", p, err)
		}
	}
	return err
}

func (p *TimedOutException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedByBatchlog() {
		if err := oprot.WriteFieldBegin("acknowledged_by_batchlog", thrift.BOOL, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:acknowledged_by_batchlog: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.AcknowledgedByBatchlog)); err != nil {
			return fmt.Errorf("%T.acknowledged_by_batchlog (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:acknowledged_by_batchlog: %s", p, err)
		}
	}
	return err
}

func (p *TimedOutException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TimedOutException(%+v)", *p)
}

func (p *TimedOutException) Error() string {
	return p.String()
}

type AuthenticationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthenticationException() *AuthenticationException {
	return &AuthenticationException{}
}

func (p *AuthenticationException) GetWhy() string {
	return p.Why
}
func (p *AuthenticationException) IsSetWhy() bool {
	return true
}

func (p *AuthenticationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationException) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthenticationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthenticationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationException(%+v)", *p)
}

func (p *AuthenticationException) Error() string {
	return p.String()
}

type AuthorizationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthorizationException() *AuthorizationException {
	return &AuthorizationException{}
}

func (p *AuthorizationException) GetWhy() string {
	return p.Why
}
func (p *AuthorizationException) IsSetWhy() bool {
	return true
}

func (p *AuthorizationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthorizationException) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthorizationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthorizationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthorizationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthorizationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthorizationException(%+v)", *p)
}

func (p *AuthorizationException) Error() string {
	return p.String()
}

type SchemaDisagreementException struct {
}

func NewSchemaDisagreementException() *SchemaDisagreementException {
	return &SchemaDisagreementException{}
}

func (p *SchemaDisagreementException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SchemaDisagreementException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SchemaDisagreementException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SchemaDisagreementException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaDisagreementException(%+v)", *p)
}

func (p *SchemaDisagreementException) Error() string {
	return p.String()
}

type ColumnParent struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string `thrift:"column_family,3,required"`
	SuperColumn  []byte `thrift:"super_column,4"`
}

func NewColumnParent() *ColumnParent {
	return &ColumnParent{}
}

func (p *ColumnParent) GetColumnFamily() string {
	return p.ColumnFamily
}

var ColumnParent_SuperColumn_DEFAULT []byte

func (p *ColumnParent) GetSuperColumn() []byte {
	return p.SuperColumn
}
func (p *ColumnParent) IsSetColumnFamily() bool {
	return true
}

func (p *ColumnParent) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnParent) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnParent) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnParent) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnParent) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnParent"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnParent) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnParent) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnParent) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnParent(%+v)", *p)
}

type ColumnPath struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string `thrift:"column_family,3,required"`
	SuperColumn  []byte `thrift:"super_column,4"`
	Column       []byte `thrift:"column,5"`
}

func NewColumnPath() *ColumnPath {
	return &ColumnPath{}
}

func (p *ColumnPath) GetColumnFamily() string {
	return p.ColumnFamily
}

var ColumnPath_SuperColumn_DEFAULT []byte

func (p *ColumnPath) GetSuperColumn() []byte {
	return p.SuperColumn
}

var ColumnPath_Column_DEFAULT []byte

func (p *ColumnPath) GetColumn() []byte {
	return p.Column
}
func (p *ColumnPath) IsSetColumnFamily() bool {
	return true
}

func (p *ColumnPath) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnPath) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnPath) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnPath) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnPath) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnPath) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Column = v
	}
	return nil
}

func (p *ColumnPath) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnPath"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnPath) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnPath) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRING, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.Column); err != nil {
				return fmt.Errorf("%T.column (5) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnPath(%+v)", *p)
}

type SliceRange struct {
	Start    []byte `thrift:"start,1,required"`
	Finish   []byte `thrift:"finish,2,required"`
	Reversed bool   `thrift:"reversed,3,required"`
	Count    int32  `thrift:"count,4,required"`
}

func NewSliceRange() *SliceRange {
	return &SliceRange{
		Reversed: false,

		Count: 100,
	}
}

func (p *SliceRange) GetStart() []byte {
	return p.Start
}

func (p *SliceRange) GetFinish() []byte {
	return p.Finish
}

func (p *SliceRange) GetReversed() bool {
	return p.Reversed
}

func (p *SliceRange) GetCount() int32 {
	return p.Count
}
func (p *SliceRange) IsSetStart() bool {
	return true
}

func (p *SliceRange) IsSetFinish() bool {
	return true
}

func (p *SliceRange) IsSetReversed() bool {
	return true
}

func (p *SliceRange) IsSetCount() bool {
	return true
}

func (p *SliceRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SliceRange) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *SliceRange) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Finish = v
	}
	return nil
}

func (p *SliceRange) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Reversed = v
	}
	return nil
}

func (p *SliceRange) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *SliceRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SliceRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SliceRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Start != nil {
		if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:start: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Start); err != nil {
			return fmt.Errorf("%T.start (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:start: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Finish != nil {
		if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:finish: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Finish); err != nil {
			return fmt.Errorf("%T.finish (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:finish: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:reversed: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
		return fmt.Errorf("%T.reversed (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:reversed: %s", p, err)
	}
	return err
}

func (p *SliceRange) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:count: %s", p, err)
	}
	return err
}

func (p *SliceRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SliceRange(%+v)", *p)
}

type SlicePredicate struct {
	ColumnNames [][]byte    `thrift:"column_names,1"`
	SliceRange  *SliceRange `thrift:"slice_range,2"`
}

func NewSlicePredicate() *SlicePredicate {
	return &SlicePredicate{}
}

var SlicePredicate_ColumnNames_DEFAULT [][]byte

func (p *SlicePredicate) GetColumnNames() [][]byte {
	return p.ColumnNames
}

var SlicePredicate_SliceRange_DEFAULT *SliceRange

func (p *SlicePredicate) GetSliceRange() *SliceRange {
	return p.SliceRange
}
func (p *SlicePredicate) IsSetColumnNames() bool {
	return p.ColumnNames != nil
}

func (p *SlicePredicate) IsSetSliceRange() bool {
	return p.SliceRange != SlicePredicate_SliceRange_DEFAULT
}

func (p *SlicePredicate) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SlicePredicate) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.ColumnNames = tSlice
	for i := 0; i < size; i++ {
		var _elem2 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem2 = v
		}
		p.ColumnNames = append(p.ColumnNames, _elem2)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *SlicePredicate) ReadField2(iprot thrift.TProtocol) error {
	p.SliceRange = NewSliceRange()
	if err := p.SliceRange.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SliceRange, err)
	}
	return nil
}

func (p *SlicePredicate) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SlicePredicate"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SlicePredicate) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnNames != nil {
		if p.IsSetColumnNames() {
			if err := oprot.WriteFieldBegin("column_names", thrift.LIST, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_names: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.ColumnNames)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.ColumnNames {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_names: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SliceRange != nil {
		if p.IsSetSliceRange() {
			if err := oprot.WriteFieldBegin("slice_range", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:slice_range: %s", p, err)
			}
			if err := p.SliceRange.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SliceRange, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:slice_range: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SlicePredicate(%+v)", *p)
}

type IndexExpression struct {
	ColumnName []byte        `thrift:"column_name,1,required"`
	Op         IndexOperator `thrift:"op,2,required"`
	Value      []byte        `thrift:"value,3,required"`
}

func NewIndexExpression() *IndexExpression {
	return &IndexExpression{}
}

func (p *IndexExpression) GetColumnName() []byte {
	return p.ColumnName
}

func (p *IndexExpression) GetOp() IndexOperator {
	return p.Op
}

func (p *IndexExpression) GetValue() []byte {
	return p.Value
}
func (p *IndexExpression) IsSetColumnName() bool {
	return true
}

func (p *IndexExpression) IsSetOp() bool {
	return true
}

func (p *IndexExpression) IsSetValue() bool {
	return true
}

func (p *IndexExpression) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexExpression) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ColumnName = v
	}
	return nil
}

func (p *IndexExpression) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := IndexOperator(v)
		p.Op = temp
	}
	return nil
}

func (p *IndexExpression) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *IndexExpression) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexExpression"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexExpression) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnName != nil {
		if err := oprot.WriteFieldBegin("column_name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.ColumnName); err != nil {
			return fmt.Errorf("%T.column_name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_name: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("op", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:op: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Op)); err != nil {
		return fmt.Errorf("%T.op (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:op: %s", p, err)
	}
	return err
}

func (p *IndexExpression) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:value: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexExpression(%+v)", *p)
}

type IndexClause struct {
	Expressions []*IndexExpression `thrift:"expressions,1,required"`
	StartKey    []byte             `thrift:"start_key,2,required"`
	Count       int32              `thrift:"count,3,required"`
}

func NewIndexClause() *IndexClause {
	return &IndexClause{
		Count: 100,
	}
}

func (p *IndexClause) GetExpressions() []*IndexExpression {
	return p.Expressions
}

func (p *IndexClause) GetStartKey() []byte {
	return p.StartKey
}

func (p *IndexClause) GetCount() int32 {
	return p.Count
}
func (p *IndexClause) IsSetExpressions() bool {
	return true
}

func (p *IndexClause) IsSetStartKey() bool {
	return true
}

func (p *IndexClause) IsSetCount() bool {
	return true
}

func (p *IndexClause) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexClause) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*IndexExpression, 0, size)
	p.Expressions = tSlice
	for i := 0; i < size; i++ {
		_elem3 := NewIndexExpression()
		if err := _elem3.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem3, err)
		}
		p.Expressions = append(p.Expressions, _elem3)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *IndexClause) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *IndexClause) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *IndexClause) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexClause"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexClause) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Expressions != nil {
		if err := oprot.WriteFieldBegin("expressions", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:expressions: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expressions)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Expressions {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:expressions: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:start_key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartKey); err != nil {
			return fmt.Errorf("%T.start_key (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:start_key: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:count: %s", p, err)
	}
	return err
}

func (p *IndexClause) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexClause(%+v)", *p)
}

type KeyRange struct {
	StartKey   []byte             `thrift:"start_key,1"`
	EndKey     []byte             `thrift:"end_key,2"`
	StartToken *string            `thrift:"start_token,3"`
	EndToken   *string            `thrift:"end_token,4"`
	Count      int32              `thrift:"count,5,required"`
	RowFilter  []*IndexExpression `thrift:"row_filter,6"`
}

func NewKeyRange() *KeyRange {
	return &KeyRange{
		Count: 100,
	}
}

var KeyRange_StartKey_DEFAULT []byte

func (p *KeyRange) GetStartKey() []byte {
	return p.StartKey
}

var KeyRange_EndKey_DEFAULT []byte

func (p *KeyRange) GetEndKey() []byte {
	return p.EndKey
}

var KeyRange_StartToken_DEFAULT string

func (p *KeyRange) GetStartToken() string {
	if !p.IsSetStartToken() {
		return KeyRange_StartToken_DEFAULT
	}
	return *p.StartToken
}

var KeyRange_EndToken_DEFAULT string

func (p *KeyRange) GetEndToken() string {
	if !p.IsSetEndToken() {
		return KeyRange_EndToken_DEFAULT
	}
	return *p.EndToken
}

var KeyRange_RowFilter_DEFAULT []*IndexExpression

func (p *KeyRange) GetRowFilter() []*IndexExpression {
	return p.RowFilter
}

func (p *KeyRange) GetCount() int32 {
	return p.Count
}
func (p *KeyRange) IsSetStartKey() bool {
	return p.StartKey != nil
}

func (p *KeyRange) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *KeyRange) IsSetStartToken() bool {
	return p.StartToken != nil
}

func (p *KeyRange) IsSetEndToken() bool {
	return p.EndToken != nil
}

func (p *KeyRange) IsSetRowFilter() bool {
	return p.RowFilter != nil
}

func (p *KeyRange) IsSetCount() bool {
	return true
}

func (p *KeyRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyRange) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *KeyRange) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndKey = v
	}
	return nil
}

func (p *KeyRange) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.StartToken = &v
	}
	return nil
}

func (p *KeyRange) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.EndToken = &v
	}
	return nil
}

func (p *KeyRange) ReadField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*IndexExpression, 0, size)
	p.RowFilter = tSlice
	for i := 0; i < size; i++ {
		_elem4 := NewIndexExpression()
		if err := _elem4.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem4, err)
		}
		p.RowFilter = append(p.RowFilter, _elem4)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *KeyRange) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if p.IsSetStartKey() {
			if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:start_key: %s", p, err)
			}
			if err := oprot.WriteBinary(p.StartKey); err != nil {
				return fmt.Errorf("%T.start_key (1) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:start_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.EndKey != nil {
		if p.IsSetEndKey() {
			if err := oprot.WriteFieldBegin("end_key", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:end_key: %s", p, err)
			}
			if err := oprot.WriteBinary(p.EndKey); err != nil {
				return fmt.Errorf("%T.end_key (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:end_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetStartToken() {
		if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:start_token: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.StartToken)); err != nil {
			return fmt.Errorf("%T.start_token (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:start_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndToken() {
		if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:end_token: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.EndToken)); err != nil {
			return fmt.Errorf("%T.end_token (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:end_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:count: %s", p, err)
	}
	return err
}

func (p *KeyRange) writeField6(oprot thrift.TProtocol) (err error) {
	if p.RowFilter != nil {
		if p.IsSetRowFilter() {
			if err := oprot.WriteFieldBegin("row_filter", thrift.LIST, 6); err != nil {
				return fmt.Errorf("%T write field begin error 6:row_filter: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowFilter)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.RowFilter {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 6:row_filter: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyRange(%+v)", *p)
}

type KeySlice struct {
	Key     []byte                 `thrift:"key,1,required"`
	Columns []*ColumnOrSuperColumn `thrift:"columns,2,required"`
}

func NewKeySlice() *KeySlice {
	return &KeySlice{}
}

func (p *KeySlice) GetKey() []byte {
	return p.Key
}

func (p *KeySlice) GetColumns() []*ColumnOrSuperColumn {
	return p.Columns
}
func (p *KeySlice) IsSetKey() bool {
	return true
}

func (p *KeySlice) IsSetColumns() bool {
	return true
}

func (p *KeySlice) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeySlice) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeySlice) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ColumnOrSuperColumn, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem5 := NewColumnOrSuperColumn()
		if err := _elem5.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem5, err)
		}
		p.Columns = append(p.Columns, _elem5)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *KeySlice) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeySlice"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeySlice) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeySlice(%+v)", *p)
}

type KeyCount struct {
	Key   []byte `thrift:"key,1,required"`
	Count int32  `thrift:"count,2,required"`
}

func NewKeyCount() *KeyCount {
	return &KeyCount{}
}

func (p *KeyCount) GetKey() []byte {
	return p.Key
}

func (p *KeyCount) GetCount() int32 {
	return p.Count
}
func (p *KeyCount) IsSetKey() bool {
	return true
}

func (p *KeyCount) IsSetCount() bool {
	return true
}

func (p *KeyCount) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyCount) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeyCount) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyCount) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyCount"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyCount) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeyCount) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *KeyCount) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyCount(%+v)", *p)
}

type Deletion struct {
	Timestamp   *int64          `thrift:"timestamp,1"`
	SuperColumn []byte          `thrift:"super_column,2"`
	Predicate   *SlicePredicate `thrift:"predicate,3"`
}

func NewDeletion() *Deletion {
	return &Deletion{}
}

var Deletion_Timestamp_DEFAULT int64

func (p *Deletion) GetTimestamp() int64 {
	if !p.IsSetTimestamp() {
		return Deletion_Timestamp_DEFAULT
	}
	return *p.Timestamp
}

var Deletion_SuperColumn_DEFAULT []byte

func (p *Deletion) GetSuperColumn() []byte {
	return p.SuperColumn
}

var Deletion_Predicate_DEFAULT *SlicePredicate

func (p *Deletion) GetPredicate() *SlicePredicate {
	return p.Predicate
}
func (p *Deletion) IsSetTimestamp() bool {
	return p.Timestamp != nil
}

func (p *Deletion) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *Deletion) IsSetPredicate() bool {
	return p.Predicate != Deletion_Predicate_DEFAULT
}

func (p *Deletion) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Deletion) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Timestamp = &v
	}
	return nil
}

func (p *Deletion) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *Deletion) ReadField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate, err)
	}
	return nil
}

func (p *Deletion) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Deletion"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Deletion) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Deletion) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (2) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if p.IsSetPredicate() {
			if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
			}
			if err := p.Predicate.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Predicate, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Deletion(%+v)", *p)
}

type Mutation struct {
	ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"column_or_supercolumn,1"`
	Deletion            *Deletion            `thrift:"deletion,2"`
}

func NewMutation() *Mutation {
	return &Mutation{}
}

var Mutation_ColumnOrSupercolumn_DEFAULT *ColumnOrSuperColumn

func (p *Mutation) GetColumnOrSupercolumn() *ColumnOrSuperColumn {
	return p.ColumnOrSupercolumn
}

var Mutation_Deletion_DEFAULT *Deletion

func (p *Mutation) GetDeletion() *Deletion {
	return p.Deletion
}
func (p *Mutation) IsSetColumnOrSupercolumn() bool {
	return p.ColumnOrSupercolumn != Mutation_ColumnOrSupercolumn_DEFAULT
}

func (p *Mutation) IsSetDeletion() bool {
	return p.Deletion != Mutation_Deletion_DEFAULT
}

func (p *Mutation) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Mutation) ReadField1(iprot thrift.TProtocol) error {
	p.ColumnOrSupercolumn = NewColumnOrSuperColumn()
	if err := p.ColumnOrSupercolumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnOrSupercolumn, err)
	}
	return nil
}

func (p *Mutation) ReadField2(iprot thrift.TProtocol) error {
	p.Deletion = NewDeletion()
	if err := p.Deletion.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Deletion, err)
	}
	return nil
}

func (p *Mutation) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Mutation"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *Mutation) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnOrSupercolumn != nil {
		if p.IsSetColumnOrSupercolumn() {
			if err := oprot.WriteFieldBegin("column_or_supercolumn", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_or_supercolumn: %s", p, err)
			}
			if err := p.ColumnOrSupercolumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.ColumnOrSupercolumn, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_or_supercolumn: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Deletion != nil {
		if p.IsSetDeletion() {
			if err := oprot.WriteFieldBegin("deletion", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:deletion: %s", p, err)
			}
			if err := p.Deletion.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Deletion, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:deletion: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Mutation(%+v)", *p)
}

type EndpointDetails struct {
	Host       string  `thrift:"host,1"`
	Datacenter string  `thrift:"datacenter,2"`
	Rack       *string `thrift:"rack,3"`
}

func NewEndpointDetails() *EndpointDetails {
	return &EndpointDetails{}
}

func (p *EndpointDetails) GetHost() string {
	return p.Host
}

func (p *EndpointDetails) GetDatacenter() string {
	return p.Datacenter
}

var EndpointDetails_Rack_DEFAULT string

func (p *EndpointDetails) GetRack() string {
	if !p.IsSetRack() {
		return EndpointDetails_Rack_DEFAULT
	}
	return *p.Rack
}
func (p *EndpointDetails) IsSetHost() bool {
	return true
}

func (p *EndpointDetails) IsSetDatacenter() bool {
	return true
}

func (p *EndpointDetails) IsSetRack() bool {
	return p.Rack != nil
}

func (p *EndpointDetails) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EndpointDetails) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Host = v
	}
	return nil
}

func (p *EndpointDetails) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Datacenter = v
	}
	return nil
}

func (p *EndpointDetails) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Rack = &v
	}
	return nil
}

func (p *EndpointDetails) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EndpointDetails"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EndpointDetails) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:host: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Host)); err != nil {
		return fmt.Errorf("%T.host (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:host: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datacenter", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:datacenter: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Datacenter)); err != nil {
		return fmt.Errorf("%T.datacenter (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:datacenter: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRack() {
		if err := oprot.WriteFieldBegin("rack", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:rack: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Rack)); err != nil {
			return fmt.Errorf("%T.rack (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:rack: %s", p, err)
		}
	}
	return err
}

func (p *EndpointDetails) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EndpointDetails(%+v)", *p)
}

type TokenRange struct {
	StartToken      string             `thrift:"start_token,1,required"`
	EndToken        string             `thrift:"end_token,2,required"`
	Endpoints       []string           `thrift:"endpoints,3,required"`
	RpcEndpoints    []string           `thrift:"rpc_endpoints,4"`
	EndpointDetails []*EndpointDetails `thrift:"endpoint_details,5"`
}

func NewTokenRange() *TokenRange {
	return &TokenRange{}
}

func (p *TokenRange) GetStartToken() string {
	return p.StartToken
}

func (p *TokenRange) GetEndToken() string {
	return p.EndToken
}

func (p *TokenRange) GetEndpoints() []string {
	return p.Endpoints
}

var TokenRange_RpcEndpoints_DEFAULT []string

func (p *TokenRange) GetRpcEndpoints() []string {
	return p.RpcEndpoints
}

var TokenRange_EndpointDetails_DEFAULT []*EndpointDetails

func (p *TokenRange) GetEndpointDetails() []*EndpointDetails {
	return p.EndpointDetails
}
func (p *TokenRange) IsSetStartToken() bool {
	return true
}

func (p *TokenRange) IsSetEndToken() bool {
	return true
}

func (p *TokenRange) IsSetEndpoints() bool {
	return true
}

func (p *TokenRange) IsSetRpcEndpoints() bool {
	return p.RpcEndpoints != nil
}

func (p *TokenRange) IsSetEndpointDetails() bool {
	return p.EndpointDetails != nil
}

func (p *TokenRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TokenRange) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *TokenRange) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *TokenRange) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.Endpoints = tSlice
	for i := 0; i < size; i++ {
		var _elem6 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem6 = v
		}
		p.Endpoints = append(p.Endpoints, _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TokenRange) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.RpcEndpoints = tSlice
	for i := 0; i < size; i++ {
		var _elem7 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem7 = v
		}
		p.RpcEndpoints = append(p.RpcEndpoints, _elem7)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TokenRange) ReadField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*EndpointDetails, 0, size)
	p.EndpointDetails = tSlice
	for i := 0; i < size; i++ {
		_elem8 := NewEndpointDetails()
		if err := _elem8.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem8, err)
		}
		p.EndpointDetails = append(p.EndpointDetails, _elem8)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TokenRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TokenRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TokenRange) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Endpoints != nil {
		if err := oprot.WriteFieldBegin("endpoints", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:endpoints: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Endpoints)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Endpoints {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:endpoints: %s", p, err)
		}
	}
	return err
}

func (p *TokenRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.RpcEndpoints != nil {
		if p.IsSetRpcEndpoints() {
			if err := oprot.WriteFieldBegin("rpc_endpoints", thrift.LIST, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:rpc_endpoints: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.RpcEndpoints)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.RpcEndpoints {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:rpc_endpoints: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) writeField5(oprot thrift.TProtocol) (err error) {
	if p.EndpointDetails != nil {
		if p.IsSetEndpointDetails() {
			if err := oprot.WriteFieldBegin("endpoint_details", thrift.LIST, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:endpoint_details: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.EndpointDetails)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.EndpointDetails {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:endpoint_details: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TokenRange(%+v)", *p)
}

type AuthenticationRequest struct {
	Credentials map[string]string `thrift:"credentials,1,required"`
}

func NewAuthenticationRequest() *AuthenticationRequest {
	return &AuthenticationRequest{}
}

func (p *AuthenticationRequest) GetCredentials() map[string]string {
	return p.Credentials
}
func (p *AuthenticationRequest) IsSetCredentials() bool {
	return true
}

func (p *AuthenticationRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationRequest) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Credentials = tMap
	for i := 0; i < size; i++ {
		var _key9 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key9 = v
		}
		var _val10 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val10 = v
		}
		p.Credentials[_key9] = _val10
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *AuthenticationRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Credentials != nil {
		if err := oprot.WriteFieldBegin("credentials", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:credentials: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Credentials)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Credentials {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:credentials: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticationRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationRequest(%+v)", *p)
}

type ColumnDef struct {
	Name            []byte            `thrift:"name,1,required"`
	ValidationClass string            `thrift:"validation_class,2,required"`
	IndexType       *IndexType        `thrift:"index_type,3"`
	IndexName       *string           `thrift:"index_name,4"`
	IndexOptions    map[string]string `thrift:"index_options,5"`
}

func NewColumnDef() *ColumnDef {
	return &ColumnDef{}
}

func (p *ColumnDef) GetName() []byte {
	return p.Name
}

func (p *ColumnDef) GetValidationClass() string {
	return p.ValidationClass
}

var ColumnDef_IndexType_DEFAULT IndexType

func (p *ColumnDef) GetIndexType() IndexType {
	if !p.IsSetIndexType() {
		return ColumnDef_IndexType_DEFAULT
	}
	return *p.IndexType
}

var ColumnDef_IndexName_DEFAULT string

func (p *ColumnDef) GetIndexName() string {
	if !p.IsSetIndexName() {
		return ColumnDef_IndexName_DEFAULT
	}
	return *p.IndexName
}

var ColumnDef_IndexOptions_DEFAULT map[string]string

func (p *ColumnDef) GetIndexOptions() map[string]string {
	return p.IndexOptions
}
func (p *ColumnDef) IsSetName() bool {
	return true
}

func (p *ColumnDef) IsSetValidationClass() bool {
	return true
}

func (p *ColumnDef) IsSetIndexType() bool {
	return p.IndexType != nil
}

func (p *ColumnDef) IsSetIndexName() bool {
	return p.IndexName != nil
}

func (p *ColumnDef) IsSetIndexOptions() bool {
	return p.IndexOptions != nil
}

func (p *ColumnDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnDef) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *ColumnDef) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.ValidationClass = v
	}
	return nil
}

func (p *ColumnDef) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := IndexType(v)
		p.IndexType = &temp
	}
	return nil
}

func (p *ColumnDef) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.IndexName = &v
	}
	return nil
}

func (p *ColumnDef) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.IndexOptions = tMap
	for i := 0; i < size; i++ {
		var _key11 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key11 = v
		}
		var _val12 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val12 = v
		}
		p.IndexOptions[_key11] = _val12
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ColumnDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnDef) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("validation_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:validation_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ValidationClass)); err != nil {
		return fmt.Errorf("%T.validation_class (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:validation_class: %s", p, err)
	}
	return err
}

func (p *ColumnDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexType() {
		if err := oprot.WriteFieldBegin("index_type", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:index_type: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.IndexType)); err != nil {
			return fmt.Errorf("%T.index_type (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:index_type: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexName() {
		if err := oprot.WriteFieldBegin("index_name", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:index_name: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.IndexName)); err != nil {
			return fmt.Errorf("%T.index_name (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:index_name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IndexOptions != nil {
		if p.IsSetIndexOptions() {
			if err := oprot.WriteFieldBegin("index_options", thrift.MAP, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:index_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.IndexOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range p.IndexOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:index_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnDef(%+v)", *p)
}

type CfDef struct {
	Keyspace   string `thrift:"keyspace,1,required"`
	Name       string `thrift:"name,2,required"`
	ColumnType string `thrift:"column_type,3"`
	// unused field # 4
	ComparatorType    string  `thrift:"comparator_type,5"`
	SubcomparatorType *string `thrift:"subcomparator_type,6"`
	// unused field # 7
	Comment      *string  `thrift:"comment,8"`
	RowCacheSize *float64 `thrift:"row_cache_size,9"`
	// unused field # 10
	KeyCacheSize                 *float64          `thrift:"key_cache_size,11"`
	ReadRepairChance             *float64          `thrift:"read_repair_chance,12"`
	ColumnMetadata               []*ColumnDef      `thrift:"column_metadata,13"`
	GcGraceSeconds               *int32            `thrift:"gc_grace_seconds,14"`
	DefaultValidationClass       *string           `thrift:"default_validation_class,15"`
	Id                           *int32            `thrift:"id,16"`
	MinCompactionThreshold       *int32            `thrift:"min_compaction_threshold,17"`
	MaxCompactionThreshold       *int32            `thrift:"max_compaction_threshold,18"`
	RowCacheSavePeriodInSeconds  *int32            `thrift:"row_cache_save_period_in_seconds,19"`
	KeyCacheSavePeriodInSeconds  *int32            `thrift:"key_cache_save_period_in_seconds,20"`
	MemtableFlushAfterMins       *int32            `thrift:"memtable_flush_after_mins,21"`
	MemtableThroughputInMb       *int32            `thrift:"memtable_throughput_in_mb,22"`
	MemtableOperationsInMillions *float64          `thrift:"memtable_operations_in_millions,23"`
	ReplicateOnWrite             *bool             `thrift:"replicate_on_write,24"`
	MergeShardsChance            *float64          `thrift:"merge_shards_chance,25"`
	KeyValidationClass           *string           `thrift:"key_validation_class,26"`
	RowCacheProvider             *string           `thrift:"row_cache_provider,27"`
	KeyAlias                     []byte            `thrift:"key_alias,28"`
	CompactionStrategy           *string           `thrift:"compaction_strategy,29"`
	CompactionStrategyOptions    map[string]string `thrift:"compaction_strategy_options,30"`
	RowCacheKeysToSave           *int32            `thrift:"row_cache_keys_to_save,31"`
	CompressionOptions           map[string]string `thrift:"compression_options,32"`
	BloomFilterFpChance          *float64          `thrift:"bloom_filter_fp_chance,33"`
	Caching                      string            `thrift:"caching,34"`
	// unused field # 35
	// unused field # 36
	DclocalReadRepairChance float64 `thrift:"dclocal_read_repair_chance,37"`
	PopulateIoCacheOnFlush  *bool   `thrift:"populate_io_cache_on_flush,38"`
}

func NewCfDef() *CfDef {
	return &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		DclocalReadRepairChance: 0,
	}
}

func (p *CfDef) GetKeyspace() string {
	return p.Keyspace
}

func (p *CfDef) GetName() string {
	return p.Name
}

var CfDef_ColumnType_DEFAULT string = "Standard"

func (p *CfDef) GetColumnType() string {
	return p.ColumnType
}

var CfDef_ComparatorType_DEFAULT string = "BytesType"

func (p *CfDef) GetComparatorType() string {
	return p.ComparatorType
}

var CfDef_SubcomparatorType_DEFAULT string

func (p *CfDef) GetSubcomparatorType() string {
	if !p.IsSetSubcomparatorType() {
		return CfDef_SubcomparatorType_DEFAULT
	}
	return *p.SubcomparatorType
}

var CfDef_Comment_DEFAULT string

func (p *CfDef) GetComment() string {
	if !p.IsSetComment() {
		return CfDef_Comment_DEFAULT
	}
	return *p.Comment
}

var CfDef_ReadRepairChance_DEFAULT float64

func (p *CfDef) GetReadRepairChance() float64 {
	if !p.IsSetReadRepairChance() {
		return CfDef_ReadRepairChance_DEFAULT
	}
	return *p.ReadRepairChance
}

var CfDef_ColumnMetadata_DEFAULT []*ColumnDef

func (p *CfDef) GetColumnMetadata() []*ColumnDef {
	return p.ColumnMetadata
}

var CfDef_GcGraceSeconds_DEFAULT int32

func (p *CfDef) GetGcGraceSeconds() int32 {
	if !p.IsSetGcGraceSeconds() {
		return CfDef_GcGraceSeconds_DEFAULT
	}
	return *p.GcGraceSeconds
}

var CfDef_DefaultValidationClass_DEFAULT string

func (p *CfDef) GetDefaultValidationClass() string {
	if !p.IsSetDefaultValidationClass() {
		return CfDef_DefaultValidationClass_DEFAULT
	}
	return *p.DefaultValidationClass
}

var CfDef_Id_DEFAULT int32

func (p *CfDef) GetId() int32 {
	if !p.IsSetId() {
		return CfDef_Id_DEFAULT
	}
	return *p.Id
}

var CfDef_MinCompactionThreshold_DEFAULT int32

func (p *CfDef) GetMinCompactionThreshold() int32 {
	if !p.IsSetMinCompactionThreshold() {
		return CfDef_MinCompactionThreshold_DEFAULT
	}
	return *p.MinCompactionThreshold
}

var CfDef_MaxCompactionThreshold_DEFAULT int32

func (p *CfDef) GetMaxCompactionThreshold() int32 {
	if !p.IsSetMaxCompactionThreshold() {
		return CfDef_MaxCompactionThreshold_DEFAULT
	}
	return *p.MaxCompactionThreshold
}

var CfDef_ReplicateOnWrite_DEFAULT bool

func (p *CfDef) GetReplicateOnWrite() bool {
	if !p.IsSetReplicateOnWrite() {
		return CfDef_ReplicateOnWrite_DEFAULT
	}
	return *p.ReplicateOnWrite
}

var CfDef_KeyValidationClass_DEFAULT string

func (p *CfDef) GetKeyValidationClass() string {
	if !p.IsSetKeyValidationClass() {
		return CfDef_KeyValidationClass_DEFAULT
	}
	return *p.KeyValidationClass
}

var CfDef_KeyAlias_DEFAULT []byte

func (p *CfDef) GetKeyAlias() []byte {
	return p.KeyAlias
}

var CfDef_CompactionStrategy_DEFAULT string

func (p *CfDef) GetCompactionStrategy() string {
	if !p.IsSetCompactionStrategy() {
		return CfDef_CompactionStrategy_DEFAULT
	}
	return *p.CompactionStrategy
}

var CfDef_CompactionStrategyOptions_DEFAULT map[string]string

func (p *CfDef) GetCompactionStrategyOptions() map[string]string {
	return p.CompactionStrategyOptions
}

var CfDef_CompressionOptions_DEFAULT map[string]string

func (p *CfDef) GetCompressionOptions() map[string]string {
	return p.CompressionOptions
}

var CfDef_BloomFilterFpChance_DEFAULT float64

func (p *CfDef) GetBloomFilterFpChance() float64 {
	if !p.IsSetBloomFilterFpChance() {
		return CfDef_BloomFilterFpChance_DEFAULT
	}
	return *p.BloomFilterFpChance
}

var CfDef_Caching_DEFAULT string = "keys_only"

func (p *CfDef) GetCaching() string {
	return p.Caching
}

var CfDef_DclocalReadRepairChance_DEFAULT float64 = 0

func (p *CfDef) GetDclocalReadRepairChance() float64 {
	return p.DclocalReadRepairChance
}

var CfDef_PopulateIoCacheOnFlush_DEFAULT bool

func (p *CfDef) GetPopulateIoCacheOnFlush() bool {
	if !p.IsSetPopulateIoCacheOnFlush() {
		return CfDef_PopulateIoCacheOnFlush_DEFAULT
	}
	return *p.PopulateIoCacheOnFlush
}

var CfDef_RowCacheSize_DEFAULT float64

func (p *CfDef) GetRowCacheSize() float64 {
	if !p.IsSetRowCacheSize() {
		return CfDef_RowCacheSize_DEFAULT
	}
	return *p.RowCacheSize
}

var CfDef_KeyCacheSize_DEFAULT float64

func (p *CfDef) GetKeyCacheSize() float64 {
	if !p.IsSetKeyCacheSize() {
		return CfDef_KeyCacheSize_DEFAULT
	}
	return *p.KeyCacheSize
}

var CfDef_RowCacheSavePeriodInSeconds_DEFAULT int32

func (p *CfDef) GetRowCacheSavePeriodInSeconds() int32 {
	if !p.IsSetRowCacheSavePeriodInSeconds() {
		return CfDef_RowCacheSavePeriodInSeconds_DEFAULT
	}
	return *p.RowCacheSavePeriodInSeconds
}

var CfDef_KeyCacheSavePeriodInSeconds_DEFAULT int32

func (p *CfDef) GetKeyCacheSavePeriodInSeconds() int32 {
	if !p.IsSetKeyCacheSavePeriodInSeconds() {
		return CfDef_KeyCacheSavePeriodInSeconds_DEFAULT
	}
	return *p.KeyCacheSavePeriodInSeconds
}

var CfDef_MemtableFlushAfterMins_DEFAULT int32

func (p *CfDef) GetMemtableFlushAfterMins() int32 {
	if !p.IsSetMemtableFlushAfterMins() {
		return CfDef_MemtableFlushAfterMins_DEFAULT
	}
	return *p.MemtableFlushAfterMins
}

var CfDef_MemtableThroughputInMb_DEFAULT int32

func (p *CfDef) GetMemtableThroughputInMb() int32 {
	if !p.IsSetMemtableThroughputInMb() {
		return CfDef_MemtableThroughputInMb_DEFAULT
	}
	return *p.MemtableThroughputInMb
}

var CfDef_MemtableOperationsInMillions_DEFAULT float64

func (p *CfDef) GetMemtableOperationsInMillions() float64 {
	if !p.IsSetMemtableOperationsInMillions() {
		return CfDef_MemtableOperationsInMillions_DEFAULT
	}
	return *p.MemtableOperationsInMillions
}

var CfDef_MergeShardsChance_DEFAULT float64

func (p *CfDef) GetMergeShardsChance() float64 {
	if !p.IsSetMergeShardsChance() {
		return CfDef_MergeShardsChance_DEFAULT
	}
	return *p.MergeShardsChance
}

var CfDef_RowCacheProvider_DEFAULT string

func (p *CfDef) GetRowCacheProvider() string {
	if !p.IsSetRowCacheProvider() {
		return CfDef_RowCacheProvider_DEFAULT
	}
	return *p.RowCacheProvider
}

var CfDef_RowCacheKeysToSave_DEFAULT int32

func (p *CfDef) GetRowCacheKeysToSave() int32 {
	if !p.IsSetRowCacheKeysToSave() {
		return CfDef_RowCacheKeysToSave_DEFAULT
	}
	return *p.RowCacheKeysToSave
}
func (p *CfDef) IsSetKeyspace() bool {
	return true
}

func (p *CfDef) IsSetName() bool {
	return true
}

func (p *CfDef) IsSetColumnType() bool {
	return p.ColumnType != CfDef_ColumnType_DEFAULT
}

func (p *CfDef) IsSetComparatorType() bool {
	return p.ComparatorType != CfDef_ComparatorType_DEFAULT
}

func (p *CfDef) IsSetSubcomparatorType() bool {
	return p.SubcomparatorType != nil
}

func (p *CfDef) IsSetComment() bool {
	return p.Comment != nil
}

func (p *CfDef) IsSetReadRepairChance() bool {
	return p.ReadRepairChance != nil
}

func (p *CfDef) IsSetColumnMetadata() bool {
	return p.ColumnMetadata != nil
}

func (p *CfDef) IsSetGcGraceSeconds() bool {
	return p.GcGraceSeconds != nil
}

func (p *CfDef) IsSetDefaultValidationClass() bool {
	return p.DefaultValidationClass != nil
}

func (p *CfDef) IsSetId() bool {
	return p.Id != nil
}

func (p *CfDef) IsSetMinCompactionThreshold() bool {
	return p.MinCompactionThreshold != nil
}

func (p *CfDef) IsSetMaxCompactionThreshold() bool {
	return p.MaxCompactionThreshold != nil
}

func (p *CfDef) IsSetReplicateOnWrite() bool {
	return p.ReplicateOnWrite != nil
}

func (p *CfDef) IsSetKeyValidationClass() bool {
	return p.KeyValidationClass != nil
}

func (p *CfDef) IsSetKeyAlias() bool {
	return p.KeyAlias != nil
}

func (p *CfDef) IsSetCompactionStrategy() bool {
	return p.CompactionStrategy != nil
}

func (p *CfDef) IsSetCompactionStrategyOptions() bool {
	return p.CompactionStrategyOptions != nil
}

func (p *CfDef) IsSetCompressionOptions() bool {
	return p.CompressionOptions != nil
}

func (p *CfDef) IsSetBloomFilterFpChance() bool {
	return p.BloomFilterFpChance != nil
}

func (p *CfDef) IsSetCaching() bool {
	return p.Caching != CfDef_Caching_DEFAULT
}

func (p *CfDef) IsSetDclocalReadRepairChance() bool {
	return p.DclocalReadRepairChance != CfDef_DclocalReadRepairChance_DEFAULT
}

func (p *CfDef) IsSetPopulateIoCacheOnFlush() bool {
	return p.PopulateIoCacheOnFlush != nil
}

func (p *CfDef) IsSetRowCacheSize() bool {
	return p.RowCacheSize != nil
}

func (p *CfDef) IsSetKeyCacheSize() bool {
	return p.KeyCacheSize != nil
}

func (p *CfDef) IsSetRowCacheSavePeriodInSeconds() bool {
	return p.RowCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetKeyCacheSavePeriodInSeconds() bool {
	return p.KeyCacheSavePeriodInSeconds != nil
}

func (p *CfDef) IsSetMemtableFlushAfterMins() bool {
	return p.MemtableFlushAfterMins != nil
}

func (p *CfDef) IsSetMemtableThroughputInMb() bool {
	return p.MemtableThroughputInMb != nil
}

func (p *CfDef) IsSetMemtableOperationsInMillions() bool {
	return p.MemtableOperationsInMillions != nil
}

func (p *CfDef) IsSetMergeShardsChance() bool {
	return p.MergeShardsChance != nil
}

func (p *CfDef) IsSetRowCacheProvider() bool {
	return p.RowCacheProvider != nil
}

func (p *CfDef) IsSetRowCacheKeysToSave() bool {
	return p.RowCacheKeysToSave != nil
}

func (p *CfDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 8:
			if err := p.ReadField8(iprot); err != nil {
				return err
			}
		case 12:
			if err := p.ReadField12(iprot); err != nil {
				return err
			}
		case 13:
			if err := p.ReadField13(iprot); err != nil {
				return err
			}
		case 14:
			if err := p.ReadField14(iprot); err != nil {
				return err
			}
		case 15:
			if err := p.ReadField15(iprot); err != nil {
				return err
			}
		case 16:
			if err := p.ReadField16(iprot); err != nil {
				return err
			}
		case 17:
			if err := p.ReadField17(iprot); err != nil {
				return err
			}
		case 18:
			if err := p.ReadField18(iprot); err != nil {
				return err
			}
		case 24:
			if err := p.ReadField24(iprot); err != nil {
				return err
			}
		case 26:
			if err := p.ReadField26(iprot); err != nil {
				return err
			}
		case 28:
			if err := p.ReadField28(iprot); err != nil {
				return err
			}
		case 29:
			if err := p.ReadField29(iprot); err != nil {
				return err
			}
		case 30:
			if err := p.ReadField30(iprot); err != nil {
				return err
			}
		case 32:
			if err := p.ReadField32(iprot); err != nil {
				return err
			}
		case 33:
			if err := p.ReadField33(iprot); err != nil {
				return err
			}
		case 34:
			if err := p.ReadField34(iprot); err != nil {
				return err
			}
		case 37:
			if err := p.ReadField37(iprot); err != nil {
				return err
			}
		case 38:
			if err := p.ReadField38(iprot); err != nil {
				return err
			}
		case 9:
			if err := p.ReadField9(iprot); err != nil {
				return err
			}
		case 11:
			if err := p.ReadField11(iprot); err != nil {
				return err
			}
		case 19:
			if err := p.ReadField19(iprot); err != nil {
				return err
			}
		case 20:
			if err := p.ReadField20(iprot); err != nil {
				return err
			}
		case 21:
			if err := p.ReadField21(iprot); err != nil {
				return err
			}
		case 22:
			if err := p.ReadField22(iprot); err != nil {
				return err
			}
		case 23:
			if err := p.ReadField23(iprot); err != nil {
				return err
			}
		case 25:
			if err := p.ReadField25(iprot); err != nil {
				return err
			}
		case 27:
			if err := p.ReadField27(iprot); err != nil {
				return err
			}
		case 31:
			if err := p.ReadField31(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CfDef) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CfDef) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *CfDef) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.ColumnType = v
	}
	return nil
}

func (p *CfDef) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.ComparatorType = v
	}
	return nil
}

func (p *CfDef) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.SubcomparatorType = &v
	}
	return nil
}

func (p *CfDef) ReadField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 8: %s", err)
	} else {
		p.Comment = &v
	}
	return nil
}

func (p *CfDef) ReadField12(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 12: %s", err)
	} else {
		p.ReadRepairChance = &v
	}
	return nil
}

func (p *CfDef) ReadField13(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ColumnDef, 0, size)
	p.ColumnMetadata = tSlice
	for i := 0; i < size; i++ {
		_elem13 := NewColumnDef()
		if err := _elem13.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem13, err)
		}
		p.ColumnMetadata = append(p.ColumnMetadata, _elem13)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CfDef) ReadField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 14: %s", err)
	} else {
		p.GcGraceSeconds = &v
	}
	return nil
}

func (p *CfDef) ReadField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 15: %s", err)
	} else {
		p.DefaultValidationClass = &v
	}
	return nil
}

func (p *CfDef) ReadField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 16: %s", err)
	} else {
		p.Id = &v
	}
	return nil
}

func (p *CfDef) ReadField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 17: %s", err)
	} else {
		p.MinCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) ReadField18(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 18: %s", err)
	} else {
		p.MaxCompactionThreshold = &v
	}
	return nil
}

func (p *CfDef) ReadField24(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 24: %s", err)
	} else {
		p.ReplicateOnWrite = &v
	}
	return nil
}

func (p *CfDef) ReadField26(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 26: %s", err)
	} else {
		p.KeyValidationClass = &v
	}
	return nil
}

func (p *CfDef) ReadField28(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 28: %s", err)
	} else {
		p.KeyAlias = v
	}
	return nil
}

func (p *CfDef) ReadField29(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 29: %s", err)
	} else {
		p.CompactionStrategy = &v
	}
	return nil
}

func (p *CfDef) ReadField30(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.CompactionStrategyOptions = tMap
	for i := 0; i < size; i++ {
		var _key14 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key14 = v
		}
		var _val15 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val15 = v
		}
		p.CompactionStrategyOptions[_key14] = _val15
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *CfDef) ReadField32(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.CompressionOptions = tMap
	for i := 0; i < size; i++ {
		var _key16 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key16 = v
		}
		var _val17 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val17 = v
		}
		p.CompressionOptions[_key16] = _val17
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *CfDef) ReadField33(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 33: %s", err)
	} else {
		p.BloomFilterFpChance = &v
	}
	return nil
}

func (p *CfDef) ReadField34(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 34: %s", err)
	} else {
		p.Caching = v
	}
	return nil
}

func (p *CfDef) ReadField37(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 37: %s", err)
	} else {
		p.DclocalReadRepairChance = v
	}
	return nil
}

func (p *CfDef) ReadField38(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 38: %s", err)
	} else {
		p.PopulateIoCacheOnFlush = &v
	}
	return nil
}

func (p *CfDef) ReadField9(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 9: %s", err)
	} else {
		p.RowCacheSize = &v
	}
	return nil
}

func (p *CfDef) ReadField11(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 11: %s", err)
	} else {
		p.KeyCacheSize = &v
	}
	return nil
}

func (p *CfDef) ReadField19(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 19: %s", err)
	} else {
		p.RowCacheSavePeriodInSeconds = &v
	}
	return nil
}

func (p *CfDef) ReadField20(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 20: %s", err)
	} else {
		p.KeyCacheSavePeriodInSeconds = &v
	}
	return nil
}

func (p *CfDef) ReadField21(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 21: %s", err)
	} else {
		p.MemtableFlushAfterMins = &v
	}
	return nil
}

func (p *CfDef) ReadField22(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 22: %s", err)
	} else {
		p.MemtableThroughputInMb = &v
	}
	return nil
}

func (p *CfDef) ReadField23(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 23: %s", err)
	} else {
		p.MemtableOperationsInMillions = &v
	}
	return nil
}

func (p *CfDef) ReadField25(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 25: %s", err)
	} else {
		p.MergeShardsChance = &v
	}
	return nil
}

func (p *CfDef) ReadField27(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 27: %s", err)
	} else {
		p.RowCacheProvider = &v
	}
	return nil
}

func (p *CfDef) ReadField31(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 31: %s", err)
	} else {
		p.RowCacheKeysToSave = &v
	}
	return nil
}

func (p *CfDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField8(oprot); err != nil {
		return err
	}
	if err := p.writeField9(oprot); err != nil {
		return err
	}
	if err := p.writeField11(oprot); err != nil {
		return err
	}
	if err := p.writeField12(oprot); err != nil {
		return err
	}
	if err := p.writeField13(oprot); err != nil {
		return err
	}
	if err := p.writeField14(oprot); err != nil {
		return err
	}
	if err := p.writeField15(oprot); err != nil {
		return err
	}
	if err := p.writeField16(oprot); err != nil {
		return err
	}
	if err := p.writeField17(oprot); err != nil {
		return err
	}
	if err := p.writeField18(oprot); err != nil {
		return err
	}
	if err := p.writeField19(oprot); err != nil {
		return err
	}
	if err := p.writeField20(oprot); err != nil {
		return err
	}
	if err := p.writeField21(oprot); err != nil {
		return err
	}
	if err := p.writeField22(oprot); err != nil {
		return err
	}
	if err := p.writeField23(oprot); err != nil {
		return err
	}
	if err := p.writeField24(oprot); err != nil {
		return err
	}
	if err := p.writeField25(oprot); err != nil {
		return err
	}
	if err := p.writeField26(oprot); err != nil {
		return err
	}
	if err := p.writeField27(oprot); err != nil {
		return err
	}
	if err := p.writeField28(oprot); err != nil {
		return err
	}
	if err := p.writeField29(oprot); err != nil {
		return err
	}
	if err := p.writeField30(oprot); err != nil {
		return err
	}
	if err := p.writeField31(oprot); err != nil {
		return err
	}
	if err := p.writeField32(oprot); err != nil {
		return err
	}
	if err := p.writeField33(oprot); err != nil {
		return err
	}
	if err := p.writeField34(oprot); err != nil {
		return err
	}
	if err := p.writeField37(oprot); err != nil {
		return err
	}
	if err := p.writeField38(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CfDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnType() {
		if err := oprot.WriteFieldBegin("column_type", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column_type: %s", p, err)
		}
		if err := oprot.WriteString(string(p.ColumnType)); err != nil {
			return fmt.Errorf("%T.column_type (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetComparatorType() {
		if err := oprot.WriteFieldBegin("comparator_type", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:comparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(p.ComparatorType)); err != nil {
			return fmt.Errorf("%T.comparator_type (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:comparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetSubcomparatorType() {
		if err := oprot.WriteFieldBegin("subcomparator_type", thrift.STRING, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:subcomparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.SubcomparatorType)); err != nil {
			return fmt.Errorf("%T.subcomparator_type (6) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:subcomparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin("comment", thrift.STRING, 8); err != nil {
			return fmt.Errorf("%T write field begin error 8:comment: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Comment)); err != nil {
			return fmt.Errorf("%T.comment (8) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 8:comment: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSize() {
		if err := oprot.WriteFieldBegin("row_cache_size", thrift.DOUBLE, 9); err != nil {
			return fmt.Errorf("%T write field begin error 9:row_cache_size: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.RowCacheSize)); err != nil {
			return fmt.Errorf("%T.row_cache_size (9) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 9:row_cache_size: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField11(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSize() {
		if err := oprot.WriteFieldBegin("key_cache_size", thrift.DOUBLE, 11); err != nil {
			return fmt.Errorf("%T write field begin error 11:key_cache_size: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.KeyCacheSize)); err != nil {
			return fmt.Errorf("%T.key_cache_size (11) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 11:key_cache_size: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetReadRepairChance() {
		if err := oprot.WriteFieldBegin("read_repair_chance", thrift.DOUBLE, 12); err != nil {
			return fmt.Errorf("%T write field begin error 12:read_repair_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.ReadRepairChance)); err != nil {
			return fmt.Errorf("%T.read_repair_chance (12) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 12:read_repair_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField13(oprot thrift.TProtocol) (err error) {
	if p.ColumnMetadata != nil {
		if p.IsSetColumnMetadata() {
			if err := oprot.WriteFieldBegin("column_metadata", thrift.LIST, 13); err != nil {
				return fmt.Errorf("%T write field begin error 13:column_metadata: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnMetadata)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.ColumnMetadata {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 13:column_metadata: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetGcGraceSeconds() {
		if err := oprot.WriteFieldBegin("gc_grace_seconds", thrift.I32, 14); err != nil {
			return fmt.Errorf("%T write field begin error 14:gc_grace_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.GcGraceSeconds)); err != nil {
			return fmt.Errorf("%T.gc_grace_seconds (14) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 14:gc_grace_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetDefaultValidationClass() {
		if err := oprot.WriteFieldBegin("default_validation_class", thrift.STRING, 15); err != nil {
			return fmt.Errorf("%T write field begin error 15:default_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.DefaultValidationClass)); err != nil {
			return fmt.Errorf("%T.default_validation_class (15) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 15:default_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetId() {
		if err := oprot.WriteFieldBegin("id", thrift.I32, 16); err != nil {
			return fmt.Errorf("%T write field begin error 16:id: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Id)); err != nil {
			return fmt.Errorf("%T.id (16) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 16:id: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetMinCompactionThreshold() {
		if err := oprot.WriteFieldBegin("min_compaction_threshold", thrift.I32, 17); err != nil {
			return fmt.Errorf("%T write field begin error 17:min_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MinCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.min_compaction_threshold (17) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 17:min_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField18(oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxCompactionThreshold() {
		if err := oprot.WriteFieldBegin("max_compaction_threshold", thrift.I32, 18); err != nil {
			return fmt.Errorf("%T write field begin error 18:max_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MaxCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.max_compaction_threshold (18) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 18:max_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField19(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("row_cache_save_period_in_seconds", thrift.I32, 19); err != nil {
			return fmt.Errorf("%T write field begin error 19:row_cache_save_period_in_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.RowCacheSavePeriodInSeconds)); err != nil {
			return fmt.Errorf("%T.row_cache_save_period_in_seconds (19) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 19:row_cache_save_period_in_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField20(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("key_cache_save_period_in_seconds", thrift.I32, 20); err != nil {
			return fmt.Errorf("%T write field begin error 20:key_cache_save_period_in_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.KeyCacheSavePeriodInSeconds)); err != nil {
			return fmt.Errorf("%T.key_cache_save_period_in_seconds (20) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 20:key_cache_save_period_in_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField21(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableFlushAfterMins() {
		if err := oprot.WriteFieldBegin("memtable_flush_after_mins", thrift.I32, 21); err != nil {
			return fmt.Errorf("%T write field begin error 21:memtable_flush_after_mins: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MemtableFlushAfterMins)); err != nil {
			return fmt.Errorf("%T.memtable_flush_after_mins (21) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 21:memtable_flush_after_mins: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField22(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableThroughputInMb() {
		if err := oprot.WriteFieldBegin("memtable_throughput_in_mb", thrift.I32, 22); err != nil {
			return fmt.Errorf("%T write field begin error 22:memtable_throughput_in_mb: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.MemtableThroughputInMb)); err != nil {
			return fmt.Errorf("%T.memtable_throughput_in_mb (22) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 22:memtable_throughput_in_mb: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField23(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableOperationsInMillions() {
		if err := oprot.WriteFieldBegin("memtable_operations_in_millions", thrift.DOUBLE, 23); err != nil {
			return fmt.Errorf("%T write field begin error 23:memtable_operations_in_millions: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.MemtableOperationsInMillions)); err != nil {
			return fmt.Errorf("%T.memtable_operations_in_millions (23) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 23:memtable_operations_in_millions: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField24(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicateOnWrite() {
		if err := oprot.WriteFieldBegin("replicate_on_write", thrift.BOOL, 24); err != nil {
			return fmt.Errorf("%T write field begin error 24:replicate_on_write: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.ReplicateOnWrite)); err != nil {
			return fmt.Errorf("%T.replicate_on_write (24) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 24:replicate_on_write: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField25(oprot thrift.TProtocol) (err error) {
	if p.IsSetMergeShardsChance() {
		if err := oprot.WriteFieldBegin("merge_shards_chance", thrift.DOUBLE, 25); err != nil {
			return fmt.Errorf("%T write field begin error 25:merge_shards_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.MergeShardsChance)); err != nil {
			return fmt.Errorf("%T.merge_shards_chance (25) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 25:merge_shards_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField26(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyValidationClass() {
		if err := oprot.WriteFieldBegin("key_validation_class", thrift.STRING, 26); err != nil {
			return fmt.Errorf("%T write field begin error 26:key_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.KeyValidationClass)); err != nil {
			return fmt.Errorf("%T.key_validation_class (26) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 26:key_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField27(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheProvider() {
		if err := oprot.WriteFieldBegin("row_cache_provider", thrift.STRING, 27); err != nil {
			return fmt.Errorf("%T write field begin error 27:row_cache_provider: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.RowCacheProvider)); err != nil {
			return fmt.Errorf("%T.row_cache_provider (27) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 27:row_cache_provider: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField28(oprot thrift.TProtocol) (err error) {
	if p.KeyAlias != nil {
		if p.IsSetKeyAlias() {
			if err := oprot.WriteFieldBegin("key_alias", thrift.STRING, 28); err != nil {
				return fmt.Errorf("%T write field begin error 28:key_alias: %s", p, err)
			}
			if err := oprot.WriteBinary(p.KeyAlias); err != nil {
				return fmt.Errorf("%T.key_alias (28) field write error: %s", p, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 28:key_alias: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField29(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompactionStrategy() {
		if err := oprot.WriteFieldBegin("compaction_strategy", thrift.STRING, 29); err != nil {
			return fmt.Errorf("%T write field begin error 29:compaction_strategy: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.CompactionStrategy)); err != nil {
			return fmt.Errorf("%T.compaction_strategy (29) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 29:compaction_strategy: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField30(oprot thrift.TProtocol) (err error) {
	if p.CompactionStrategyOptions != nil {
		if p.IsSetCompactionStrategyOptions() {
			if err := oprot.WriteFieldBegin("compaction_strategy_options", thrift.MAP, 30); err != nil {
				return fmt.Errorf("%T write field begin error 30:compaction_strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompactionStrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range p.CompactionStrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 30:compaction_strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField31(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheKeysToSave() {
		if err := oprot.WriteFieldBegin("row_cache_keys_to_save", thrift.I32, 31); err != nil {
			return fmt.Errorf("%T write field begin error 31:row_cache_keys_to_save: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.RowCacheKeysToSave)); err != nil {
			return fmt.Errorf("%T.row_cache_keys_to_save (31) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 31:row_cache_keys_to_save: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField32(oprot thrift.TProtocol) (err error) {
	if p.CompressionOptions != nil {
		if p.IsSetCompressionOptions() {
			if err := oprot.WriteFieldBegin("compression_options", thrift.MAP, 32); err != nil {
				return fmt.Errorf("%T write field begin error 32:compression_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompressionOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range p.CompressionOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 32:compression_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField33(oprot thrift.TProtocol) (err error) {
	if p.IsSetBloomFilterFpChance() {
		if err := oprot.WriteFieldBegin("bloom_filter_fp_chance", thrift.DOUBLE, 33); err != nil {
			return fmt.Errorf("%T write field begin error 33:bloom_filter_fp_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.BloomFilterFpChance)); err != nil {
			return fmt.Errorf("%T.bloom_filter_fp_chance (33) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 33:bloom_filter_fp_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField34(oprot thrift.TProtocol) (err error) {
	if p.IsSetCaching() {
		if err := oprot.WriteFieldBegin("caching", thrift.STRING, 34); err != nil {
			return fmt.Errorf("%T write field begin error 34:caching: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Caching)); err != nil {
			return fmt.Errorf("%T.caching (34) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 34:caching: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField37(oprot thrift.TProtocol) (err error) {
	if p.IsSetDclocalReadRepairChance() {
		if err := oprot.WriteFieldBegin("dclocal_read_repair_chance", thrift.DOUBLE, 37); err != nil {
			return fmt.Errorf("%T write field begin error 37:dclocal_read_repair_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.DclocalReadRepairChance)); err != nil {
			return fmt.Errorf("%T.dclocal_read_repair_chance (37) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 37:dclocal_read_repair_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField38(oprot thrift.TProtocol) (err error) {
	if p.IsSetPopulateIoCacheOnFlush() {
		if err := oprot.WriteFieldBegin("populate_io_cache_on_flush", thrift.BOOL, 38); err != nil {
			return fmt.Errorf("%T write field begin error 38:populate_io_cache_on_flush: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.PopulateIoCacheOnFlush)); err != nil {
			return fmt.Errorf("%T.populate_io_cache_on_flush (38) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 38:populate_io_cache_on_flush: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfDef(%+v)", *p)
}

type KsDef struct {
	Name              string            `thrift:"name,1,required"`
	StrategyClass     string            `thrift:"strategy_class,2,required"`
	StrategyOptions   map[string]string `thrift:"strategy_options,3"`
	ReplicationFactor *int32            `thrift:"replication_factor,4"`
	CfDefs            []*CfDef          `thrift:"cf_defs,5,required"`
	DurableWrites     bool              `thrift:"durable_writes,6"`
}

func NewKsDef() *KsDef {
	return &KsDef{
		DurableWrites: true,
	}
}

func (p *KsDef) GetName() string {
	return p.Name
}

func (p *KsDef) GetStrategyClass() string {
	return p.StrategyClass
}

var KsDef_StrategyOptions_DEFAULT map[string]string

func (p *KsDef) GetStrategyOptions() map[string]string {
	return p.StrategyOptions
}

var KsDef_ReplicationFactor_DEFAULT int32

func (p *KsDef) GetReplicationFactor() int32 {
	if !p.IsSetReplicationFactor() {
		return KsDef_ReplicationFactor_DEFAULT
	}
	return *p.ReplicationFactor
}

func (p *KsDef) GetCfDefs() []*CfDef {
	return p.CfDefs
}

var KsDef_DurableWrites_DEFAULT bool = true

func (p *KsDef) GetDurableWrites() bool {
	return p.DurableWrites
}
func (p *KsDef) IsSetName() bool {
	return true
}

func (p *KsDef) IsSetStrategyClass() bool {
	return true
}

func (p *KsDef) IsSetStrategyOptions() bool {
	return p.StrategyOptions != nil
}

func (p *KsDef) IsSetReplicationFactor() bool {
	return p.ReplicationFactor != nil
}

func (p *KsDef) IsSetCfDefs() bool {
	return true
}

func (p *KsDef) IsSetDurableWrites() bool {
	return p.DurableWrites != KsDef_DurableWrites_DEFAULT
}

func (p *KsDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KsDef) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *KsDef) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StrategyClass = v
	}
	return nil
}

func (p *KsDef) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.StrategyOptions = tMap
	for i := 0; i < size; i++ {
		var _key18 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key18 = v
		}
		var _val19 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val19 = v
		}
		p.StrategyOptions[_key18] = _val19
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *KsDef) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.ReplicationFactor = &v
	}
	return nil
}

func (p *KsDef) ReadField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*CfDef, 0, size)
	p.CfDefs = tSlice
	for i := 0; i < size; i++ {
		_elem20 := NewCfDef()
		if err := _elem20.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem20, err)
		}
		p.CfDefs = append(p.CfDefs, _elem20)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *KsDef) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.DurableWrites = v
	}
	return nil
}

func (p *KsDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KsDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KsDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("strategy_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:strategy_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StrategyClass)); err != nil {
		return fmt.Errorf("%T.strategy_class (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:strategy_class: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StrategyOptions != nil {
		if p.IsSetStrategyOptions() {
			if err := oprot.WriteFieldBegin("strategy_options", thrift.MAP, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.StrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range p.StrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *KsDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicationFactor() {
		if err := oprot.WriteFieldBegin("replication_factor", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:replication_factor: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.ReplicationFactor)); err != nil {
			return fmt.Errorf("%T.replication_factor (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:replication_factor: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.CfDefs != nil {
		if err := oprot.WriteFieldBegin("cf_defs", thrift.LIST, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:cf_defs: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CfDefs)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.CfDefs {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:cf_defs: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetDurableWrites() {
		if err := oprot.WriteFieldBegin("durable_writes", thrift.BOOL, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:durable_writes: %s", p, err)
		}
		if err := oprot.WriteBool(bool(p.DurableWrites)); err != nil {
			return fmt.Errorf("%T.durable_writes (6) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:durable_writes: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KsDef(%+v)", *p)
}

type CqlRow struct {
	Key     []byte    `thrift:"key,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewCqlRow() *CqlRow {
	return &CqlRow{}
}

func (p *CqlRow) GetKey() []byte {
	return p.Key
}

func (p *CqlRow) GetColumns() []*Column {
	return p.Columns
}
func (p *CqlRow) IsSetKey() bool {
	return true
}

func (p *CqlRow) IsSetColumns() bool {
	return true
}

func (p *CqlRow) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlRow) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *CqlRow) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Column, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		_elem21 := NewColumn()
		if err := _elem21.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem21, err)
		}
		p.Columns = append(p.Columns, _elem21)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CqlRow) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlRow"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlRow) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlRow(%+v)", *p)
}

type CqlMetadata struct {
	NameTypes        map[string]string `thrift:"name_types,1,required"`
	ValueTypes       map[string]string `thrift:"value_types,2,required"`
	DefaultNameType  string            `thrift:"default_name_type,3,required"`
	DefaultValueType string            `thrift:"default_value_type,4,required"`
}

func NewCqlMetadata() *CqlMetadata {
	return &CqlMetadata{}
}

func (p *CqlMetadata) GetNameTypes() map[string]string {
	return p.NameTypes
}

func (p *CqlMetadata) GetValueTypes() map[string]string {
	return p.ValueTypes
}

func (p *CqlMetadata) GetDefaultNameType() string {
	return p.DefaultNameType
}

func (p *CqlMetadata) GetDefaultValueType() string {
	return p.DefaultValueType
}
func (p *CqlMetadata) IsSetNameTypes() bool {
	return true
}

func (p *CqlMetadata) IsSetValueTypes() bool {
	return true
}

func (p *CqlMetadata) IsSetDefaultNameType() bool {
	return true
}

func (p *CqlMetadata) IsSetDefaultValueType() bool {
	return true
}

func (p *CqlMetadata) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlMetadata) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.NameTypes = tMap
	for i := 0; i < size; i++ {
		var _key22 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key22 = v
		}
		var _val23 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val23 = v
		}
		p.NameTypes[_key22] = _val23
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *CqlMetadata) ReadField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.ValueTypes = tMap
	for i := 0; i < size; i++ {
		var _key24 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key24 = v
		}
		var _val25 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val25 = v
		}
		p.ValueTypes[_key24] = _val25
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *CqlMetadata) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.DefaultNameType = v
	}
	return nil
}

func (p *CqlMetadata) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.DefaultValueType = v
	}
	return nil
}

func (p *CqlMetadata) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlMetadata"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlMetadata) writeField1(oprot thrift.TProtocol) (err error) {
	if p.NameTypes != nil {
		if err := oprot.WriteFieldBegin("name_types", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.NameTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.NameTypes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ValueTypes != nil {
		if err := oprot.WriteFieldBegin("value_types", thrift.MAP, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:value_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.ValueTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.ValueTypes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:value_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_name_type", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:default_name_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultNameType)); err != nil {
		return fmt.Errorf("%T.default_name_type (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:default_name_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_value_type", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:default_value_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultValueType)); err != nil {
		return fmt.Errorf("%T.default_value_type (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:default_value_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlMetadata(%+v)", *p)
}

type CqlResult_ struct {
	TypeA1 CqlResultType `thrift:"type,1,required"`
	Rows   []*CqlRow     `thrift:"rows,2"`
	Num    *int32        `thrift:"num,3"`
	Schema *CqlMetadata  `thrift:"schema,4"`
}

func NewCqlResult_() *CqlResult_ {
	return &CqlResult_{}
}

func (p *CqlResult_) GetTypeA1() CqlResultType {
	return p.TypeA1
}

var CqlResult__Rows_DEFAULT []*CqlRow

func (p *CqlResult_) GetRows() []*CqlRow {
	return p.Rows
}

var CqlResult__Num_DEFAULT int32

func (p *CqlResult_) GetNum() int32 {
	if !p.IsSetNum() {
		return CqlResult__Num_DEFAULT
	}
	return *p.Num
}

var CqlResult__Schema_DEFAULT *CqlMetadata

func (p *CqlResult_) GetSchema() *CqlMetadata {
	return p.Schema
}
func (p *CqlResult_) IsSetTypeA1() bool {
	return true
}

func (p *CqlResult_) IsSetRows() bool {
	return p.Rows != nil
}

func (p *CqlResult_) IsSetNum() bool {
	return p.Num != nil
}

func (p *CqlResult_) IsSetSchema() bool {
	return p.Schema != CqlResult__Schema_DEFAULT
}

func (p *CqlResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlResult_) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := CqlResultType(v)
		p.TypeA1 = temp
	}
	return nil
}

func (p *CqlResult_) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*CqlRow, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		_elem26 := NewCqlRow()
		if err := _elem26.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem26, err)
		}
		p.Rows = append(p.Rows, _elem26)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CqlResult_) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Num = &v
	}
	return nil
}

func (p *CqlResult_) ReadField4(iprot thrift.TProtocol) error {
	p.Schema = NewCqlMetadata()
	if err := p.Schema.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Schema, err)
	}
	return nil
}

func (p *CqlResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:type: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.TypeA1)); err != nil {
		return fmt.Errorf("%T.type (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:type: %s", p, err)
	}
	return err
}

func (p *CqlResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if p.IsSetRows() {
			if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Rows)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.Rows {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult_) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNum() {
		if err := oprot.WriteFieldBegin("num", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:num: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Num)); err != nil {
			return fmt.Errorf("%T.num (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:num: %s", p, err)
		}
	}
	return err
}

func (p *CqlResult_) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Schema != nil {
		if p.IsSetSchema() {
			if err := oprot.WriteFieldBegin("schema", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:schema: %s", p, err)
			}
			if err := p.Schema.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Schema, err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:schema: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlResult_(%+v)", *p)
}

type CqlPreparedResult_ struct {
	ItemId        int32    `thrift:"itemId,1,required"`
	Count         int32    `thrift:"count,2,required"`
	VariableTypes []string `thrift:"variable_types,3"`
	VariableNames []string `thrift:"variable_names,4"`
}

func NewCqlPreparedResult_() *CqlPreparedResult_ {
	return &CqlPreparedResult_{}
}

func (p *CqlPreparedResult_) GetItemId() int32 {
	return p.ItemId
}

func (p *CqlPreparedResult_) GetCount() int32 {
	return p.Count
}

var CqlPreparedResult__VariableTypes_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableTypes() []string {
	return p.VariableTypes
}

var CqlPreparedResult__VariableNames_DEFAULT []string

func (p *CqlPreparedResult_) GetVariableNames() []string {
	return p.VariableNames
}
func (p *CqlPreparedResult_) IsSetItemId() bool {
	return true
}

func (p *CqlPreparedResult_) IsSetCount() bool {
	return true
}

func (p *CqlPreparedResult_) IsSetVariableTypes() bool {
	return p.VariableTypes != nil
}

func (p *CqlPreparedResult_) IsSetVariableNames() bool {
	return p.VariableNames != nil
}

func (p *CqlPreparedResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlPreparedResult_) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CqlPreparedResult_) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Count = v
	}
	return nil
}

func (p *CqlPreparedResult_) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.VariableTypes = tSlice
	for i := 0; i < size; i++ {
		var _elem27 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem27 = v
		}
		p.VariableTypes = append(p.VariableTypes, _elem27)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CqlPreparedResult_) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]string, 0, size)
	p.VariableNames = tSlice
	for i := 0; i < size; i++ {
		var _elem28 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem28 = v
		}
		p.VariableNames = append(p.VariableNames, _elem28)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CqlPreparedResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlPreparedResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlPreparedResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult_) writeField3(oprot thrift.TProtocol) (err error) {
	if p.VariableTypes != nil {
		if p.IsSetVariableTypes() {
			if err := oprot.WriteFieldBegin("variable_types", thrift.LIST, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:variable_types: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableTypes)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.VariableTypes {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:variable_types: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlPreparedResult_) writeField4(oprot thrift.TProtocol) (err error) {
	if p.VariableNames != nil {
		if p.IsSetVariableNames() {
			if err := oprot.WriteFieldBegin("variable_names", thrift.LIST, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:variable_names: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableNames)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range p.VariableNames {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:variable_names: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlPreparedResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlPreparedResult_(%+v)", *p)
}

type CfSplit struct {
	StartToken string `thrift:"start_token,1,required"`
	EndToken   string `thrift:"end_token,2,required"`
	RowCount   int64  `thrift:"row_count,3,required"`
}

func NewCfSplit() *CfSplit {
	return &CfSplit{}
}

func (p *CfSplit) GetStartToken() string {
	return p.StartToken
}

func (p *CfSplit) GetEndToken() string {
	return p.EndToken
}

func (p *CfSplit) GetRowCount() int64 {
	return p.RowCount
}
func (p *CfSplit) IsSetStartToken() bool {
	return true
}

func (p *CfSplit) IsSetEndToken() bool {
	return true
}

func (p *CfSplit) IsSetRowCount() bool {
	return true
}

func (p *CfSplit) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CfSplit) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *CfSplit) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *CfSplit) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.RowCount = v
	}
	return nil
}

func (p *CfSplit) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfSplit"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CfSplit) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_token: %s", p, err)
	}
	return err
}

func (p *CfSplit) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_token: %s", p, err)
	}
	return err
}

func (p *CfSplit) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row_count", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row_count: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.RowCount)); err != nil {
		return fmt.Errorf("%T.row_count (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row_count: %s", p, err)
	}
	return err
}

func (p *CfSplit) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfSplit(%+v)", *p)
}
